# Rust编码规范说明

## 1. 总体要求

在编写/修改代码时，你使用**中文**编写注释，并遵循以下规范：

- **语言级别:** `Rust 2024 Edition`
- **目标:** 极其严谨、可维护、可审计；代码清晰易读；在最严格工具链下 **0 Warning**。
- **强制工具约束（必须通过）:**
    - `cargo fmt --all --check`
    - `cargo clippy --all-targets --all-features -- -D warnings`
    - `cargo test --all --all-features`
    - `cargo test --doc --all-features`（文档注释必须可测试）
- **严格零警告含义（示例，不限于此）:**
    - 不声明不使用的变量/导入/依赖。
    - 不需要可变的变量**不得**声明为 `mut`（同时确保通过 `clippy::needless_mut` 等相关lint）。
    - 不需要分配/克隆时**不得**无谓 `clone()`/`to_string()`/`Vec::from`。
    - 不得使用“先写出来再说”的占位代码；确需占位应使用明确的 `todo!()` 并附带任务编号/原因/边界（且不得进入主分支产物）。
- **更接近Rust官方风格的额外约束（强制）:**
    - 默认禁止 `unsafe`：优先 `#![forbid(unsafe_code)]`；若必须使用，需在同文件中以最小封装边界隔离，并用文档注释声明不变量与安全性前提。
    - 公共API稳定性优先：避免暴露内部实现细节；优先通过类型系统表达约束（而不是靠注释/约定）。
    - 依赖最小化：不引入未使用/仅为“方便”的crate；引入必须有明确价值与替代方案说明（写在模块文档注释中即可）。

---

## 2. 时间信息维护（修改代码必须同步更新）

任何修改代码的行为，都必须同步更新对应的**时间信息**到最新，且保持一致性：

- 每个文件（模块）开头的模块级文档注释（`//!`）必须包含：
    - `作者: WaterRun`
    - `更新于: YYYY-MM-DD`
- 若文件内存在协议/数据格式/行为约定的时间戳说明：
    - 必须更新到本次修改的实际日期，并确保同文件内不出现相互矛盾的日期。

---

## 3. 类型与API约束（强类型、清晰边界）

- Rust 是静态强类型语言，编译器可推导类型，但在以下位置必须明确标注类型：
    - 函数签名（参数与返回值）
    - 结构体字段
    - 公共 `pub` API
    - 重要 type alias（尤其是跨模块/跨层级语义边界的别名）
- 善用高级类型能力：
    - 泛型 + trait bounds + 关联类型
    - 生命周期参数（必要且最小化暴露）
    - `impl Trait` 简化返回类型（避免暴露内部实现细节）
- 公共API设计遵循 Rust API 习惯：
    - 语义稳定、错误可诊断、命名一致、行为可预期
    - 能用类型表达的不使用运行时检查/魔法值/隐式约定

---

## 4. 编码规范与风格（rustfmt + Clippy + 代码可读性）

- **格式化:** 严格使用 `rustfmt`，不允许手工风格分歧。
- **lint策略（同文件可设置crate级属性）:**
    - `#![deny(warnings)]`（或至少确保等效：`clippy -D warnings`）
    - `#![deny(missing_docs)]`（公共API必须有文档）
    - `#![forbid(unsafe_code)]`（默认禁止；如必须使用，见“总体要求”）
- **可读性优先规则（强制）:**
    - 函数短小、单一职责；超过合理长度必须拆分。
    - 命名表达意图，避免 `tmp/data/foo` 等无语义名。
    - 复杂逻辑用类型/结构化拆解表达，而不是堆注释。
    - 尽量减少“聪明写法”；在清晰与微小性能收益冲突时优先清晰（除非有明确基准证据）。
- **可变性规则（强制，0 Warning导向）:**
    - 默认 `let`；只有确有必要才 `let mut`。
    - 不需可变的绑定/字段/引用不得可变（满足 `clippy::needless_mut` / `clippy::unused_mut` 等）。
    - 缩小可变借用作用域：能在更小块内完成修改就不要跨越更大作用域。
- **未使用值处理（强制）:**
    - 不允许“声明但不使用”。
    - 确需忽略返回值时使用 `let _ = expr;` 或 `_ = expr;`（表达“刻意忽略”）。
    - 迭代中未使用的变量使用 `_` 或 `_name`，且必须是语义上确实不需要。

---

## 5. 错误处理（Result/Option，避免panic）

- 使用 `Result<T, E>` 与 `Option<T>` 表达失败与缺失。
- 避免 `panic! / unwrap() / expect()`：
    - **生产代码**默认禁止；确需不可恢复逻辑错误时必须给出严格不变量说明（写在相关API的文档注释中）。
    - **测试代码**允许 `unwrap/expect`，但失败信息必须清晰可定位。
- 错误类型策略（单文件视角）：
    - 可枚举错误：优先自定义 `enum`（可配合 `thiserror`），保证可匹配与可诊断。
    - 应用层聚合：可用 `anyhow`，但边界处仍需结构化信息（至少错误上下文清晰）。

---

## 6. 文档注释（rustdoc）与“就近测试”（强制）

> “就近的测试”指**写在文档注释中的doctest**：用于验证该API/类型的**基本功能与典型用法**，保持短小、直观、可运行。

- 在以下位置必须写**rustdoc**文档注释：
    - 文件（模块）开头：`//!`
    - 所有公共 `pub` 的函数/结构体/枚举/trait/宏：`///`
- 文档注释必须包含可执行示例，且通过 doctest：
    - 示例使用 ` ```rust ` 代码块，确保 `cargo test --doc --all-features` 通过。
    - 文档示例用于**基本功能验证**：
        - 1～3个短例子覆盖“正常路径”的关键点
        - 避免在文档里堆边界与组合矩阵（这些进入统一单元测试）
    - 对于需要不可运行/仅编译检查的示例，使用：
        - ` ```rust,no_run `（编译但不运行）
        - ` ```compile_fail `（用于验证错误用法）
        - ` ```rust,ignore `（仅在有充分理由时使用，并在文档中说明原因）
- 公共API的文档最低要求：
    - 语义（解决什么问题）
    - 参数/返回值/错误语义
    - `# Examples`（至少1个可测试例子）

---

## 7. 统一单元测试（高覆盖率，放到文件最后）

> 单元测试统一放在文件最后，追求高覆盖率与边缘条件覆盖；与文档示例分工明确：
> - 文档示例：基本功能与典型用法（短）
> - 单元测试：高覆盖率、边界情况、错误分支、组合验证（全）

- 单元测试统一放在文件末尾：
    - `#[cfg(test)] mod tests { ... }`
- 覆盖要求（强制）：
    - 关键逻辑分支必须覆盖（成功/失败路径）
    - 边界条件必须覆盖（空值、最小/最大、溢出/截断、非法输入等按语义定义）
    - 错误分支必须断言错误类型/错误码/错误消息关键片段（避免“只断言失败”）
- 测试命名与结构：
    - 测试名表达行为与条件：`should_xxx_when_yyy`
    - 避免脆弱测试（不要过度依赖内部实现细节）
    - 失败信息清晰可定位（必要时使用 `assert!(.., "context: ...")`）

---

## 8. 命名约定

- **snake_case**: 变量名、函数名、模块名、宏名、字段名（如 `user_name`, `get_total`）
- **SCREAMING_SNAKE_CASE**: 常量、静态变量（如 `MAX_SIZE`, `DEFAULT_TIMEOUT`）
- **PascalCase**: 类型名、trait名、枚举名、枚举变体（如 `DataProcessor`, `ProcessingStatus::Pending`）
- **'a, 'b**: 生命周期参数（如 `'static`, `'a`）
- **T, U, K, V**: 泛型类型参数（如 `T`, `ResultT`）

---

## 9. 文件结构（模块组织顺序）

每个 Rust 文件（模块）必须按以下顺序组织：

1. 模块级文档注释（`//!`，含作者与最后更新日期）
2. 属性声明（`#![...]` / `#[...]`）
3. `use` 语句（按 标准库 / 外部crate / 当前crate 分组；组内按字母序）
4. 模块声明（`mod`，若存在）
5. 常量定义
6. 类型定义（`struct`、`enum`、type alias、`trait`）
7. `impl`（按类型分组，先固有实现再trait实现）
8. 函数定义（按可见性与用途分组）
9. `#[cfg(test)]` 测试模块（**统一放在文件最后**）

---

## 10. 代码即文档（最终原则）

- **原则:** 最大化代码可读性，同时保证库级别高质量规范。
- 除文档注释外尽量减少零散注释；优先通过：
    - 更好的命名
    - 类型与结构拆解
    - 明确的不变量封装
      来表达意图。
- 任何“看起来不直观”的实现都必须满足至少其一：
    - 文档注释中给出可测试示例或不变量说明
    - 有基准/性能约束证据证明必要性
    - 有清晰的审计点与回退策略
