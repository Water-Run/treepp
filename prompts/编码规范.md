# Rust编码规范说明  

在编写代码时, 你使用中文编写注释, 并遵循以下的编码规范.  

**语言级别:** `Rust 2024 Edition`  
**类型注解:** Rust是静态强类型语言，编译器会进行类型推导，但在函数签名、结构体字段、公共API中必须明确标注类型。善用泛型、trait bounds、关联类型、生命周期参数等高级类型特性  
**编码规范:** 严格遵循Rust官方风格指南(rustfmt)和Clippy规范。代码需要在`cargo clippy -- -D warnings`最严格模式下无Warning。采用现代Rust习惯用法，包括：使用`?`运算符进行错误传播、使用`if let`/`while let`进行模式匹配、使用迭代器链式调用、使用`impl Trait`简化返回类型、使用`async/await`异步编程、使用宏(macro_rules!、过程宏)、使用`const fn`和`const generics`等。遵循所有权、借用、生命周期规则，避免不必要的克隆和分配  
**错误处理:** 使用`Result<T, E>`和`Option<T>`进行错误处理，避免panic(除非是不可恢复的逻辑错误)。使用`thiserror`或`anyhow`库优化错误处理  
**文档注释:** 在所有的文件(模块)开头、所有公共(pub)函数、结构体、枚举、trait、宏上都要有遵循rustdoc标准的文档注释(三斜线`///`或模块级`//!`)。代码即文档的编码规范：代码需要尽可能的自描述、易懂，减少非文档注释之外的注释内容。

## 命名约定

- **snake_case**: 变量名、函数名、模块名、宏名、字段名 (如 `user_name`, `get_total`)
- **SCREAMING_SNAKE_CASE**: 常量、静态变量 (如 `MAX_SIZE`, `DEFAULT_TIMEOUT`)
- **PascalCase**: 类型名、trait名、枚举名、枚举变体 (如 `DataProcessor`, `ProcessingStatus::Pending`)
- **'a, 'b**: 生命周期参数 (如 `'static`, `'a`)
- **T, U, K, V**: 泛型类型参数 (如 `T`, `TResult`)

## 文件结构

每个Rust文件(模块)必须按以下顺序组织：

1. 模块级文档注释(`//!`)
2. 属性声明(`#![...]`)
3. use语句(按标准库、外部crate、当前crate分组，组内按字母顺序)
4. 模块声明(`mod`)
5. 常量定义
6. 类型定义(struct、enum、type alias、trait)
7. trait实现
8. 函数定义

单元测试合理整合进代码中, 涵盖完整的边缘情况.  
**原则**: 最大话代码的可读性, 同时保证库级别的高质量规范, 代码即文档的风格, 除了文档注释外尽量减少其它注释, 而是通过代码本身表达.  
