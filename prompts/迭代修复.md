考虑我的项目:  

# `tree++`: 好的多的Windows`tree`命令

*[English](./README.md)*

Windows上的`tree`命令自从近40年前发布以来几乎就没有改动. 在如今LLM的时代, 作为描述项目结构非常常用的工具, 仅有的`/f`和`/a`两个参数的功能显然捉襟见肘. 同时, 它很慢.

**`tree++`是对`tree`的一次全面升级**, 为Windows平台下的`tree`命令引入了:

- ***扩展参数集, 支持功能涵盖包括显示文件大小, 递归深度限制, 修改输出风格, 将结果输出至文件, 及排除指定目录(包括遵循`.gitignore`)等常用功能***
- ***支持多线程, 在大且复杂的目录中提供显著的性能提升***
- ***与原有的Windows`tree`命令参数和输出完全兼容, 并兼容使用Unix风格的参数(如`-f`和`--files`)***

**`tree++`使用`Rust`实现**, 开源于[GitHub](https://github.com/Water-Run/treepp).

*性能对比(以`C:\Windows`为示例):*

| 类型                | 耗时(`ms`)   | 倍率    |
| ----------------- | ---------- | ----- |
| 原生`tree`          | `34055.50` | 1.0x  |
| `treepp`(默认, 8线程) | `3480.12`  | 9.79x |
| `treepp`(1线程)     | `6687.58`  | 5.09x |

## 安装

从[Release](https://github.com/Water-Run/treepp/releases/tag/0.1.0)下载`tree++.zip`, 解压到合适目录, 并将目录添加至环境变量.

开启Windows终端, 执行:

```powershell
treepp /v
```

有输出:

```plaintext
tree++ version 0.1.0

A Better tree command for Windows.

author: WaterRun
link: https://github.com/Water-Run/treepp
```

即完成安装.

随后, 你可以以和普通的Windows `tree`命令一样的方式使用:

```powershell
treepp /f
```

## 速览

| 参数集(等价写法)                                       | 说明                                         |
| ----------------------------------------------- | ------------------------------------------ |
| `--help` `-h` `/?`                              | 显示帮助信息                                     |
| `--version` `-v` `/V`                           | 显示版本信息                                     |
| `--ascii` `-a` `/A`                             | 使用 ASCII 字符绘制树                             |
| `--files` `-f` `/F`                             | 显示文件                                       |
| `--full-path` `-p` `/FP`                        | 显示完整路径                                     |
| `--human-readable` `-H` `/HR`                   | 以人类可读方式显示文件大小                              |
| `--no-indent` `-i` `/NI`                        | 不显示树形连接线                                   |
| `--reverse` `-r` `/R`                           | 逆序排序                                       |
| `--size` `-s` `/S`                              | 显示文件大小(字节)                                 |
| `--date` `-d` `/DT`                             | 显示最后修改日期                                   |
| `--exclude` `-I` `/X`                           | 排除匹配的文件                                    |
| `--level` `-L` `/L`                             | 限制递归深度                                     |
| `--include` `-m` `/M`                           | 仅显示匹配的文件                                   |
| `--disk-usage` `-u` `/DU`                       | 显示目录累计大小                                   |
| `--ignore-case` `-c` `/IC`                      | 匹配时忽略大小写                                   |
| `--report` `-e` `/RP`                           | 显示末尾统计信息                                   |
| `--prune` `-P` `/P`                             | 修剪空目录                                      |
| `--sort` `-S` `/SO` | 指定排序方式(`name`、`size`、`mtime` 等)            |
| `--no-win-banner` `-N` `/NB`                    | 不显示 Windows 原生 tree 的样板信息                  |
| `--silent` `-l` `/SI`                           | 终端静默(结合`output`指令使用)                       |
| `--output` `-o` `/O`                            | 将结果输出至文件(`.txt`, `.json`, `.yml`, `.toml`) |
| `--thread` `-t` `/T`                            | 扫描线程数(默认为8)                                |
| `--gitignore` `-g` `/G`                         | 遵循`.gitignore`                             |

> 完整参数集参阅: [tree++参数集文档](./OPTIONS-zh.md)


# `tree++`: 完整参数说明和示例文档

本文档简述 [tree++](https://github.com/Water-Run/treepp) 所支持的全部参数与使用示例。

## 模拟目录

指令的示例输出基于此模拟目录：

```powershell
PS D:\Rust\tree++> treepp /F
卷 存储 的文件夹 PATH 列表
卷序列号为 26E9-52C1
D:\Rust\tree++
│  Cargo.toml
│  LICENSE
│  OPTIONS-zh.md
│  OPTIONS.md
│  README-zh.md
│  README.md
│
└─src
        cli.rs
        config.rs
        main.rs
        error.rs
        output.rs
        render.rs
        scan.rs
```

> `treepp /F` 与 Windows 原生 `tree /F` 行为完全一致：显示卷头信息和树形结构。直接执行 `treepp` 时亦保持原始语义仅展示目录结构。

## 全局用法

```powershell
treepp [<PATH>] [<OPTIONS>...]
```

- `<PATH>`：可选，默认为当前目录。
- `<OPTIONS>`：可重复、可混用。支持下表列出的 `--`（GNU）、`-`（短参数）与 `/`（CMD，大小写不敏感）三种形式。

## 指令的具体说明

### `/?`: 显示帮助

**功能：** 显示完整的参数帮助信息。

**语法：**

```powershell
treepp (--help | -h | /?) [<PATH>]
```

**示例：**

```powershell
PS D:\Rust\tree++> treepp /?
tree++ - a better tree command for Windows
Usage:
  treepp [path] [options]
Options:
  /H, /?, -h, --help        Show help information
  /V, -v, --version     Show version information
  ...
```

### `/V`: 显示版本

**功能：** 输出当前版本信息。

**语法：**

```powershell
treepp (--version | -v | /V)
```

**示例：**

```powershell
PS D:\Rust\tree++> treepp /V
tree++ version 0.1.0
author: WaterRun
link: https://github.com/Water-Run/treepp
```

### `/A`: 使用 ASCII 字符绘制树

**功能：** 以 ASCII 树形字符输出，兼容 `tree /A`。

**语法：**

```powershell
treepp (--ascii | -a | /A) [<PATH>]
```

**示例：**

```powershell
PS D:\Rust\tree++> treepp /A
卷 存储 的文件夹 PATH 列表
卷序列号为 26E9-52C1
D:\Rust\tree++
\---src
```

### `/F`: 显示文件

**功能：** 在目录树中列出文件条目。

**语法：**

```powershell
treepp (--files | -f | /F) [<PATH>]
```

**示例（与 `/A` 组合）：**

```powershell
PS D:\Rust\tree++> treepp /A /F
卷 存储 的文件夹 PATH 列表
卷序列号为 26E9-52C1
D:\Rust\tree++
|   Cargo.toml
|   LICENSE
|   OPTIONS-zh.md
|   OPTIONS.md
|   README-zh.md
|   README.md
|
\---src
        cli.rs
        config.rs
        main.rs
        error.rs
        output.rs
        render.rs
        scan.rs
```

### `/FP`: 显示完整路径

**功能：** 以绝对路径展示所有条目。

**语法：**

```powershell
treepp (--full-path | -p | /FP) [<PATH>]
```

**示例（与 `/F` 组合）：**

```powershell
PS D:\Rust\tree++> treepp /F /FP
卷 存储 的文件夹 PATH 列表
卷序列号为 26E9-52C1
D:\Rust\tree++
│  D:\Rust\tree++\Cargo.toml
│  D:\Rust\tree++\LICENSE
│  D:\Rust\tree++\OPTIONS-zh.md
│  D:\Rust\tree++\OPTIONS.md
│  D:\Rust\tree++\README-zh.md
│  D:\Rust\tree++\README.md
│
└─D:\Rust\tree++\src
        D:\Rust\tree++\src\cli.rs
        D:\Rust\tree++\src\config.rs
        D:\Rust\tree++\src\main.rs
        D:\Rust\tree++\src\output.rs
        D:\Rust\tree++\src\render.rs
        D:\Rust\tree++\src\scan.rs
```

### `/HR`: 人类可读文件大小

**功能：** 将文件大小转换为 B/KB/MB 等易读单位，常与 `/S` 搭配。

**语法：**

```powershell
treepp (--human-readable | -H | /HR) [<PATH>]
```

**示例（`/S /HR /F`）：**

```powershell
PS D:\Rust\tree++> treepp /S /HR /F
卷 存储 的文件夹 PATH 列表
卷序列号为 26E9-52C1
D:\Rust\tree++
│  Cargo.toml        982 B
│  LICENSE           1.0 KB
│  OPTIONS-zh.md     7.9 KB
│  OPTIONS.md        7.5 KB
│  README-zh.md      10.2 KB
│  README.md         9.1 KB
│
└─src
        cli.rs         6.0 KB
        config.rs      2.8 KB
        main.rs
        error.rs        1.9 KB
        output.rs      7.3 KB
        render.rs      5.2 KB
        scan.rs        8.8 KB
```

### `/S`: 显示文件大小（字节）

**功能：** 显示文件字节数，可与 `/HR` 联用。

**语法：**

```powershell
treepp (--size | -s | /S) [<PATH>]
```

**示例：**

```powershell
PS D:\Rust\tree++> treepp /S /F
卷 存储 的文件夹 PATH 列表
卷序列号为 26E9-52C1
D:\Rust\tree++
│  Cargo.toml        982
│  LICENSE           1067
│  OPTIONS-zh.md     8120
│  OPTIONS.md        7644
│  README-zh.md     10420
│  README.md         9288
│
└─src
        cli.rs         6120
        config.rs      2840
        main.rs
        error.rs        1980
        output.rs      7440
        render.rs      5360
        scan.rs        9020
```

### `/NI`: 不显示树形连接线

**功能：** 用缩进取代树形符号。

**语法：**

```powershell
treepp (--no-indent | -i | /NI) [<PATH>]
```

**示例：**

```powershell
PS D:\Rust\tree++> treepp /F /NI
卷 存储 的文件夹 PATH 列表
卷序列号为 26E9-52C1
D:\Rust\tree++
  Cargo.toml
  LICENSE
  OPTIONS-zh.md
  OPTIONS.md
  README-zh.md
  README.md

  src
    cli.rs
    config.rs
    main.rs
    output.rs
    render.rs
    scan.rs
```

### `/R`: 逆序排序

**功能：** 将当前排序结果倒序输出，可与 `/SO` 组合。

**语法：**

```powershell
treepp (--reverse | -r | /R) [<PATH>]
```

**示例：**

```powershell
PS D:\Rust\tree++> treepp /F /R
卷 存储 的文件夹 PATH 列表
卷序列号为 26E9-52C1
D:\Rust\tree++
│  README.md
│  README-zh.md
│  OPTIONS.md
│  OPTIONS-zh.md
│  LICENSE
│  Cargo.toml
│
└─src
        scan.rs
        render.rs
        output.rs
        main.rs
        error.rs
        config.rs
        cli.rs
```

### `/DT`: 显示最后修改日期

**功能：** 在条目后追加文件/目录的最后修改时间。

**语法：**

```powershell
treepp (--date | -d | /DT) [<PATH>]
```

**示例：**

```powershell
PS D:\Rust\tree++> treepp /F /DT
卷 存储 的文件夹 PATH 列表
卷序列号为 26E9-52C1
D:\Rust\tree++
│  Cargo.toml        2025-12-16 10:02:11
│  LICENSE           2024-11-03 09:00:29
│  OPTIONS-zh.md     2025-12-17 14:20:16
│  OPTIONS.md        2025-12-17 14:18:05
│  README-zh.md      2025-12-18 09:12:40
│  README.md         2025-12-18 09:10:03
│
└─src
        cli.rs         2025-12-17 22:41:12
        config.rs      2025-12-17 22:35:09
        main.rs
        error.rs        2025-12-17 22:12:47
        output.rs      2025-12-17 23:01:58
        render.rs      2025-12-17 22:58:47
        scan.rs        2025-12-17 23:05:58
```

### `/X`: 排除匹配项

**功能：** 忽略与模式匹配的文件或目录。

**语法：**

```powershell
treepp (--exclude | -I | /X) <PATTERN> [<PATH>]
```

**示例（排除 `*.md`）：**

```powershell
PS D:\Rust\tree++> treepp /F /X *.md
卷 存储 的文件夹 PATH 列表
卷序列号为 26E9-52C1
D:\Rust\tree++
│  Cargo.toml
│  LICENSE
│
└─src
        cli.rs
        config.rs
        main.rs
        error.rs
        output.rs
        render.rs
        scan.rs
```

### `/L`: 限制递归深度

**功能：** 指定最大递归层级。

**语法：**

```powershell
treepp (--level | -L | /L) <LEVEL> [<PATH>]
```

**示例（仅展示 1 层）：**

```powershell
PS D:\Rust\tree++> treepp /F /L 1
卷 存储 的文件夹 PATH 列表
卷序列号为 26E9-52C1
D:\Rust\tree++
│  Cargo.toml
│  LICENSE
│  OPTIONS-zh.md
│  OPTIONS.md
│  README-zh.md
│  README.md
│
└─src
```

### `/M`: 仅显示匹配项

**功能：** 只保留符合模式的条目。

**语法：**

```powershell
treepp (--include | -m | /M) <PATTERN> [<PATH>]
```

**示例（仅显示 `*.rs`）：**

```powershell
PS D:\Rust\tree++> treepp /F /M *.rs
卷 存储 的文件夹 PATH 列表
卷序列号为 26E9-52C1
D:\Rust\tree++
│
└─src
        cli.rs
        config.rs
        main.rs
        error.rs
        output.rs
        render.rs
        scan.rs
```

### `/DU`: 显示目录累计大小

**功能：** 统计每个目录的累计磁盘用量，与 `/HR` 配合。

**语法：**

```powershell
treepp (--disk-usage | -u | /DU) [<PATH>]
```

**示例：**

```powershell
PS D:\Rust\tree++> treepp /DU /HR
卷 存储 的文件夹 PATH 列表
卷序列号为 26E9-52C1
D:\Rust\tree++
src             31.5 KB
```

### `/IC`: 匹配时忽略大小写

**功能：** 使 `/M`、`/X` 等匹配指令忽略大小写。

**语法：**

```powershell
treepp (--ignore-case | -c | /IC) [<PATH>]
```

**示例（`/F /M *.MD /IC`）：**

```powershell
PS D:\Rust\tree++> treepp /F /M *.MD /IC
卷 存储 的文件夹 PATH 列表
卷序列号为 26E9-52C1
D:\Rust\tree++
│  OPTIONS-zh.md
│  OPTIONS.md
│  README-zh.md
│  README.md
```

### `/RP`: 显示末尾统计信息

**功能：** 在输出末尾统计信息汇总。

**语法：**

```powershell
treepp (--report | -e | /RP) [<PATH>]
```

**示例：**

```powershell
PS D:\Rust\tree++> treepp /F /RP
卷 存储 的文件夹 PATH 列表
卷序列号为 26E9-52C1
D:\Rust\tree++
│  Cargo.toml
│  LICENSE
│  OPTIONS-zh.md
│  OPTIONS.md
│  README-zh.md
│  README.md
│
└─src
        cli.rs
        config.rs
        main.rs
        error.rs
        output.rs
        render.rs
        scan.rs

1 directory, 12 files in 0.123s
```

### `/P`: 修剪空目录

**功能：** 隐藏不包含内容的目录节点。

**语法：**

```powershell
treepp (--prune | -P | /P) [<PATH>]
```

**示例：**

```powershell
PS D:\Rust\tree++> treepp /P /F
卷 存储 的文件夹 PATH 列表
卷序列号为 26E9-52C1
D:\Rust\tree++
│  Cargo.toml
│  LICENSE
│  OPTIONS-zh.md
│  OPTIONS.md
│  README-zh.md
│  README.md
│
└─src
        cli.rs
        config.rs
        main.rs
        error.rs
        output.rs
        render.rs
        scan.rs
```

### `/SO`: 指定排序方式

**功能：** 依据 `name`、`size`、`mtime` 等字段进行排序，可与 `/R` 组合。

**语法：**

```powershell
treepp (--sort | -S | /SO) <KEY> [<PATH>]
```

**示例（`/F /SO name`）：**

```powershell
PS D:\Rust\tree++> treepp /F /SO name
卷 存储 的文件夹 PATH 列表
卷序列号为 26E9-52C1
D:\Rust\tree++
│  Cargo.toml
│  LICENSE
│  OPTIONS-zh.md
│  OPTIONS.md
│  README-zh.md
│  README.md
│
└─src
        cli.rs
        config.rs
        main.rs
        error.rs
        output.rs
        render.rs
        scan.rs
```

*可选的排序字段及说明:*

| 字段      | 说明        |  
|---------|-----------|  
| `name`  | 按文件名字母表升序 |
| `size`  | 按文件大小升序   |
| `mtime` | 按修改时间升序   |
| `ctime` | 按创建时间升序   |

### `/NB`: 不显示 Windows 原生样板信息

**功能：**
省略 Windows 原生 `tree` 的样板输出。

**语法：**

```powershell
treepp (--no-win-banner | -N | /NB) [<PATH>]
```

**示例：**

```powershell
PS D:\Rust\tree++> treepp /F /NB
D:\Rust\tree++
│  Cargo.toml
│  LICENSE
│  OPTIONS-zh.md
│  OPTIONS.md
│  README-zh.md
│  README.md
│
└─src
        cli.rs
        config.rs
        main.rs
        error.rs
        output.rs
        render.rs
        scan.rs
```

> 建议在性能敏感时开启: `tree++`的对应样板输出是调用原生`tree`对指定的`C:\__treepp__`执行获取的

### `/SI`: 终端静默

**功能：** 禁止向标准输出写入结果，一般与 `/O` 搭配，静默写入文件。

**语法：**

```powershell
treepp (--silent | -l | /SI) [<PATH>]
```

**示例（`/F /O tree.json /SI`）：**

```powershell
PS D:\Rust\tree++> treepp /F /O tree.json /SI
PS D:\Rust\tree++>
```

### `/O`: 输出到文件

**功能：** 将结果持久化到 `.txt` / `.json` / `.yml` / `.toml` 文件。默认仍在控制台输出，可配合 `/SI` 静默。

**语法：**

```powershell
treepp (--output | -o | /O) <FILE.{txt|json|yml|toml}> [<PATH>]
```

**示例：**

```powershell
PS D:\Rust\tree++> treepp /F /O tree.json
卷 存储 的文件夹 PATH 列表
卷序列号为 26E9-52C1
D:\Rust\tree++
│  Cargo.toml
│  LICENSE
│  OPTIONS-zh.md
│  OPTIONS.md
│  README-zh.md
│  README.md
│
└─src
        cli.rs
        config.rs
        main.rs
        error.rs
        output.rs
        render.rs
        scan.rs

output: D:\Rust\tree++\tree.json
```

### `/T`: 扫描线程数

**功能：** 指定扫描线程数量，默认为 8。

**语法：**

```powershell
treepp (--thread | -t | /T) <N> [<PATH>]
```

**示例：**

```powershell
PS D:\Rust\tree++> treepp /F /T 32
卷 存储 的文件夹 PATH 列表
卷序列号为 26E9-52C1
D:\Rust\tree++
│  Cargo.toml
│  LICENSE
│  OPTIONS-zh.md
│  OPTIONS.md
│  README-zh.md
│  README.md
│
└─src
        cli.rs
        config.rs
        main.rs
        error.rs
        output.rs
        render.rs
        scan.rs
```

### `/G`: 遵循 `.gitignore`

**功能：** 解析每级目录中的 `.gitignore` 文件，自动忽略匹配条目。

**语法：**

```powershell
treepp (--gitignore | -g | /G) [<PATH>]
```

**示例：**

```powershell
PS D:\Rust\tree++> treepp /F /G
卷 存储 的文件夹 PATH 列表
卷序列号为 26E9-52C1
D:\Rust\tree++
│  Cargo.toml
│  LICENSE
│  OPTIONS-zh.md
│  OPTIONS.md
│  README-zh.md
│  README.md
│
└─src
        cli.rs
        config.rs
        main.rs
        error.rs
        output.rs
        render.rs
        scan.rs

.gitignore rules applied
```

对应源码:  

Cargo.toml:  

```toml
[package]
name = "treepp"
version = "0.1.0"
edition = "2024"
authors = ["WaterRun"]
description = "A better tree command for Windows"
repository = "https://github.com/Water-Run/treepp"
license = "MIT"
readme = "README.md"
keywords = ["tree", "directory", "cli", "windows"]
categories = ["command-line-utilities", "filesystem"]

[dependencies]

# 并行遍历
rayon = "1.11.0"

# 目录遍历
walkdir = "2.5.0"

# gitignore 规则解析
ignore = "0.4.25"

# 通配符匹配
glob = "0.3.3"

# 序列化支持 (json/yaml/toml 输出)
serde = { version = "1.0.228", features = ["derive"] }
serde_json = "1.0.148"
serde_yaml = "0.9.34"
toml = "0.9.10"

# 错误处理
thiserror = "2.0.17"

# Windows 编码转换
encoding_rs = "0.8"

# 路径检查
dunce = "1.0"

# 时间处理（本地时区支持）
chrono = "0.4"

[dev-dependencies]
tempfile = "3.24.0"

[profile.release]
opt-level = 3
lto = true
codegen-units = 1
strip = true

[[bin]]
name = "treepp"
path = "src/main.rs"
```

main.rs:  

```rust
//! tree++ 主程序入口
//!
//! 本模块实现 `tree++` 命令行工具的主入口，串联以下流程：
//!
//! 1. **CLI 解析**：解析命令行参数，产出 `ParseResult`
//! 2. **配置验证**：验证配置有效性，补齐派生字段
//! 3. **目录扫描**：执行单线程或多线程扫描，产出 `ScanStats`
//! 4. **树形渲染**：将扫描结果渲染为文本，产出 `RenderResult`
//! 5. **结果输出**：输出到 stdout 和/或文件
//!
//! # 退出码
//!
//! - `0`：成功
//! - `1`：参数错误
//! - `2`：扫描错误
//! - `3`：输出错误
//!
//! 作者: WaterRun
//! 更新于: 2025-01-06

#![forbid(unsafe_code)]
#![deny(warnings)]
#![deny(missing_docs)]
#![allow(dead_code)]

mod cli;
mod config;
mod error;
mod output;
mod render;
mod scan;

use std::process::ExitCode;

use cli::{CliError, CliParser, ParseResult};
use error::TreeppError;

/// 退出码：成功
const EXIT_SUCCESS: u8 = 0;

/// 退出码：参数错误
const EXIT_CLI_ERROR: u8 = 1;

/// 退出码：扫描错误
const EXIT_SCAN_ERROR: u8 = 2;

/// 退出码：输出错误
const EXIT_OUTPUT_ERROR: u8 = 3;

/// 程序主入口
///
/// 解析命令行参数并执行相应操作。
fn main() -> ExitCode {
    match run() {
        Ok(()) => ExitCode::from(EXIT_SUCCESS),
        Err(e) => {
            let code = error_to_exit_code(&e);
            print_error(&e);
            ExitCode::from(code)
        }
    }
}

/// 执行主流程
///
/// 串联 CLI 解析 -> 配置验证 -> 扫描 -> 渲染 -> 输出的完整流程。
fn run() -> Result<(), TreeppError> {
    // 1. CLI 解析
    let parser = CliParser::from_env();
    let parse_result = parser.parse()?;

    // 2. 根据解析结果执行相应操作
    match parse_result {
        ParseResult::Help => {
            cli::print_help();
            Ok(())
        }
        ParseResult::Version => {
            cli::print_version();
            Ok(())
        }
        ParseResult::Config(config) => {
            // 配置已在 parse() 中调用 validate()，此处直接使用

            // 3. 目录扫描
            let stats = scan::scan(&config)?;

            // 4. 树形渲染
            let render_result = render::render(&stats, &config);

            // 5. 结果输出
            output::execute_output(&render_result, &stats.tree, &config)?;

            Ok(())
        }
    }
}

/// 将错误映射为退出码
fn error_to_exit_code(err: &TreeppError) -> u8 {
    match err {
        TreeppError::Cli(_) | TreeppError::Config(_) => EXIT_CLI_ERROR,
        TreeppError::Scan(_) | TreeppError::Match(_) => EXIT_SCAN_ERROR,
        TreeppError::Render(_) | TreeppError::Output(_) => EXIT_OUTPUT_ERROR,
    }
}

/// 打印错误信息到 stderr
///
/// 根据错误类型格式化输出，提供用户友好的错误提示。
fn print_error(err: &TreeppError) {
    let prefix = match err {
        TreeppError::Cli(_) => "参数错误",
        TreeppError::Config(_) => "配置错误",
        TreeppError::Scan(_) => "扫描错误",
        TreeppError::Match(_) => "匹配错误",
        TreeppError::Render(_) => "渲染错误",
        TreeppError::Output(_) => "输出错误",
    };

    eprintln!("tree++: {}: {}", prefix, err);

    // 对于特定错误类型，提供额外提示
    match err {
        TreeppError::Cli(CliError::UnknownOption { .. }) => {
            eprintln!("提示: 使用 treepp --help 查看可用选项");
        }
        TreeppError::Cli(CliError::PathAfterOptions { .. }) => {
            eprintln!("提示: 路径参数必须在所有选项之前，例如: treepp C:\\dir /F");
        }
        TreeppError::Cli(CliError::MultiplePaths { .. }) => {
            eprintln!("提示: 只能指定一个目标路径");
        }
        _ => {}
    }
}
```

cli.rs:  

```rust
//! 命令行参数解析模块
//!
//! 本模块实现 `tree++` 命令行工具的参数解析功能，支持三种参数风格混用：
//!
//! - Windows CMD 风格 (`/F`)，大小写不敏感
//! - Unix 短参数风格 (`-f`)，大小写敏感
//! - GNU 长参数风格 (`--files`)，大小写敏感
//!
//! 解析完成后产出 [`Config`] 结构体，供后续扫描、匹配、渲染、输出模块使用。
//!
//! # 示例
//!
//! ```no_run
//! use treepp::cli::{CliParser, ParseResult};
//!
//! let args = vec!["D:\\project".to_string(), "/F".to_string(), "--ascii".to_string()];
//! let parser = CliParser::new(args);
//! match parser.parse() {
//!     Ok(ParseResult::Config(config)) => println!("{:?}", config),
//!     Ok(ParseResult::Help) => println!("显示帮助"),
//!     Ok(ParseResult::Version) => println!("显示版本"),
//!     Err(e) => eprintln!("错误: {}", e),
//! }
//! ```
//!
//! 作者: WaterRun
//! 更新于: 2025-01-06

#![forbid(unsafe_code)]

use std::collections::HashSet;
use std::env;
use std::num::NonZeroUsize;
use std::path::PathBuf;

use crate::config::{CharsetMode, Config, PathMode, SortKey};
pub(crate) use crate::error::CliError;

// ============================================================================
// 解析结果枚举
// ============================================================================

/// 解析结果
///
/// 表示命令行解析后的三种可能结果。
///
/// # Examples
///
/// ```no_run
/// use treepp::cli::{CliParser, ParseResult};
///
/// let parser = CliParser::new(vec!["--help".to_string()]);
/// match parser.parse() {
///     Ok(ParseResult::Help) => println!("显示帮助"),
///     Ok(ParseResult::Version) => println!("显示版本"),
///     Ok(ParseResult::Config(c)) => println!("配置: {:?}", c),
///     Err(e) => eprintln!("错误: {}", e),
/// }
/// ```
#[derive(Debug)]
pub enum ParseResult {
    /// 正常配置，需要执行扫描
    Config(Config),
    /// 用户请求显示帮助信息
    Help,
    /// 用户请求显示版本信息
    Version,
}

// ============================================================================
// 参数定义
// ============================================================================

/// 参数类型
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum ArgKind {
    /// 标志型参数（无需值）
    Flag,
    /// 带值型参数（需要后跟一个值）
    Value,
}

/// 参数定义结构体
struct ArgDef {
    /// 规范名称（用于重复检测和错误消息）
    canonical: &'static str,
    /// 参数类型
    kind: ArgKind,
    /// Windows CMD 风格 (`/X`)，大小写不敏感
    cmd_patterns: &'static [&'static str],
    /// Unix 短参数 (`-x`)，大小写敏感
    short_patterns: &'static [&'static str],
    /// GNU 长参数 (`--xxx`)，大小写敏感
    long_patterns: &'static [&'static str],
}

/// 所有支持的参数定义
///
/// 参数定义顺序与文档保持一致，便于维护。
const ARG_DEFINITIONS: &[ArgDef] = &[
    // 信息显示类
    ArgDef {
        canonical: "help",
        kind: ArgKind::Flag,
        cmd_patterns: &["/?"],
        short_patterns: &["-h"],
        long_patterns: &["--help"],
    },
    ArgDef {
        canonical: "version",
        kind: ArgKind::Flag,
        cmd_patterns: &["/V"],
        short_patterns: &["-v"],
        long_patterns: &["--version"],
    },
    // 显示内容类
    ArgDef {
        canonical: "files",
        kind: ArgKind::Flag,
        cmd_patterns: &["/F"],
        short_patterns: &["-f"],
        long_patterns: &["--files"],
    },
    ArgDef {
        canonical: "full-path",
        kind: ArgKind::Flag,
        cmd_patterns: &["/FP"],
        short_patterns: &["-p"],
        long_patterns: &["--full-path"],
    },
    ArgDef {
        canonical: "size",
        kind: ArgKind::Flag,
        cmd_patterns: &["/S"],
        short_patterns: &["-s"],
        long_patterns: &["--size"],
    },
    ArgDef {
        canonical: "human-readable",
        kind: ArgKind::Flag,
        cmd_patterns: &["/HR"],
        short_patterns: &["-H"],
        long_patterns: &["--human-readable"],
    },
    ArgDef {
        canonical: "date",
        kind: ArgKind::Flag,
        cmd_patterns: &["/DT"],
        short_patterns: &["-d"],
        long_patterns: &["--date"],
    },
    ArgDef {
        canonical: "disk-usage",
        kind: ArgKind::Flag,
        cmd_patterns: &["/DU"],
        short_patterns: &["-u"],
        long_patterns: &["--disk-usage"],
    },
    // 渲染样式类
    ArgDef {
        canonical: "ascii",
        kind: ArgKind::Flag,
        cmd_patterns: &["/A"],
        short_patterns: &["-a"],
        long_patterns: &["--ascii"],
    },
    ArgDef {
        canonical: "no-indent",
        kind: ArgKind::Flag,
        cmd_patterns: &["/NI"],
        short_patterns: &["-i"],
        long_patterns: &["--no-indent"],
    },
    ArgDef {
        canonical: "quote",
        kind: ArgKind::Flag,
        cmd_patterns: &["/Q"],
        short_patterns: &["-q"],
        long_patterns: &["--quote"],
    },
    // 排序类
    ArgDef {
        canonical: "sort",
        kind: ArgKind::Value,
        cmd_patterns: &["/SO"],
        short_patterns: &["-S"],
        long_patterns: &["--sort"],
    },
    ArgDef {
        canonical: "reverse",
        kind: ArgKind::Flag,
        cmd_patterns: &["/R"],
        short_patterns: &["-r"],
        long_patterns: &["--reverse"],
    },
    ArgDef {
        canonical: "dirs-first",
        kind: ArgKind::Flag,
        cmd_patterns: &["/DF"],
        short_patterns: &["-D"],
        long_patterns: &["--dirs-first"],
    },
    // 过滤类
    ArgDef {
        canonical: "level",
        kind: ArgKind::Value,
        cmd_patterns: &["/L"],
        short_patterns: &["-L"],
        long_patterns: &["--level"],
    },
    ArgDef {
        canonical: "include",
        kind: ArgKind::Value,
        cmd_patterns: &["/M"],
        short_patterns: &["-m"],
        long_patterns: &["--include"],
    },
    ArgDef {
        canonical: "exclude",
        kind: ArgKind::Value,
        cmd_patterns: &["/X"],
        short_patterns: &["-I"],
        long_patterns: &["--exclude"],
    },
    ArgDef {
        canonical: "ignore-case",
        kind: ArgKind::Flag,
        cmd_patterns: &["/IC"],
        short_patterns: &["-c"],
        long_patterns: &["--ignore-case"],
    },
    ArgDef {
        canonical: "prune",
        kind: ArgKind::Flag,
        cmd_patterns: &["/P"],
        short_patterns: &["-P"],
        long_patterns: &["--prune"],
    },
    ArgDef {
        canonical: "gitignore",
        kind: ArgKind::Flag,
        cmd_patterns: &["/G"],
        short_patterns: &["-g"],
        long_patterns: &["--gitignore"],
    },
    // 输出控制类
    ArgDef {
        canonical: "report",
        kind: ArgKind::Flag,
        cmd_patterns: &["/RP"],
        short_patterns: &["-e"],
        long_patterns: &["--report"],
    },
    ArgDef {
        canonical: "no-win-banner",
        kind: ArgKind::Flag,
        cmd_patterns: &["/NB"],
        short_patterns: &["-N"],
        long_patterns: &["--no-win-banner"],
    },
    ArgDef {
        canonical: "silent",
        kind: ArgKind::Flag,
        cmd_patterns: &["/SI"],
        short_patterns: &["-l"],
        long_patterns: &["--silent"],
    },
    ArgDef {
        canonical: "output",
        kind: ArgKind::Value,
        cmd_patterns: &["/O"],
        short_patterns: &["-o"],
        long_patterns: &["--output"],
    },
    // 性能类
    ArgDef {
        canonical: "thread",
        kind: ArgKind::Value,
        cmd_patterns: &["/T"],
        short_patterns: &["-t"],
        long_patterns: &["--thread"],
    },
];

// ============================================================================
// 参数匹配结果
// ============================================================================

/// 参数匹配结果
struct MatchedArg {
    /// 匹配到的参数定义
    definition: &'static ArgDef,
    /// 参数值（如果是带值参数）
    value: Option<String>,
}

// ============================================================================
// 命令行解析器
// ============================================================================

/// 命令行参数解析器
///
/// 支持三种参数风格混用：
/// - Windows CMD 风格 (`/F`)，大小写不敏感
/// - Unix 短参数风格 (`-f`)，大小写敏感
/// - GNU 长参数风格 (`--files`)，大小写敏感
///
/// # 路径位置规则
///
/// 路径参数必须出现在所有选项之前，这与 Windows 原生 `tree` 命令行为一致。
///
/// # Examples
///
/// ```no_run
/// use treepp::cli::CliParser;
///
/// // 从命令行参数创建
/// let parser = CliParser::from_env();
///
/// // 或手动指定参数
/// let parser = CliParser::new(vec!["/F".to_string(), "--ascii".to_string()]);
/// ```
pub struct CliParser {
    /// 待解析的参数列表
    args: Vec<String>,
    /// 当前解析位置
    position: usize,
    /// 已使用的规范名称集合（用于重复检测）
    seen_canonical_names: HashSet<String>,
    /// 是否已遇到选项（用于检测路径位置）
    has_seen_option: bool,
    /// 第一个遇到的选项（用于错误消息）
    first_option: Option<String>,
}

impl CliParser {
    /// 从参数列表创建解析器
    ///
    /// # 参数
    ///
    /// * `args` - 命令行参数列表（不包含程序名）
    ///
    /// # Examples
    ///
    /// ```
    /// use treepp::cli::CliParser;
    ///
    /// let parser = CliParser::new(vec!["/F".to_string(), "--level".to_string(), "3".to_string()]);
    /// ```
    #[must_use]
    pub fn new(args: Vec<String>) -> Self {
        Self {
            args,
            position: 0,
            seen_canonical_names: HashSet::new(),
            has_seen_option: false,
            first_option: None,
        }
    }

    /// 从环境参数创建解析器
    ///
    /// 自动跳过程序名（第一个参数）。
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use treepp::cli::CliParser;
    ///
    /// let parser = CliParser::from_env();
    /// let result = parser.parse();
    /// ```
    #[must_use]
    pub fn from_env() -> Self {
        let args: Vec<String> = env::args().skip(1).collect();
        Self::new(args)
    }

    /// 解析命令行参数
    ///
    /// 解析完成后调用 `Config::validate()` 验证配置有效性。
    ///
    /// # 路径位置规则
    ///
    /// 路径参数必须出现在所有选项之前。例如：
    /// - `treepp C:\dir /F` ✓ 正确
    /// - `treepp /F C:\dir` ✗ 错误
    ///
    /// # 返回值
    ///
    /// 成功返回 `ParseResult`，失败返回 `CliError`。
    ///
    /// # Errors
    ///
    /// - `CliError::UnknownOption` - 遇到未知参数
    /// - `CliError::MissingValue` - 需要值的参数缺少值
    /// - `CliError::InvalidValue` - 参数值无效
    /// - `CliError::DuplicateOption` - 参数重复
    /// - `CliError::PathAfterOptions` - 路径出现在选项之后
    /// - `CliError::MultiplePaths` - 指定了多个路径
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use treepp::cli::{CliParser, ParseResult};
    ///
    /// let parser = CliParser::new(vec!["/F".to_string()]);
    /// match parser.parse() {
    ///     Ok(ParseResult::Config(config)) => {
    ///         assert!(config.scan.show_files);
    ///     }
    ///     _ => panic!("解析失败"),
    /// }
    /// ```
    pub fn parse(mut self) -> Result<ParseResult, CliError> {
        let mut config = Config::default();
        let mut collected_paths: Vec<String> = Vec::new();

        // 可累积的参数（允许多次指定）
        const ACCUMULATIVE_OPTIONS: &[&str] = &["include", "exclude"];

        while self.position < self.args.len() {
            let current_arg = self.args[self.position].clone();

            if Self::is_option_like(&current_arg) {
                let matched = self.try_match_argument(&current_arg)?;

                // 记录第一个选项（用于错误消息）
                if !self.has_seen_option {
                    self.has_seen_option = true;
                    self.first_option = Some(current_arg.clone());
                }

                // 非累积参数才检查重复
                if !ACCUMULATIVE_OPTIONS.contains(&matched.definition.canonical) {
                    self.register_canonical_name(matched.definition.canonical)?;
                }

                self.apply_to_config(&mut config, &matched)?;

                // 帮助和版本信息立即返回
                if matched.definition.canonical == "help" {
                    return Ok(ParseResult::Help);
                }
                if matched.definition.canonical == "version" {
                    return Ok(ParseResult::Version);
                }
            } else {
                // 非选项参数视为路径
                // 检查路径是否出现在选项之后
                if self.has_seen_option {
                    return Err(CliError::PathAfterOptions {
                        path: current_arg,
                        after_option: self.first_option.clone().unwrap_or_default(),
                    });
                }
                collected_paths.push(current_arg);
            }

            self.position += 1;
        }

        // 验证并设置路径
        self.validate_paths(&collected_paths, &mut config)?;

        // 调用 Config::validate() 进行配置验证
        let validated_config = config.validate().map_err(|e| CliError::ParseError {
            message: e.to_string(),
        })?;

        Ok(ParseResult::Config(validated_config))
    }

    /// 判断字符串是否看起来像选项参数
    fn is_option_like(arg: &str) -> bool {
        arg.starts_with('-') || arg.starts_with('/')
    }

    /// 尝试匹配参数到已知定义
    fn try_match_argument(&mut self, arg: &str) -> Result<MatchedArg, CliError> {
        for def in ARG_DEFINITIONS {
            if let Some(matched) = self.try_match_definition(arg, def)? {
                return Ok(matched);
            }
        }
        Err(CliError::UnknownOption {
            option: arg.to_string(),
        })
    }

    /// 尝试将参数与特定定义匹配
    fn try_match_definition(
        &mut self,
        arg: &str,
        def: &'static ArgDef,
    ) -> Result<Option<MatchedArg>, CliError> {
        let arg_upper = arg.to_uppercase();

        // CMD 风格匹配（大小写不敏感）
        for pattern in def.cmd_patterns {
            if arg_upper == pattern.to_uppercase() {
                let value = self.consume_value_if_required(def, arg)?;
                return Ok(Some(MatchedArg {
                    definition: def,
                    value,
                }));
            }
        }

        // Unix 短参数匹配（大小写敏感）
        for pattern in def.short_patterns {
            if arg == *pattern {
                let value = self.consume_value_if_required(def, arg)?;
                return Ok(Some(MatchedArg {
                    definition: def,
                    value,
                }));
            }
        }

        // GNU 长参数匹配（大小写敏感）
        for pattern in def.long_patterns {
            if arg == *pattern {
                let value = self.consume_value_if_required(def, arg)?;
                return Ok(Some(MatchedArg {
                    definition: def,
                    value,
                }));
            }

            // 支持 --option=value 语法
            let equals_prefix = format!("{pattern}=");
            if arg.starts_with(&equals_prefix) && def.kind == ArgKind::Value {
                let value = arg[equals_prefix.len()..].to_string();
                return Ok(Some(MatchedArg {
                    definition: def,
                    value: Some(value),
                }));
            }
        }

        Ok(None)
    }

    /// 如果参数需要值，消费下一个参数作为值
    fn consume_value_if_required(
        &mut self,
        def: &ArgDef,
        arg: &str,
    ) -> Result<Option<String>, CliError> {
        if def.kind == ArgKind::Flag {
            return Ok(None);
        }

        let next_position = self.position + 1;
        if next_position >= self.args.len() {
            return Err(CliError::MissingValue {
                option: arg.to_string(),
            });
        }

        let next_arg = &self.args[next_position];
        if Self::is_option_like(next_arg) {
            return Err(CliError::MissingValue {
                option: arg.to_string(),
            });
        }

        self.position += 1;
        Ok(Some(next_arg.clone()))
    }

    /// 注册已使用的规范名称，检测重复
    fn register_canonical_name(&mut self, canonical: &str) -> Result<(), CliError> {
        if !self.seen_canonical_names.insert(canonical.to_string()) {
            return Err(CliError::DuplicateOption {
                option: canonical.to_string(),
            });
        }
        Ok(())
    }

    /// 将匹配的参数应用到配置
    fn apply_to_config(&self, config: &mut Config, matched: &MatchedArg) -> Result<(), CliError> {
        let canonical = matched.definition.canonical;

        match canonical {
            // 信息显示类
            "help" => config.show_help = true,
            "version" => config.show_version = true,

            // 扫描选项
            "files" => config.scan.show_files = true,
            "gitignore" => config.scan.respect_gitignore = true,
            "level" => {
                let value = matched.value.as_ref().expect("level 参数需要值");
                let depth: usize = value.parse().map_err(|_| CliError::InvalidValue {
                    option: canonical.to_string(),
                    value: value.clone(),
                    reason: "必须是正整数".to_string(),
                })?;
                config.scan.max_depth = Some(depth);
            }
            "thread" => {
                let value = matched.value.as_ref().expect("thread 参数需要值");
                let count: usize = value.parse().map_err(|_| CliError::InvalidValue {
                    option: canonical.to_string(),
                    value: value.clone(),
                    reason: "必须是正整数".to_string(),
                })?;
                config.scan.thread_count =
                    NonZeroUsize::new(count).ok_or_else(|| CliError::InvalidValue {
                        option: canonical.to_string(),
                        value: value.clone(),
                        reason: "线程数必须大于 0".to_string(),
                    })?;
            }

            // 匹配选项
            "include" => {
                if let Some(value) = matched.value.clone() {
                    config.matching.include_patterns.push(value);
                }
            }
            "exclude" => {
                if let Some(value) = matched.value.clone() {
                    config.matching.exclude_patterns.push(value);
                }
            }
            "ignore-case" => config.matching.ignore_case = true,
            "prune" => config.matching.prune_empty = true,

            // 渲染选项
            "ascii" => config.render.charset = CharsetMode::Ascii,
            "full-path" => config.render.path_mode = PathMode::Full,
            "size" => config.render.show_size = true,
            "human-readable" => config.render.human_readable = true,
            "date" => config.render.show_date = true,
            "disk-usage" => config.render.show_disk_usage = true,
            "no-indent" => config.render.no_indent = true,
            "reverse" => config.render.reverse_sort = true,
            "report" => config.render.show_report = true,
            "no-win-banner" => config.render.no_win_banner = true,
            "quote" => config.render.quote_names = true,
            "dirs-first" => config.render.dirs_first = true,
            "sort" => {
                let value = matched.value.as_ref().expect("sort 参数需要值");
                config.render.sort_key =
                    SortKey::from_str_loose(value).ok_or_else(|| CliError::InvalidValue {
                        option: canonical.to_string(),
                        value: value.clone(),
                        reason: format!("有效值: {}", SortKey::valid_keys().join(", ")),
                    })?;
            }

            // 输出选项
            "output" => {
                if let Some(value) = matched.value.as_ref() {
                    config.output.output_path = Some(PathBuf::from(value));
                }
            }
            "silent" => config.output.silent = true,

            _ => {}
        }

        Ok(())
    }

    /// 验证路径参数
    fn validate_paths(&self, paths: &[String], config: &mut Config) -> Result<(), CliError> {
        match paths.len() {
            0 => Ok(()),
            1 => {
                config.root_path = PathBuf::from(&paths[0]);
                Ok(())
            }
            _ => Err(CliError::MultiplePaths {
                paths: paths.to_vec(),
            }),
        }
    }
}

// ============================================================================
// 帮助与版本信息
// ============================================================================

/// 获取帮助信息字符串
///
/// # Examples
///
/// ```
/// use treepp::cli::help_text;
///
/// let help = help_text();
/// assert!(help.contains("tree++"));
/// assert!(help.contains("--help"));
/// ```
#[must_use]
pub fn help_text() -> &'static str {
    r#"tree++ - 更好的 Windows tree 命令

用法:
  treepp [<PATH>] [<OPTIONS>...]

选项:
  --help, -h, /?              显示帮助信息
  --version, -v, /V           显示版本信息
  --ascii, -a, /A             使用 ASCII 字符绘制树
  --files, -f, /F             显示文件
  --full-path, -p, /FP        显示完整路径
  --human-readable, -H, /HR   以人类可读方式显示文件大小
  --no-indent, -i, /NI        不显示树形连接线
  --reverse, -r, /R           逆序排序
  --size, -s, /S              显示文件大小（字节）
  --date, -d, /DT             显示最后修改日期
  --exclude, -I, /X <PATTERN> 排除匹配的文件
  --level, -L, /L <N>         限制递归深度
  --include, -m, /M <PATTERN> 仅显示匹配的文件
  --disk-usage, -u, /DU       显示目录累计大小
  --ignore-case, -c, /IC      匹配时忽略大小写
  --report, -e, /RP           显示末尾统计信息
  --prune, -P, /P             修剪空目录
  --sort, -S, /SO <KEY>       指定排序方式（name, size, mtime, ctime）
  --no-win-banner, -N, /NB    不显示 Windows 原生 tree 的样板信息
  --silent, -l, /SI           终端静默（结合 --output 使用）
  --output, -o, /O <FILE>     将结果输出至文件（.txt, .json, .yml, .toml）
  --thread, -t, /T <N>        扫描线程数（默认 8）
  --gitignore, -g, /G         遵循 .gitignore
  --quote, -q, /Q             用双引号包裹文件名
  --dirs-first, -D, /DF       目录优先显示

更多信息: https://github.com/Water-Run/treepp"#
}

/// 获取版本信息字符串
///
/// # Examples
///
/// ```
/// use treepp::cli::version_text;
///
/// let version = version_text();
/// assert!(version.contains("0.1.0"));
/// ```
#[must_use]
pub fn version_text() -> &'static str {
    r#"tree++ version 0.1.0

A Better tree command for Windows.

author: WaterRun
link: https://github.com/Water-Run/treepp"#
}

/// 打印帮助信息到标准输出
///
/// # Examples
///
/// ```no_run
/// use treepp::cli::print_help;
///
/// print_help();
/// ```
pub fn print_help() {
    println!("{}", help_text());
}

/// 打印版本信息到标准输出
///
/// # Examples
///
/// ```no_run
/// use treepp::cli::print_version;
///
/// print_version();
/// ```
pub fn print_version() {
    println!("{}", version_text());
}

// ============================================================================
// 单元测试
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;
    use crate::config::OutputFormat;
    use tempfile::TempDir;

    // ------------------------------------------------------------------------
    // 辅助函数
    // ------------------------------------------------------------------------

    /// 创建临时目录用于测试
    fn create_temp_dir() -> TempDir {
        TempDir::new().expect("创建临时目录失败")
    }

    /// 创建带有指定路径的解析器
    fn parser_with_temp_dir(temp_dir: &TempDir, extra_args: Vec<&str>) -> CliParser {
        let path_str = temp_dir.path().to_string_lossy().to_string();
        let mut args = vec![path_str];
        args.extend(extra_args.into_iter().map(String::from));
        CliParser::new(args)
    }

    // ------------------------------------------------------------------------
    // 基础解析测试
    // ------------------------------------------------------------------------

    #[test]
    fn should_parse_empty_args_with_defaults() {
        let parser = CliParser::new(vec![]);
        let result = parser.parse();

        assert!(result.is_ok(), "解析应成功: {:?}", result);
        if let Ok(ParseResult::Config(config)) = result {
            // 验证后的路径是规范化的绝对路径
            assert!(
                config.root_path.is_absolute(),
                "默认路径应被规范化为绝对路径"
            );
            // 验证其他默认值
            assert!(!config.scan.show_files);
            assert_eq!(config.scan.thread_count.get(), 8);
            assert_eq!(config.scan.max_depth, None);
            assert!(!config.scan.respect_gitignore);
            assert!(config.matching.include_patterns.is_empty());
            assert!(config.matching.exclude_patterns.is_empty());
            assert!(!config.matching.ignore_case);
            assert!(!config.matching.prune_empty);
            assert_eq!(config.render.charset, CharsetMode::Unicode);
            assert_eq!(config.render.path_mode, PathMode::Relative);
            assert!(!config.render.show_size);
            assert!(!config.render.human_readable);
            assert!(!config.render.show_date);
            assert!(!config.render.show_disk_usage);
            assert!(!config.render.no_indent);
            assert!(!config.render.reverse_sort);
            assert!(!config.render.show_report);
            assert!(!config.render.no_win_banner);
            assert!(!config.render.quote_names);
            assert!(!config.render.dirs_first);
            assert_eq!(config.render.sort_key, SortKey::Name);
            assert!(config.output.output_path.is_none());
            assert!(!config.output.silent);
        } else {
            panic!("期望 ParseResult::Config");
        }
    }

    #[test]
    fn should_parse_path_only() {
        let temp_dir = create_temp_dir();
        let path_str = temp_dir.path().to_string_lossy().to_string();

        let parser = CliParser::new(vec![path_str]);
        let result = parser.parse();

        assert!(result.is_ok(), "解析应成功: {:?}", result);
        if let Ok(ParseResult::Config(config)) = result {
            assert!(config.root_path.is_absolute());
            let expected = dunce::canonicalize(temp_dir.path()).expect("规范化失败");
            assert_eq!(config.root_path, expected);
        } else {
            panic!("期望 ParseResult::Config");
        }
    }

    #[test]
    fn should_parse_path_with_spaces() {
        let temp_dir = create_temp_dir();
        let sub_dir = temp_dir.path().join("path with spaces");
        std::fs::create_dir(&sub_dir).expect("创建子目录失败");

        let parser = CliParser::new(vec![sub_dir.to_string_lossy().to_string()]);
        let result = parser.parse();

        assert!(result.is_ok(), "带空格路径解析应成功: {:?}", result);
    }

    #[test]
    fn should_parse_relative_path() {
        // 使用当前目录的相对路径 "."
        let parser = CliParser::new(vec![".".to_string()]);
        let result = parser.parse();

        assert!(result.is_ok(), "相对路径解析应成功: {:?}", result);
        if let Ok(ParseResult::Config(config)) = result {
            assert!(config.root_path.is_absolute());
        }
    }

    // ------------------------------------------------------------------------
    // 帮助与版本测试
    // ------------------------------------------------------------------------

    #[test]
    fn should_return_help_for_help_flags() {
        for flag in &["--help", "-h", "/?"] {
            let parser = CliParser::new(vec![flag.to_string()]);
            let result = parser.parse();
            assert!(matches!(result, Ok(ParseResult::Help)), "测试 {flag}");
        }
    }

    #[test]
    fn should_return_version_for_version_flags() {
        for flag in &["--version", "-v", "/V", "/v"] {
            let parser = CliParser::new(vec![flag.to_string()]);
            let result = parser.parse();
            assert!(matches!(result, Ok(ParseResult::Version)), "测试 {flag}");
        }
    }

    #[test]
    fn should_return_help_even_with_other_options() {
        // 帮助选项应该优先返回
        let parser = CliParser::new(vec!["/F".to_string(), "--help".to_string()]);
        let result = parser.parse();
        // 注意：由于重复检测，这里会检测到 help，但 /F 在前面先处理
        // 实际上会解析 /F，然后解析 --help 并返回 Help
        assert!(matches!(result, Ok(ParseResult::Help)));
    }

    #[test]
    fn should_return_version_even_with_other_options() {
        let parser = CliParser::new(vec!["/F".to_string(), "--version".to_string()]);
        let result = parser.parse();
        assert!(matches!(result, Ok(ParseResult::Version)));
    }

    // ------------------------------------------------------------------------
    // 三风格混用测试
    // ------------------------------------------------------------------------

    #[test]
    fn should_parse_cmd_style_case_insensitive() {
        let parser1 = CliParser::new(vec!["/F".to_string()]);
        let parser2 = CliParser::new(vec!["/f".to_string()]);

        if let (Ok(ParseResult::Config(c1)), Ok(ParseResult::Config(c2))) =
            (parser1.parse(), parser2.parse())
        {
            assert!(c1.scan.show_files);
            assert!(c2.scan.show_files);
        } else {
            panic!("解析失败");
        }
    }

    #[test]
    fn should_parse_cmd_style_various_cases() {
        // 测试更多 CMD 风格的大小写变体
        for flag in &["/A", "/a", "/HR", "/hr", "/Hr", "/hR", "/NI", "/ni", "/Ni"] {
            let parser = CliParser::new(vec![flag.to_string()]);
            let result = parser.parse();
            assert!(
                matches!(result, Ok(ParseResult::Config(_))),
                "测试 {flag} 失败"
            );
        }
    }

    #[test]
    fn should_parse_unix_short_style_case_sensitive() {
        let parser1 = CliParser::new(vec!["-f".to_string()]);
        let result1 = parser1.parse();
        assert!(matches!(result1, Ok(ParseResult::Config(_))));

        let parser2 = CliParser::new(vec!["-F".to_string()]);
        let result2 = parser2.parse();
        assert!(matches!(result2, Err(CliError::UnknownOption { .. })));
    }

    #[test]
    fn should_parse_gnu_long_style() {
        let parser = CliParser::new(vec!["--files".to_string()]);
        if let Ok(ParseResult::Config(config)) = parser.parse() {
            assert!(config.scan.show_files);
        } else {
            panic!("解析失败");
        }
    }

    #[test]
    fn should_reject_gnu_long_style_wrong_case() {
        let parser = CliParser::new(vec!["--FILES".to_string()]);
        let result = parser.parse();
        assert!(matches!(result, Err(CliError::UnknownOption { .. })));
    }

    #[test]
    fn should_parse_mixed_styles() {
        let parser = CliParser::new(vec![
            "/F".to_string(),
            "-a".to_string(),
            "--level".to_string(),
            "3".to_string(),
        ]);

        if let Ok(ParseResult::Config(config)) = parser.parse() {
            assert!(config.scan.show_files);
            assert_eq!(config.render.charset, CharsetMode::Ascii);
            assert_eq!(config.scan.max_depth, Some(3));
        } else {
            panic!("解析失败");
        }
    }

    #[test]
    fn should_parse_all_three_styles_together() {
        let temp_dir = create_temp_dir();
        let parser = parser_with_temp_dir(
            &temp_dir,
            vec![
                "/F",
                "-a",
                "--size",
                "/HR",
                "-d",
                "--reverse",
                "/Q",
                "-D",
                "--prune",
            ],
        );

        if let Ok(ParseResult::Config(config)) = parser.parse() {
            assert!(config.scan.show_files);
            assert_eq!(config.render.charset, CharsetMode::Ascii);
            assert!(config.render.show_size);
            assert!(config.render.human_readable);
            assert!(config.render.show_date);
            assert!(config.render.reverse_sort);
            assert!(config.render.quote_names);
            assert!(config.render.dirs_first);
            assert!(config.matching.prune_empty);
        } else {
            panic!("解析失败");
        }
    }

    // ------------------------------------------------------------------------
    // 等价映射测试
    // ------------------------------------------------------------------------

    #[test]
    fn should_map_equivalent_options() {
        let cases = vec!["/F", "-f", "--files"];

        for flag in cases {
            let parser = CliParser::new(vec![flag.to_string()]);
            if let Ok(ParseResult::Config(config)) = parser.parse() {
                assert!(config.scan.show_files, "测试 {flag}");
            } else {
                panic!("解析 {flag} 失败");
            }
        }
    }

    #[test]
    fn should_map_all_equivalent_ascii_options() {
        for flag in &["/A", "/a", "-a", "--ascii"] {
            let parser = CliParser::new(vec![flag.to_string()]);
            if let Ok(ParseResult::Config(config)) = parser.parse() {
                assert_eq!(
                    config.render.charset,
                    CharsetMode::Ascii,
                    "测试 {flag} 失败"
                );
            } else {
                panic!("解析 {flag} 失败");
            }
        }
    }

    #[test]
    fn should_map_all_equivalent_level_options() {
        for (flag, value) in &[("/L", "5"), ("-L", "5"), ("--level", "5")] {
            let parser = CliParser::new(vec![flag.to_string(), value.to_string()]);
            if let Ok(ParseResult::Config(config)) = parser.parse() {
                assert_eq!(config.scan.max_depth, Some(5), "测试 {flag} 失败");
            } else {
                panic!("解析 {flag} {value} 失败");
            }
        }
    }

    // ------------------------------------------------------------------------
    // 带值参数测试
    // ------------------------------------------------------------------------

    #[test]
    fn should_parse_value_arguments() {
        let parser = CliParser::new(vec!["--level".to_string(), "5".to_string()]);

        if let Ok(ParseResult::Config(config)) = parser.parse() {
            assert_eq!(config.scan.max_depth, Some(5));
        } else {
            panic!("解析失败");
        }
    }

    #[test]
    fn should_parse_equals_syntax() {
        let parser = CliParser::new(vec!["--level=10".to_string()]);

        if let Ok(ParseResult::Config(config)) = parser.parse() {
            assert_eq!(config.scan.max_depth, Some(10));
        } else {
            panic!("解析失败");
        }
    }

    #[test]
    fn should_parse_equals_syntax_with_various_values() {
        let cases = vec![
            ("--level=1", 1usize),
            ("--level=100", 100),
            ("--level=999", 999),
        ];

        for (arg, expected) in cases {
            let parser = CliParser::new(vec![arg.to_string()]);
            if let Ok(ParseResult::Config(config)) = parser.parse() {
                assert_eq!(config.scan.max_depth, Some(expected), "测试 {arg}");
            } else {
                panic!("解析 {arg} 失败");
            }
        }
    }

    #[test]
    fn should_parse_equals_syntax_for_sort() {
        let parser = CliParser::new(vec!["--sort=size".to_string()]);

        if let Ok(ParseResult::Config(config)) = parser.parse() {
            assert_eq!(config.render.sort_key, SortKey::Size);
        } else {
            panic!("解析失败");
        }
    }

    #[test]
    fn should_parse_equals_syntax_for_output() {
        let parser = CliParser::new(vec!["--output=tree.json".to_string()]);

        if let Ok(ParseResult::Config(config)) = parser.parse() {
            assert_eq!(config.output.output_path, Some(PathBuf::from("tree.json")));
        } else {
            panic!("解析失败");
        }
    }

    #[test]
    fn should_fail_on_missing_value() {
        let parser = CliParser::new(vec!["--level".to_string()]);
        let result = parser.parse();
        assert!(matches!(result, Err(CliError::MissingValue { .. })));
    }

    #[test]
    fn should_fail_on_missing_value_when_followed_by_option() {
        let parser = CliParser::new(vec!["--level".to_string(), "--files".to_string()]);
        let result = parser.parse();
        assert!(matches!(result, Err(CliError::MissingValue { .. })));
    }

    #[test]
    fn should_fail_on_invalid_value() {
        let parser = CliParser::new(vec!["--level".to_string(), "abc".to_string()]);
        let result = parser.parse();
        assert!(matches!(result, Err(CliError::InvalidValue { .. })));
    }

    #[test]
    fn should_fail_on_negative_level() {
        let parser = CliParser::new(vec!["--level".to_string(), "-5".to_string()]);
        let result = parser.parse();
        // -5 看起来像选项，所以会报 MissingValue
        assert!(matches!(result, Err(CliError::MissingValue { .. })));
    }

    #[test]
    fn should_parse_level_zero() {
        let parser = CliParser::new(vec!["--level".to_string(), "0".to_string()]);

        if let Ok(ParseResult::Config(config)) = parser.parse() {
            assert_eq!(config.scan.max_depth, Some(0));
        } else {
            panic!("解析失败");
        }
    }

    #[test]
    fn should_parse_large_level() {
        let parser = CliParser::new(vec!["--level".to_string(), "1000000".to_string()]);

        if let Ok(ParseResult::Config(config)) = parser.parse() {
            assert_eq!(config.scan.max_depth, Some(1_000_000));
        } else {
            panic!("解析失败");
        }
    }

    // ------------------------------------------------------------------------
    // 排序键测试
    // ------------------------------------------------------------------------

    #[test]
    fn should_parse_sort_key() {
        for (input, expected) in [
            ("name", SortKey::Name),
            ("size", SortKey::Size),
            ("mtime", SortKey::Mtime),
            ("ctime", SortKey::Ctime),
            ("NAME", SortKey::Name),
            ("Size", SortKey::Size),
            ("MTIME", SortKey::Mtime),
            ("Ctime", SortKey::Ctime),
        ] {
            let parser = CliParser::new(vec!["--sort".to_string(), input.to_string()]);
            if let Ok(ParseResult::Config(config)) = parser.parse() {
                assert_eq!(config.render.sort_key, expected, "测试 {input}");
            } else {
                panic!("解析 sort={input} 失败");
            }
        }
    }

    #[test]
    fn should_fail_on_invalid_sort_key() {
        let parser = CliParser::new(vec!["--sort".to_string(), "invalid".to_string()]);
        let result = parser.parse();
        assert!(matches!(result, Err(CliError::InvalidValue { .. })));
    }

    #[test]
    fn should_fail_on_empty_sort_key() {
        let parser = CliParser::new(vec!["--sort=".to_string()]);
        let result = parser.parse();
        assert!(matches!(result, Err(CliError::InvalidValue { .. })));
    }

    // ------------------------------------------------------------------------
    // 重复参数测试
    // ------------------------------------------------------------------------

    #[test]
    fn should_fail_on_duplicate_option() {
        let parser = CliParser::new(vec!["/F".to_string(), "--files".to_string()]);
        let result = parser.parse();
        assert!(matches!(result, Err(CliError::DuplicateOption { .. })));
    }

    #[test]
    fn should_fail_on_duplicate_same_style() {
        let parser = CliParser::new(vec!["/F".to_string(), "/F".to_string()]);
        let result = parser.parse();
        assert!(matches!(result, Err(CliError::DuplicateOption { .. })));
    }

    #[test]
    fn should_fail_on_duplicate_different_case_cmd() {
        let parser = CliParser::new(vec!["/F".to_string(), "/f".to_string()]);
        let result = parser.parse();
        assert!(matches!(result, Err(CliError::DuplicateOption { .. })));
    }

    #[test]
    fn should_fail_on_duplicate_level() {
        let parser = CliParser::new(vec![
            "--level".to_string(),
            "3".to_string(),
            "-L".to_string(),
            "5".to_string(),
        ]);
        let result = parser.parse();
        assert!(matches!(result, Err(CliError::DuplicateOption { .. })));
    }

    // ------------------------------------------------------------------------
    // 未知参数测试
    // ------------------------------------------------------------------------

    #[test]
    fn should_fail_on_unknown_option() {
        let parser = CliParser::new(vec!["/UNKNOWN".to_string()]);
        let result = parser.parse();
        assert!(matches!(result, Err(CliError::UnknownOption { .. })));
    }

    #[test]
    fn should_fail_on_unknown_short_option() {
        let parser = CliParser::new(vec!["-z".to_string()]);
        let result = parser.parse();
        assert!(matches!(result, Err(CliError::UnknownOption { .. })));
    }

    #[test]
    fn should_fail_on_unknown_long_option() {
        let parser = CliParser::new(vec!["--unknown-option".to_string()]);
        let result = parser.parse();
        assert!(matches!(result, Err(CliError::UnknownOption { .. })));
    }

    #[test]
    fn should_fail_on_typo_option() {
        let parser = CliParser::new(vec!["--fies".to_string()]); // typo for --files
        let result = parser.parse();
        assert!(matches!(result, Err(CliError::UnknownOption { .. })));
    }

    // ------------------------------------------------------------------------
    // 线程数测试
    // ------------------------------------------------------------------------

    #[test]
    fn should_parse_thread_count() {
        let parser = CliParser::new(vec!["--thread".to_string(), "16".to_string()]);

        if let Ok(ParseResult::Config(config)) = parser.parse() {
            assert_eq!(config.scan.thread_count.get(), 16);
        } else {
            panic!("解析失败");
        }
    }

    #[test]
    fn should_parse_thread_count_one() {
        let parser = CliParser::new(vec!["--thread".to_string(), "1".to_string()]);

        if let Ok(ParseResult::Config(config)) = parser.parse() {
            assert_eq!(config.scan.thread_count.get(), 1);
        } else {
            panic!("解析失败");
        }
    }

    #[test]
    fn should_fail_on_zero_thread_count() {
        let parser = CliParser::new(vec!["--thread".to_string(), "0".to_string()]);
        let result = parser.parse();
        assert!(matches!(result, Err(CliError::InvalidValue { .. })));
    }

    #[test]
    fn should_fail_on_invalid_thread_count() {
        let parser = CliParser::new(vec!["--thread".to_string(), "abc".to_string()]);
        let result = parser.parse();
        assert!(matches!(result, Err(CliError::InvalidValue { .. })));
    }

    #[test]
    fn should_parse_thread_with_cmd_style() {
        let parser = CliParser::new(vec!["/T".to_string(), "4".to_string()]);

        if let Ok(ParseResult::Config(config)) = parser.parse() {
            assert_eq!(config.scan.thread_count.get(), 4);
        } else {
            panic!("解析失败");
        }
    }

    // ------------------------------------------------------------------------
    // 输出选项测试
    // ------------------------------------------------------------------------

    #[test]
    fn should_parse_output_path() {
        let parser = CliParser::new(vec!["--output".to_string(), "tree.json".to_string()]);

        if let Ok(ParseResult::Config(config)) = parser.parse() {
            assert_eq!(config.output.output_path, Some(PathBuf::from("tree.json")));
        } else {
            panic!("解析失败");
        }
    }

    #[test]
    fn should_parse_output_with_various_extensions() {
        let cases = vec![
            ("tree.txt", OutputFormat::Txt),
            ("tree.json", OutputFormat::Json),
            ("tree.yml", OutputFormat::Yaml),
            ("tree.yaml", OutputFormat::Yaml),
            ("tree.toml", OutputFormat::Toml),
        ];

        for (filename, expected_format) in cases {
            let parser = CliParser::new(vec!["--output".to_string(), filename.to_string()]);
            if let Ok(ParseResult::Config(config)) = parser.parse() {
                assert_eq!(
                    config.output.format, expected_format,
                    "测试 {filename} 格式推断"
                );
            } else {
                panic!("解析 --output {filename} 失败");
            }
        }
    }

    #[test]
    fn should_parse_output_with_path() {
        let parser = CliParser::new(vec![
            "--output".to_string(),
            "C:\\output\\tree.json".to_string(),
        ]);

        if let Ok(ParseResult::Config(config)) = parser.parse() {
            assert_eq!(
                config.output.output_path,
                Some(PathBuf::from("C:\\output\\tree.json"))
            );
        } else {
            panic!("解析失败");
        }
    }

    #[test]
    fn should_parse_silent_with_output() {
        let parser = CliParser::new(vec![
            "--silent".to_string(),
            "--output".to_string(),
            "tree.txt".to_string(),
        ]);

        if let Ok(ParseResult::Config(config)) = parser.parse() {
            assert!(config.output.silent);
            assert!(config.output.output_path.is_some());
        } else {
            panic!("解析失败");
        }
    }

    // ------------------------------------------------------------------------
    // 模式匹配测试
    // ------------------------------------------------------------------------

    #[test]
    fn should_parse_include_pattern() {
        let parser = CliParser::new(vec!["--include".to_string(), "*.rs".to_string()]);

        if let Ok(ParseResult::Config(config)) = parser.parse() {
            assert_eq!(config.matching.include_patterns, vec!["*.rs".to_string()]);
        } else {
            panic!("解析失败");
        }
    }

    #[test]
    fn should_parse_exclude_pattern() {
        let parser = CliParser::new(vec!["--exclude".to_string(), "node_modules".to_string()]);

        if let Ok(ParseResult::Config(config)) = parser.parse() {
            assert_eq!(
                config.matching.exclude_patterns,
                vec!["node_modules".to_string()]
            );
        } else {
            panic!("解析失败");
        }
    }

    #[test]
    fn should_parse_multiple_include_patterns() {
        let parser = CliParser::new(vec![
            "--include".to_string(),
            "*.rs".to_string(),
            "-m".to_string(),
            "*.toml".to_string(),
        ]);

        if let Ok(ParseResult::Config(config)) = parser.parse() {
            assert_eq!(
                config.matching.include_patterns,
                vec!["*.rs".to_string(), "*.toml".to_string()]
            );
        } else {
            panic!("解析失败");
        }
    }

    #[test]
    fn should_parse_multiple_exclude_patterns() {
        let parser = CliParser::new(vec![
            "--exclude".to_string(),
            "target".to_string(),
            "/X".to_string(),
            "node_modules".to_string(),
        ]);

        if let Ok(ParseResult::Config(config)) = parser.parse() {
            assert_eq!(
                config.matching.exclude_patterns,
                vec!["target".to_string(), "node_modules".to_string()]
            );
        } else {
            panic!("解析失败");
        }
    }

    #[test]
    fn should_parse_ignore_case() {
        for flag in &["--ignore-case", "-c", "/IC", "/ic"] {
            let parser = CliParser::new(vec![flag.to_string()]);
            if let Ok(ParseResult::Config(config)) = parser.parse() {
                assert!(config.matching.ignore_case, "测试 {flag}");
            } else {
                panic!("解析 {flag} 失败");
            }
        }
    }

    #[test]
    fn should_parse_prune() {
        for flag in &["--prune", "-P", "/P"] {
            let parser = CliParser::new(vec![flag.to_string()]);
            if let Ok(ParseResult::Config(config)) = parser.parse() {
                assert!(config.matching.prune_empty, "测试 {flag}");
            } else {
                panic!("解析 {flag} 失败");
            }
        }
    }

    #[test]
    fn should_parse_gitignore() {
        for flag in &["--gitignore", "-g", "/G", "/g"] {
            let parser = CliParser::new(vec![flag.to_string()]);
            if let Ok(ParseResult::Config(config)) = parser.parse() {
                assert!(config.scan.respect_gitignore, "测试 {flag}");
            } else {
                panic!("解析 {flag} 失败");
            }
        }
    }

    // ------------------------------------------------------------------------
    // 配置验证集成测试
    // ------------------------------------------------------------------------

    #[test]
    fn should_fail_silent_without_output() {
        let parser = CliParser::new(vec!["--silent".to_string()]);
        let result = parser.parse();
        assert!(result.is_err());
    }

    #[test]
    fn should_infer_output_format_from_extension() {
        let parser = CliParser::new(vec!["--output".to_string(), "tree.json".to_string()]);

        if let Ok(ParseResult::Config(config)) = parser.parse() {
            assert_eq!(config.output.format, OutputFormat::Json);
        } else {
            panic!("解析失败");
        }
    }

    #[test]
    fn should_fail_on_nonexistent_path() {
        let parser = CliParser::new(vec!["C:\\nonexistent\\path\\12345".to_string()]);
        let result = parser.parse();
        assert!(result.is_err(), "不存在的路径应该失败");
    }

    // ------------------------------------------------------------------------
    // 渲染选项测试
    // ------------------------------------------------------------------------

    #[test]
    fn should_parse_full_path() {
        for flag in &["--full-path", "-p", "/FP", "/fp"] {
            let parser = CliParser::new(vec![flag.to_string()]);
            if let Ok(ParseResult::Config(config)) = parser.parse() {
                assert_eq!(config.render.path_mode, PathMode::Full, "测试 {flag}");
            } else {
                panic!("解析 {flag} 失败");
            }
        }
    }

    #[test]
    fn should_parse_size() {
        for flag in &["--size", "-s", "/S"] {
            let parser = CliParser::new(vec![flag.to_string()]);
            if let Ok(ParseResult::Config(config)) = parser.parse() {
                assert!(config.render.show_size, "测试 {flag}");
            } else {
                panic!("解析 {flag} 失败");
            }
        }
    }

    #[test]
    fn should_parse_human_readable() {
        for flag in &["--human-readable", "-H", "/HR", "/hr"] {
            let parser = CliParser::new(vec![flag.to_string()]);
            if let Ok(ParseResult::Config(config)) = parser.parse() {
                assert!(config.render.human_readable, "测试 {flag}");
            } else {
                panic!("解析 {flag} 失败");
            }
        }
    }

    #[test]
    fn should_parse_date() {
        for flag in &["--date", "-d", "/DT", "/dt"] {
            let parser = CliParser::new(vec![flag.to_string()]);
            if let Ok(ParseResult::Config(config)) = parser.parse() {
                assert!(config.render.show_date, "测试 {flag}");
            } else {
                panic!("解析 {flag} 失败");
            }
        }
    }

    #[test]
    fn should_parse_disk_usage() {
        for flag in &["--disk-usage", "-u", "/DU", "/du"] {
            let parser = CliParser::new(vec![flag.to_string()]);
            if let Ok(ParseResult::Config(config)) = parser.parse() {
                assert!(config.render.show_disk_usage, "测试 {flag}");
            } else {
                panic!("解析 {flag} 失败");
            }
        }
    }

    #[test]
    fn should_parse_no_indent() {
        for flag in &["--no-indent", "-i", "/NI", "/ni"] {
            let parser = CliParser::new(vec![flag.to_string()]);
            if let Ok(ParseResult::Config(config)) = parser.parse() {
                assert!(config.render.no_indent, "测试 {flag}");
            } else {
                panic!("解析 {flag} 失败");
            }
        }
    }

    #[test]
    fn should_parse_reverse() {
        for flag in &["--reverse", "-r", "/R", "/r"] {
            let parser = CliParser::new(vec![flag.to_string()]);
            if let Ok(ParseResult::Config(config)) = parser.parse() {
                assert!(config.render.reverse_sort, "测试 {flag}");
            } else {
                panic!("解析 {flag} 失败");
            }
        }
    }

    #[test]
    fn should_parse_report() {
        for flag in &["--report", "-e", "/RP", "/rp"] {
            let parser = CliParser::new(vec![flag.to_string()]);
            if let Ok(ParseResult::Config(config)) = parser.parse() {
                assert!(config.render.show_report, "测试 {flag}");
            } else {
                panic!("解析 {flag} 失败");
            }
        }
    }

    #[test]
    fn should_parse_no_win_banner() {
        for flag in &["--no-win-banner", "-N", "/NB", "/nb"] {
            let parser = CliParser::new(vec![flag.to_string()]);
            if let Ok(ParseResult::Config(config)) = parser.parse() {
                assert!(config.render.no_win_banner, "测试 {flag}");
            } else {
                panic!("解析 {flag} 失败");
            }
        }
    }

    #[test]
    fn should_parse_quote_option() {
        for flag in &["--quote", "-q", "/Q", "/q"] {
            let parser = CliParser::new(vec![flag.to_string()]);
            if let Ok(ParseResult::Config(config)) = parser.parse() {
                assert!(config.render.quote_names, "测试 {flag}");
            } else {
                panic!("解析 {flag} 失败");
            }
        }
    }

    #[test]
    fn should_parse_dirs_first_option() {
        for flag in &["--dirs-first", "-D", "/DF", "/df"] {
            let parser = CliParser::new(vec![flag.to_string()]);
            if let Ok(ParseResult::Config(config)) = parser.parse() {
                assert!(config.render.dirs_first, "测试 {flag}");
            } else {
                panic!("解析 {flag} 失败");
            }
        }
    }

    // ------------------------------------------------------------------------
    // 帮助文本测试
    // ------------------------------------------------------------------------

    #[test]
    fn should_contain_all_options_in_help() {
        let help = help_text();
        assert!(help.contains("--help"));
        assert!(help.contains("--files"));
        assert!(help.contains("--ascii"));
        assert!(help.contains("--level"));
        assert!(help.contains("--output"));
        assert!(help.contains("--thread"));
        assert!(help.contains("--gitignore"));
        assert!(help.contains("--quote"));
        assert!(help.contains("--dirs-first"));
        assert!(help.contains("--include"));
        assert!(help.contains("--exclude"));
        assert!(help.contains("--sort"));
        assert!(help.contains("--silent"));
        assert!(help.contains("--prune"));
    }

    #[test]
    fn should_contain_version_in_version_text() {
        let version = version_text();
        assert!(version.contains("0.1.0"));
        assert!(version.contains("WaterRun"));
        assert!(version.contains("github.com"));
    }

    #[test]
    fn should_contain_usage_in_help() {
        let help = help_text();
        assert!(help.contains("用法"));
        assert!(help.contains("treepp"));
        assert!(help.contains("PATH"));
        assert!(help.contains("OPTIONS"));
    }

    // ------------------------------------------------------------------------
    // 路径位置测试
    // ------------------------------------------------------------------------

    #[test]
    fn should_accept_path_before_options() {
        let temp_dir = create_temp_dir();
        let path_str = temp_dir.path().to_string_lossy().to_string();

        let parser = CliParser::new(vec![path_str.clone(), "/F".to_string()]);
        let result = parser.parse();

        assert!(result.is_ok(), "路径在选项之前应该成功: {:?}", result);
    }

    #[test]
    fn should_fail_path_after_options() {
        let parser = CliParser::new(vec!["/F".to_string(), "C:\\some\\path".to_string()]);
        let result = parser.parse();

        assert!(matches!(result, Err(CliError::PathAfterOptions { .. })));

        if let Err(CliError::PathAfterOptions { path, after_option }) = result {
            assert_eq!(path, "C:\\some\\path");
            assert_eq!(after_option, "/F");
        }
    }

    #[test]
    fn should_fail_path_after_multiple_options() {
        let parser = CliParser::new(vec![
            "/F".to_string(),
            "-a".to_string(),
            "C:\\some\\path".to_string(),
        ]);
        let result = parser.parse();

        assert!(matches!(result, Err(CliError::PathAfterOptions { .. })));

        if let Err(CliError::PathAfterOptions { after_option, .. }) = result {
            // 第一个选项应该被记录
            assert_eq!(after_option, "/F");
        }
    }

    #[test]
    fn should_fail_multiple_paths() {
        let parser = CliParser::new(vec!["path1".to_string(), "path2".to_string()]);
        let result = parser.parse();

        assert!(matches!(result, Err(CliError::MultiplePaths { .. })));

        if let Err(CliError::MultiplePaths { paths }) = result {
            assert_eq!(paths.len(), 2);
            assert_eq!(paths[0], "path1");
            assert_eq!(paths[1], "path2");
        }
    }

    #[test]
    fn should_fail_three_paths() {
        let parser = CliParser::new(vec![
            "path1".to_string(),
            "path2".to_string(),
            "path3".to_string(),
        ]);
        let result = parser.parse();

        assert!(matches!(result, Err(CliError::MultiplePaths { .. })));

        if let Err(CliError::MultiplePaths { paths }) = result {
            assert_eq!(paths.len(), 3);
        }
    }

    #[test]
    fn should_accept_only_options_no_path() {
        let parser = CliParser::new(vec!["/F".to_string()]);
        let result = parser.parse();

        // 当前目录应该存在，所以解析应该成功
        assert!(
            result.is_ok(),
            "只有选项无路径应该成功（使用当前目录）"
        );
    }

    // ------------------------------------------------------------------------
    // 边缘情况测试
    // ------------------------------------------------------------------------

    #[test]
    fn should_handle_empty_string_arg() {
        // 空字符串被视为路径
        let parser = CliParser::new(vec!["".to_string()]);
        let result = parser.parse();
        // 空路径应该导致验证失败
        assert!(result.is_err());
    }

    #[test]
    fn should_handle_whitespace_only_arg() {
        let parser = CliParser::new(vec!["   ".to_string()]);
        let result = parser.parse();
        // 纯空白路径应该导致验证失败
        assert!(result.is_err());
    }

    #[test]
    fn should_handle_dash_only() {
        let parser = CliParser::new(vec!["-".to_string()]);
        let result = parser.parse();
        // 单独的 "-" 应该被视为未知选项
        assert!(matches!(result, Err(CliError::UnknownOption { .. })));
    }

    #[test]
    fn should_handle_double_dash_only() {
        let parser = CliParser::new(vec!["--".to_string()]);
        let result = parser.parse();
        // 单独的 "--" 应该被视为未知选项
        assert!(matches!(result, Err(CliError::UnknownOption { .. })));
    }

    #[test]
    fn should_handle_slash_only() {
        let parser = CliParser::new(vec!["/".to_string()]);
        let result = parser.parse();
        // 单独的 "/" 应该被视为未知选项
        assert!(matches!(result, Err(CliError::UnknownOption { .. })));
    }

    #[test]
    fn should_parse_option_with_unicode() {
        // 带有 Unicode 字符的路径
        let temp_dir = create_temp_dir();
        let unicode_dir = temp_dir.path().join("测试目录");
        std::fs::create_dir(&unicode_dir).expect("创建目录失败");

        let parser = CliParser::new(vec![
            unicode_dir.to_string_lossy().to_string(),
            "/F".to_string(),
        ]);
        let result = parser.parse();

        assert!(result.is_ok(), "Unicode 路径应该成功: {:?}", result);
    }

    // ------------------------------------------------------------------------
    // 复合场景测试
    // ------------------------------------------------------------------------

    #[test]
    fn should_parse_complex_command_line() {
        let temp_dir = create_temp_dir();
        let parser = parser_with_temp_dir(
            &temp_dir,
            vec![
                "/F",
                "-a",
                "--level",
                "5",
                "-s",
                "-H",
                "--sort",
                "size",
                "-r",
                "--include",
                "*.rs",
                "--exclude",
                "target",
                "-c",
                "--prune",
                "-g",
                "--quote",
                "-D",
                "--report",
                "-N",
                "--thread",
                "4",
            ],
        );

        if let Ok(ParseResult::Config(config)) = parser.parse() {
            assert!(config.scan.show_files);
            assert_eq!(config.render.charset, CharsetMode::Ascii);
            assert_eq!(config.scan.max_depth, Some(5));
            assert!(config.render.show_size);
            assert!(config.render.human_readable);
            assert_eq!(config.render.sort_key, SortKey::Size);
            assert!(config.render.reverse_sort);
            assert_eq!(config.matching.include_patterns, vec!["*.rs"]);
            assert_eq!(config.matching.exclude_patterns, vec!["target"]);
            assert!(config.matching.ignore_case);
            assert!(config.matching.prune_empty);
            assert!(config.scan.respect_gitignore);
            assert!(config.render.quote_names);
            assert!(config.render.dirs_first);
            assert!(config.render.show_report);
            assert!(config.render.no_win_banner);
            assert_eq!(config.scan.thread_count.get(), 4);
        } else {
            panic!("复杂命令行解析失败");
        }
    }

    #[test]
    fn should_parse_minimal_output_scenario() {
        let temp_dir = create_temp_dir();
        let output_file = temp_dir.path().join("output.json");

        let parser = parser_with_temp_dir(
            &temp_dir,
            vec![
                "--output",
                output_file.to_str().unwrap(),
                "--silent",
                "/F",
            ],
        );

        if let Ok(ParseResult::Config(config)) = parser.parse() {
            assert!(config.output.silent);
            assert!(config.output.output_path.is_some());
            assert_eq!(config.output.format, OutputFormat::Json);
        } else {
            panic!("解析失败");
        }
    }

    // ------------------------------------------------------------------------
    // is_option_like 测试
    // ------------------------------------------------------------------------

    #[test]
    fn should_identify_option_like_strings() {
        assert!(CliParser::is_option_like("-f"));
        assert!(CliParser::is_option_like("--files"));
        assert!(CliParser::is_option_like("/F"));
        assert!(CliParser::is_option_like("/?"));
        assert!(CliParser::is_option_like("-"));
        assert!(CliParser::is_option_like("--"));
        assert!(CliParser::is_option_like("/"));
    }

    #[test]
    fn should_identify_non_option_strings() {
        assert!(!CliParser::is_option_like("path"));
        assert!(!CliParser::is_option_like("C:\\dir"));
        assert!(!CliParser::is_option_like("file.txt"));
        assert!(!CliParser::is_option_like(""));
        assert!(!CliParser::is_option_like("123"));
    }

    // ------------------------------------------------------------------------
    // from_env 测试
    // ------------------------------------------------------------------------

    #[test]
    fn should_create_parser_from_env() {
        // 这个测试主要验证 from_env 不会 panic
        let _parser = CliParser::from_env();
        // 不调用 parse()，因为实际的命令行参数可能导致各种结果
    }
}
```


config.rs:  

```rust
//! 配置模块：定义全量 Config 及其子配置结构
//!
//! 本模块是用户意图的**单一事实来源**（Single Source of Truth）。
//! 所有命令行参数经 CLI 层解析后，统一转换为 `Config` 结构，
//! 后续扫描、匹配、渲染、输出各层仅依赖此配置，不再直接访问原始参数。
//!
//! 作者: WaterRun
//! 更新于: 2025-01-06

#![forbid(unsafe_code)]

use std::num::NonZeroUsize;
use std::path::PathBuf;
use thiserror::Error;
use std::path::PathBuf;

// ============================================================================
// 错误类型
// ============================================================================

/// 配置验证错误
///
/// 表示用户输入的参数组合不合法或无法满足运行条件时产生的错误。
///
/// # Examples
///
/// ```
/// use treepp::config::ConfigError;
///
/// let err = ConfigError::ConflictingOptions {
///     opt_a: "--include".to_string(),
///     opt_b: "--exclude".to_string(),
///     reason: "不能同时指定包含和排除同一模式".to_string(),
/// };
/// assert!(err.to_string().contains("--include"));
/// ```
#[derive(Debug, Error, Clone, PartialEq, Eq)]
pub enum ConfigError {
    /// 选项之间存在冲突
    #[error("选项冲突: {opt_a} 与 {opt_b} 不能同时使用 ({reason})")]
    ConflictingOptions {
        /// 冲突选项 A
        opt_a: String,
        /// 冲突选项 B
        opt_b: String,
        /// 冲突原因
        reason: String,
    },

    /// 参数值无效
    #[error("无效参数值: {option} = {value} ({reason})")]
    InvalidValue {
        /// 选项名称
        option: String,
        /// 提供的值
        value: String,
        /// 无效原因
        reason: String,
    },

    /// 路径不存在或不可访问
    #[error("路径无效: {path} ({reason})")]
    InvalidPath {
        /// 路径
        path: PathBuf,
        /// 原因
        reason: String,
    },

    /// 输出格式无法推导
    #[error("无法推导输出格式: {path} (支持的扩展名: .txt, .json, .yml, .yaml, .toml)")]
    UnknownOutputFormat {
        /// 输出文件路径
        path: PathBuf,
    },
}

/// 配置验证结果类型
pub type ConfigResult<T> = Result<T, ConfigError>;

// ============================================================================
// 枚举类型定义
// ============================================================================

/// 排序键
///
/// 指定目录树条目的排序依据。
///
/// # Examples
///
/// ```
/// use treepp::config::SortKey;
///
/// let key = SortKey::from_str_loose("SIZE");
/// assert_eq!(key, Some(SortKey::Size));
///
/// let key = SortKey::from_str_loose("unknown");
/// assert_eq!(key, None);
/// ```
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum SortKey {
    /// 按名称字母序排序（默认）
    #[default]
    Name,
    /// 按文件大小排序
    Size,
    /// 按最后修改时间排序
    Mtime,
    /// 按创建时间排序
    Ctime,
}

impl SortKey {
    /// 从字符串松散解析排序键（大小写不敏感）
    ///
    /// # Examples
    ///
    /// ```
    /// use treepp::config::SortKey;
    ///
    /// assert_eq!(SortKey::from_str_loose("name"), Some(SortKey::Name));
    /// assert_eq!(SortKey::from_str_loose("MTIME"), Some(SortKey::Mtime));
    /// assert_eq!(SortKey::from_str_loose("invalid"), None);
    /// ```
    #[must_use]
    pub fn from_str_loose(s: &str) -> Option<Self> {
        match s.to_ascii_lowercase().as_str() {
            "name" => Some(Self::Name),
            "size" => Some(Self::Size),
            "mtime" => Some(Self::Mtime),
            "ctime" => Some(Self::Ctime),
            _ => None,
        }
    }

    /// 获取所有有效的排序键名称
    #[must_use]
    pub const fn valid_keys() -> &'static [&'static str] {
        &["name", "size", "mtime", "ctime"]
    }
}

/// 输出格式
///
/// 指定结果输出的文件格式。
///
/// # Examples
///
/// ```
/// use std::path::Path;
/// use treepp::config::OutputFormat;
///
/// let format = OutputFormat::from_extension(Path::new("tree.json"));
/// assert_eq!(format, Some(OutputFormat::Json));
/// ```
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum OutputFormat {
    /// 纯文本格式（默认）
    #[default]
    Txt,
    /// JSON 格式
    Json,
    /// YAML 格式
    Yaml,
    /// TOML 格式
    Toml,
}

impl OutputFormat {
    /// 从文件扩展名推导输出格式
    ///
    /// # Examples
    ///
    /// ```
    /// use std::path::Path;
    /// use treepp::config::OutputFormat;
    ///
    /// assert_eq!(OutputFormat::from_extension(Path::new("out.txt")), Some(OutputFormat::Txt));
    /// assert_eq!(OutputFormat::from_extension(Path::new("out.yml")), Some(OutputFormat::Yaml));
    /// assert_eq!(OutputFormat::from_extension(Path::new("out.yaml")), Some(OutputFormat::Yaml));
    /// assert_eq!(OutputFormat::from_extension(Path::new("out.unknown")), None);
    /// ```
    #[must_use]
    pub fn from_extension(path: &std::path::Path) -> Option<Self> {
        path.extension()
            .and_then(|ext| ext.to_str())
            .and_then(|ext| match ext.to_ascii_lowercase().as_str() {
                "txt" => Some(Self::Txt),
                "json" => Some(Self::Json),
                "yml" | "yaml" => Some(Self::Yaml),
                "toml" => Some(Self::Toml),
                _ => None,
            })
    }

    /// 获取格式对应的默认扩展名
    #[must_use]
    pub const fn extension(&self) -> &'static str {
        match self {
            Self::Txt => "txt",
            Self::Json => "json",
            Self::Yaml => "yml",
            Self::Toml => "toml",
        }
    }
}

/// 字符集模式
///
/// 控制树形符号使用 ASCII 还是 Unicode 字符。
///
/// # Examples
///
/// ```
/// use treepp::config::CharsetMode;
///
/// let mode = CharsetMode::Ascii;
/// assert_eq!(mode.branch(), "+--");
/// assert_eq!(mode.last_branch(), "\\--");
///
/// let mode = CharsetMode::Unicode;
/// assert_eq!(mode.branch(), "├─");
/// assert_eq!(mode.last_branch(), "└─");
/// ```
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum CharsetMode {
    /// 使用 Unicode 字符绘制树形（默认）
    #[default]
    Unicode,
    /// 使用 ASCII 字符绘制树形（兼容 `tree /A`）
    Ascii,
}

impl CharsetMode {
    /// 获取普通分支符号
    #[must_use]
    pub const fn branch(&self) -> &'static str {
        match self {
            Self::Unicode => "├─",
            Self::Ascii => "+--",
        }
    }

    /// 获取最后一个分支符号
    #[must_use]
    pub const fn last_branch(&self) -> &'static str {
        match self {
            Self::Unicode => "└─",
            Self::Ascii => "\\--",
        }
    }

    /// 获取纵向连接线符号
    #[must_use]
    pub const fn vertical(&self) -> &'static str {
        match self {
            Self::Unicode => "│  ",
            Self::Ascii => "|   ",
        }
    }

    /// 获取空白缩进
    #[must_use]
    pub const fn indent(&self) -> &'static str {
        match self {
            Self::Unicode => "   ",
            Self::Ascii => "    ",
        }
    }
}

/// 路径显示模式
///
/// 控制输出中显示完整路径还是相对名称。
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub enum PathMode {
    /// 仅显示名称（默认）
    #[default]
    Relative,
    /// 显示完整绝对路径
    Full,
}

// ============================================================================
// 子配置结构
// ============================================================================

/// 扫描选项
///
/// 控制目录遍历行为的配置。
///
/// # Examples
///
/// ```
/// use treepp::config::ScanOptions;
///
/// let opts = ScanOptions::default();
/// assert_eq!(opts.max_depth, None);
/// assert!(opts.show_files);
/// assert_eq!(opts.thread_count.get(), 8);
/// ```
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct ScanOptions {
    /// 最大递归深度（None 表示无限制）
    pub max_depth: Option<usize>,
    /// 是否显示文件（对应 `/F`）
    pub show_files: bool,
    /// 扫描线程数
    pub thread_count: NonZeroUsize,
    /// 是否遵循 `.gitignore` 规则
    pub respect_gitignore: bool,
}

impl Default for ScanOptions {
    fn default() -> Self {
        Self {
            max_depth: None,
            show_files: false,
            // 安全：8 是非零常量
            thread_count: NonZeroUsize::new(8).expect("8 is non-zero"),
            respect_gitignore: false,
        }
    }
}

/// 匹配选项
///
/// 控制文件/目录过滤行为的配置。
///
/// # Examples
///
/// ```
/// use treepp::config::MatchOptions;
///
/// let opts = MatchOptions::default();
/// assert!(opts.include_patterns.is_empty());
/// assert!(opts.exclude_patterns.is_empty());
/// assert!(!opts.ignore_case);
/// ```
#[derive(Debug, Clone, PartialEq, Eq, Default)]
pub struct MatchOptions {
    /// 包含模式列表（仅显示匹配项）
    pub include_patterns: Vec<String>,
    /// 排除模式列表（忽略匹配项）
    pub exclude_patterns: Vec<String>,
    /// 匹配时是否忽略大小写
    pub ignore_case: bool,
    /// 是否修剪空目录
    pub prune_empty: bool,
}

/// 渲染选项
///
/// 控制树形输出外观的配置。
///
/// # Examples
///
/// ```
/// use treepp::config::{RenderOptions, CharsetMode, PathMode, SortKey};
///
/// let opts = RenderOptions::default();
/// assert_eq!(opts.charset, CharsetMode::Unicode);
/// assert_eq!(opts.path_mode, PathMode::Relative);
/// assert!(!opts.show_size);
/// ```
#[derive(Debug, Clone, PartialEq, Eq, Default)]
pub struct RenderOptions {
    /// 字符集模式
    pub charset: CharsetMode,
    /// 路径显示模式
    pub path_mode: PathMode,
    /// 是否显示文件大小
    pub show_size: bool,
    /// 是否以人类可读格式显示大小
    pub human_readable: bool,
    /// 是否显示最后修改日期
    pub show_date: bool,
    /// 是否显示目录累计大小
    pub show_disk_usage: bool,
    /// 是否不显示树形连接线（仅缩进）
    pub no_indent: bool,
    /// 排序键
    pub sort_key: SortKey,
    /// 是否逆序排序
    pub reverse_sort: bool,
    /// 是否显示末尾统计报告
    pub show_report: bool,
    /// 是否隐藏 Windows 原生样板信息
    pub no_win_banner: bool,
    /// 是否用双引号包裹文件名
    pub quote_names: bool,
    /// 是否目录优先显示
    pub dirs_first: bool,
}

/// 输出选项
///
/// 控制结果输出方式的配置。
///
/// # Examples
///
/// ```
/// use treepp::config::OutputOptions;
///
/// let opts = OutputOptions::default();
/// assert!(opts.output_path.is_none());
/// assert!(!opts.silent);
/// ```
#[derive(Debug, Clone, PartialEq, Eq, Default)]
pub struct OutputOptions {
    /// 输出文件路径（None 表示仅输出到终端）
    pub output_path: Option<PathBuf>,
    /// 输出格式（从 output_path 扩展名推导，或默认 Txt）
    pub format: OutputFormat,
    /// 是否静默（不输出到终端）
    pub silent: bool,
}

// ============================================================================
// 主配置结构
// ============================================================================

/// 全量配置
///
/// 用户意图的单一事实来源。CLI 解析后生成此结构，
/// 后续所有模块（扫描、匹配、渲染、输出）均依赖此配置运行。
///
/// # Examples
///
/// ```
/// use std::path::PathBuf;
/// use treepp::config::Config;
///
/// let config = Config::default();
/// assert_eq!(config.root_path, PathBuf::from("."));
/// assert!(!config.scan.show_files);
/// ```
///
/// ```
/// use std::path::PathBuf;
/// use treepp::config::{Config, ScanOptions, OutputOptions, OutputFormat};
/// use std::num::NonZeroUsize;
///
/// let mut config = Config::default();
/// config.root_path = PathBuf::from("C:\\Windows");
/// config.scan.show_files = true;
/// config.scan.thread_count = NonZeroUsize::new(16).unwrap();
/// config.output.output_path = Some(PathBuf::from("tree.json"));
///
/// let validated = config.validate().expect("验证应通过");
/// assert_eq!(validated.output.format, OutputFormat::Json);
/// ```
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Config {
    /// 根路径（起始目录）
    pub root_path: PathBuf,
    /// 是否显示帮助信息
    pub show_help: bool,
    /// 是否显示版本信息
    pub show_version: bool,
    /// 扫描选项
    pub scan: ScanOptions,
    /// 匹配选项
    pub matching: MatchOptions,
    /// 渲染选项
    pub render: RenderOptions,
    /// 输出选项
    pub output: OutputOptions,
}

impl Default for Config {
    fn default() -> Self {
        Self {
            root_path: PathBuf::from("."),
            show_help: false,
            show_version: false,
            scan: ScanOptions::default(),
            matching: MatchOptions::default(),
            render: RenderOptions::default(),
            output: OutputOptions::default(),
        }
    }
}

impl Config {
    /// 创建具有指定根路径的配置
    ///
    /// # Examples
    ///
    /// ```
    /// use std::path::PathBuf;
    /// use treepp::config::Config;
    ///
    /// let config = Config::with_root(PathBuf::from("C:\\Users"));
    /// assert_eq!(config.root_path, PathBuf::from("C:\\Users"));
    /// ```
    #[must_use]
    pub fn with_root(root_path: PathBuf) -> Self {
        Self {
            root_path,
            ..Self::default()
        }
    }

    /// 验证配置并补齐派生字段
    ///
    /// 执行以下操作：
    /// - 检查选项冲突
    /// - 验证根路径存在性并规范化
    /// - 验证参数值合法性
    /// - 从输出路径扩展名推导输出格式
    /// - 应用默认值
    ///
    /// # Errors
    ///
    /// 返回 `ConfigError` 如果：
    /// - 选项之间存在不可调和的冲突
    /// - 根路径不存在或不是目录
    /// - 参数值无效（如未知的排序键）
    /// - 输出路径扩展名无法识别
    ///
    /// # Examples
    ///
    /// ```
    /// use std::path::PathBuf;
    /// use treepp::config::{Config, OutputFormat};
    ///
    /// let mut config = Config::default();
    /// config.output.output_path = Some(PathBuf::from("result.json"));
    ///
    /// let validated = config.validate().unwrap();
    /// assert_eq!(validated.output.format, OutputFormat::Json);
    /// ```
    ///
    /// ```
    /// use std::path::PathBuf;
    /// use treepp::config::{Config, ConfigError};
    ///
    /// let mut config = Config::default();
    /// config.output.output_path = Some(PathBuf::from("result.xyz"));
    ///
    /// let err = config.validate().unwrap_err();
    /// assert!(matches!(err, ConfigError::UnknownOutputFormat { .. }));
    /// ```
    pub fn validate(mut self) -> ConfigResult<Self> {
        // 1. 选项冲突检查
        self.check_conflicts()?;

        // 2. 根路径验证与规范化
        self.validate_and_canonicalize_root_path()?;

        // 3. 派生字段：从输出路径推导格式
        if let Some(ref path) = self.output.output_path {
            if let Some(format) = OutputFormat::from_extension(path) {
                self.output.format = format;
            } else {
                return Err(ConfigError::UnknownOutputFormat { path: path.clone() });
            }
        }

        // 4. 隐含依赖：human_readable 隐含 show_size
        if self.render.human_readable {
            self.render.show_size = true;
        }

        // 5. 隐含依赖：show_disk_usage 需要 show_size 语义支持
        // （但 show_disk_usage 是目录级别统计，与 show_size 不冲突）

        // 6. 线程数下限校验（NonZeroUsize 已保证 >= 1，无需额外检查）

        Ok(self)
    }

    /// 验证根路径并规范化
    ///
    /// 使用 dunce 规范化路径，避免 Windows 上的 `\\?\` 前缀问题。
    fn validate_and_canonicalize_root_path(&mut self) -> ConfigResult<()> {
        // 检查路径是否存在
        if !self.root_path.exists() {
            return Err(ConfigError::InvalidPath {
                path: self.root_path.clone(),
                reason: "路径不存在".to_string(),
            });
        }

        // 检查是否为目录
        if !self.root_path.is_dir() {
            return Err(ConfigError::InvalidPath {
                path: self.root_path.clone(),
                reason: "路径不是目录".to_string(),
            });
        }

        // 使用 dunce 规范化路径，避免 Windows 上的 \\?\ 前缀
        match dunce::canonicalize(&self.root_path) {
            Ok(canonical) => {
                self.root_path = canonical;
                Ok(())
            }
            Err(e) => Err(ConfigError::InvalidPath {
                path: self.root_path.clone(),
                reason: format!("无法规范化路径: {}", e),
            }),
        }
    }

    /// 检查选项冲突
    fn check_conflicts(&self) -> ConfigResult<()> {
        // 冲突：silent 必须配合 output_path 使用
        if self.output.silent && self.output.output_path.is_none() {
            return Err(ConfigError::ConflictingOptions {
                opt_a: "--silent".to_string(),
                opt_b: "(无 --output)".to_string(),
                reason: "静默模式必须指定输出文件，否则无任何输出".to_string(),
            });
        }

        // 冲突：no_indent 与 charset 的视觉效果说明（非阻断性，允许组合）
        // 此处不阻断，仅作为设计说明

        // 冲突：human_readable 无意义时的提示（非阻断）
        // 当 show_size 和 show_disk_usage 均为 false 时，human_readable 无效
        // validate() 会自动开启 show_size，故此处无需检查

        Ok(())
    }

    /// 判断是否为"仅信息显示"模式（帮助或版本）
    ///
    /// # Examples
    ///
    /// ```
    /// use treepp::config::Config;
    ///
    /// let mut config = Config::default();
    /// assert!(!config.is_info_only());
    ///
    /// config.show_help = true;
    /// assert!(config.is_info_only());
    /// ```
    #[must_use]
    pub const fn is_info_only(&self) -> bool {
        self.show_help || self.show_version
    }

    /// 判断是否需要计算文件大小信息
    ///
    /// 当 show_size、human_readable 或 show_disk_usage 任一启用时返回 true。
    ///
    /// # Examples
    ///
    /// ```
    /// use treepp::config::Config;
    ///
    /// let mut config = Config::default();
    /// assert!(!config.needs_size_info());
    ///
    /// config.render.show_size = true;
    /// assert!(config.needs_size_info());
    /// ```
    #[must_use]
    pub const fn needs_size_info(&self) -> bool {
        self.render.show_size || self.render.human_readable || self.render.show_disk_usage
    }

    /// 判断是否需要计算时间信息
    ///
    /// 当 show_date 启用或排序依据为时间相关键时返回 true。
    ///
    /// # Examples
    ///
    /// ```
    /// use treepp::config::{Config, SortKey};
    ///
    /// let mut config = Config::default();
    /// assert!(!config.needs_time_info());
    ///
    /// config.render.sort_key = SortKey::Mtime;
    /// assert!(config.needs_time_info());
    /// ```
    #[must_use]
    pub const fn needs_time_info(&self) -> bool {
        self.render.show_date
            || matches!(self.render.sort_key, SortKey::Mtime | SortKey::Ctime)
    }
}

// ============================================================================
// 单元测试
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;

    // ------------------------------------------------------------------------
    // SortKey 测试
    // ------------------------------------------------------------------------

    #[test]
    fn sort_key_from_str_loose_should_parse_valid_keys() {
        assert_eq!(SortKey::from_str_loose("name"), Some(SortKey::Name));
        assert_eq!(SortKey::from_str_loose("NAME"), Some(SortKey::Name));
        assert_eq!(SortKey::from_str_loose("Name"), Some(SortKey::Name));
        assert_eq!(SortKey::from_str_loose("size"), Some(SortKey::Size));
        assert_eq!(SortKey::from_str_loose("SIZE"), Some(SortKey::Size));
        assert_eq!(SortKey::from_str_loose("mtime"), Some(SortKey::Mtime));
        assert_eq!(SortKey::from_str_loose("MTIME"), Some(SortKey::Mtime));
        assert_eq!(SortKey::from_str_loose("ctime"), Some(SortKey::Ctime));
        assert_eq!(SortKey::from_str_loose("CTIME"), Some(SortKey::Ctime));
    }

    #[test]
    fn sort_key_from_str_loose_should_return_none_for_invalid_keys() {
        assert_eq!(SortKey::from_str_loose(""), None);
        assert_eq!(SortKey::from_str_loose("invalid"), None);
        assert_eq!(SortKey::from_str_loose("date"), None);
        assert_eq!(SortKey::from_str_loose("time"), None);
    }

    #[test]
    fn sort_key_default_should_be_name() {
        assert_eq!(SortKey::default(), SortKey::Name);
    }

    // ------------------------------------------------------------------------
    // OutputFormat 测试
    // ------------------------------------------------------------------------

    #[test]
    fn output_format_from_extension_should_recognize_valid_extensions() {
        use std::path::Path;

        assert_eq!(
            OutputFormat::from_extension(Path::new("file.txt")),
            Some(OutputFormat::Txt)
        );
        assert_eq!(
            OutputFormat::from_extension(Path::new("file.TXT")),
            Some(OutputFormat::Txt)
        );
        assert_eq!(
            OutputFormat::from_extension(Path::new("file.json")),
            Some(OutputFormat::Json)
        );
        assert_eq!(
            OutputFormat::from_extension(Path::new("file.JSON")),
            Some(OutputFormat::Json)
        );
        assert_eq!(
            OutputFormat::from_extension(Path::new("file.yml")),
            Some(OutputFormat::Yaml)
        );
        assert_eq!(
            OutputFormat::from_extension(Path::new("file.yaml")),
            Some(OutputFormat::Yaml)
        );
        assert_eq!(
            OutputFormat::from_extension(Path::new("file.YAML")),
            Some(OutputFormat::Yaml)
        );
        assert_eq!(
            OutputFormat::from_extension(Path::new("file.toml")),
            Some(OutputFormat::Toml)
        );
        assert_eq!(
            OutputFormat::from_extension(Path::new("file.TOML")),
            Some(OutputFormat::Toml)
        );
    }

    #[test]
    fn output_format_from_extension_should_return_none_for_unknown() {
        use std::path::Path;

        assert_eq!(OutputFormat::from_extension(Path::new("file.xyz")), None);
        assert_eq!(OutputFormat::from_extension(Path::new("file")), None);
        assert_eq!(OutputFormat::from_extension(Path::new("")), None);
        assert_eq!(OutputFormat::from_extension(Path::new("file.md")), None);
    }

    #[test]
    fn output_format_extension_should_return_correct_string() {
        assert_eq!(OutputFormat::Txt.extension(), "txt");
        assert_eq!(OutputFormat::Json.extension(), "json");
        assert_eq!(OutputFormat::Yaml.extension(), "yml");
        assert_eq!(OutputFormat::Toml.extension(), "toml");
    }

    #[test]
    fn output_format_default_should_be_txt() {
        assert_eq!(OutputFormat::default(), OutputFormat::Txt);
    }

    // ------------------------------------------------------------------------
    // CharsetMode 测试
    // ------------------------------------------------------------------------

    #[test]
    fn charset_mode_unicode_should_return_unicode_symbols() {
        let mode = CharsetMode::Unicode;
        assert_eq!(mode.branch(), "├─");
        assert_eq!(mode.last_branch(), "└─");
        assert_eq!(mode.vertical(), "│  ");
        assert_eq!(mode.indent(), "   ");
    }

    #[test]
    fn charset_mode_ascii_should_return_ascii_symbols() {
        let mode = CharsetMode::Ascii;
        assert_eq!(mode.branch(), "+--");
        assert_eq!(mode.last_branch(), "\\--");
        assert_eq!(mode.vertical(), "|   ");
        assert_eq!(mode.indent(), "    ");
    }

    #[test]
    fn charset_mode_default_should_be_unicode() {
        assert_eq!(CharsetMode::default(), CharsetMode::Unicode);
    }

    // ------------------------------------------------------------------------
    // PathMode 测试
    // ------------------------------------------------------------------------

    #[test]
    fn path_mode_default_should_be_relative() {
        assert_eq!(PathMode::default(), PathMode::Relative);
    }

    // ------------------------------------------------------------------------
    // ScanOptions 测试
    // ------------------------------------------------------------------------

    #[test]
    fn scan_options_default_should_have_expected_values() {
        let opts = ScanOptions::default();
        assert_eq!(opts.max_depth, None);
        assert!(!opts.show_files);
        assert_eq!(opts.thread_count.get(), 8);
        assert!(!opts.respect_gitignore);
    }

    // ------------------------------------------------------------------------
    // MatchOptions 测试
    // ------------------------------------------------------------------------

    #[test]
    fn match_options_default_should_be_empty() {
        let opts = MatchOptions::default();
        assert!(opts.include_patterns.is_empty());
        assert!(opts.exclude_patterns.is_empty());
        assert!(!opts.ignore_case);
        assert!(!opts.prune_empty);
    }

    // ------------------------------------------------------------------------
    // RenderOptions 测试
    // ------------------------------------------------------------------------

    #[test]
    fn render_options_default_should_have_expected_values() {
        let opts = RenderOptions::default();
        assert_eq!(opts.charset, CharsetMode::Unicode);
        assert_eq!(opts.path_mode, PathMode::Relative);
        assert!(!opts.show_size);
        assert!(!opts.human_readable);
        assert!(!opts.show_date);
        assert!(!opts.show_disk_usage);
        assert!(!opts.no_indent);
        assert_eq!(opts.sort_key, SortKey::Name);
        assert!(!opts.reverse_sort);
        assert!(!opts.show_report);
        assert!(!opts.no_win_banner);
        assert!(!opts.quote_names);
        assert!(!opts.dirs_first);
    }

    // ------------------------------------------------------------------------
    // OutputOptions 测试
    // ------------------------------------------------------------------------

    #[test]
    fn output_options_default_should_have_expected_values() {
        let opts = OutputOptions::default();
        assert!(opts.output_path.is_none());
        assert_eq!(opts.format, OutputFormat::Txt);
        assert!(!opts.silent);
    }

    // ------------------------------------------------------------------------
    // Config 基本测试
    // ------------------------------------------------------------------------

    #[test]
    fn config_default_should_have_expected_values() {
        let config = Config::default();
        assert_eq!(config.root_path, PathBuf::from("."));
        assert!(!config.show_help);
        assert!(!config.show_version);
    }

    #[test]
    fn config_with_root_should_set_root_path() {
        let config = Config::with_root(PathBuf::from("C:\\Windows"));
        assert_eq!(config.root_path, PathBuf::from("C:\\Windows"));
    }

    #[test]
    fn config_is_info_only_should_detect_help_and_version() {
        let mut config = Config::default();
        assert!(!config.is_info_only());

        config.show_help = true;
        assert!(config.is_info_only());

        config.show_help = false;
        config.show_version = true;
        assert!(config.is_info_only());

        config.show_help = true;
        assert!(config.is_info_only());
    }

    #[test]
    fn config_needs_size_info_should_detect_size_related_options() {
        let mut config = Config::default();
        assert!(!config.needs_size_info());

        config.render.show_size = true;
        assert!(config.needs_size_info());

        config.render.show_size = false;
        config.render.human_readable = true;
        assert!(config.needs_size_info());

        config.render.human_readable = false;
        config.render.show_disk_usage = true;
        assert!(config.needs_size_info());
    }

    #[test]
    fn config_needs_time_info_should_detect_time_related_options() {
        let mut config = Config::default();
        assert!(!config.needs_time_info());

        config.render.show_date = true;
        assert!(config.needs_time_info());

        config.render.show_date = false;
        config.render.sort_key = SortKey::Mtime;
        assert!(config.needs_time_info());

        config.render.sort_key = SortKey::Ctime;
        assert!(config.needs_time_info());

        config.render.sort_key = SortKey::Name;
        assert!(!config.needs_time_info());
    }

    // ------------------------------------------------------------------------
    // Config::validate 测试
    // ------------------------------------------------------------------------

    #[test]
    fn validate_should_derive_format_from_output_path() {
        use tempfile::TempDir;

        let temp_dir = TempDir::new().expect("创建临时目录失败");
        let mut config = Config::default();
        config.root_path = temp_dir.path().to_path_buf();
        config.output.output_path = Some(PathBuf::from("result.json"));

        let validated = config.validate().unwrap();
        assert_eq!(validated.output.format, OutputFormat::Json);
    }

    #[test]
    fn validate_should_derive_yaml_format_from_yml_extension() {
        use tempfile::TempDir;

        let temp_dir = TempDir::new().expect("创建临时目录失败");
        let mut config = Config::default();
        config.root_path = temp_dir.path().to_path_buf();
        config.output.output_path = Some(PathBuf::from("result.yml"));

        let validated = config.validate().unwrap();
        assert_eq!(validated.output.format, OutputFormat::Yaml);
    }

    #[test]
    fn validate_should_derive_yaml_format_from_yaml_extension() {
        use tempfile::TempDir;

        let temp_dir = TempDir::new().expect("创建临时目录失败");
        let mut config = Config::default();
        config.root_path = temp_dir.path().to_path_buf();
        config.output.output_path = Some(PathBuf::from("result.yaml"));

        let validated = config.validate().unwrap();
        assert_eq!(validated.output.format, OutputFormat::Yaml);
    }

    #[test]
    fn validate_should_fail_for_unknown_extension() {
        use tempfile::TempDir;

        let temp_dir = TempDir::new().expect("创建临时目录失败");
        let mut config = Config::default();
        config.root_path = temp_dir.path().to_path_buf();
        config.output.output_path = Some(PathBuf::from("result.xyz"));

        let err = config.validate().unwrap_err();
        assert!(matches!(err, ConfigError::UnknownOutputFormat { .. }));
    }

    #[test]
    fn validate_should_enable_show_size_when_human_readable_is_set() {
        use tempfile::TempDir;

        let temp_dir = TempDir::new().expect("创建临时目录失败");
        let mut config = Config::default();
        config.root_path = temp_dir.path().to_path_buf();
        config.render.human_readable = true;
        config.render.show_size = false;

        let validated = config.validate().unwrap();
        assert!(validated.render.show_size);
        assert!(validated.render.human_readable);
    }

    #[test]
    fn validate_should_fail_when_silent_without_output() {
        use tempfile::TempDir;

        let temp_dir = TempDir::new().expect("创建临时目录失败");
        let mut config = Config::default();
        config.root_path = temp_dir.path().to_path_buf();
        config.output.silent = true;
        config.output.output_path = None;

        let err = config.validate().unwrap_err();
        assert!(matches!(err, ConfigError::ConflictingOptions { .. }));

        if let ConfigError::ConflictingOptions { opt_a, .. } = err {
            assert_eq!(opt_a, "--silent");
        }
    }

    #[test]
    fn validate_should_succeed_when_silent_with_output() {
        use tempfile::TempDir;

        let temp_dir = TempDir::new().expect("创建临时目录失败");
        let mut config = Config::default();
        config.root_path = temp_dir.path().to_path_buf();
        config.output.silent = true;
        config.output.output_path = Some(PathBuf::from("tree.txt"));

        let validated = config.validate().unwrap();
        assert!(validated.output.silent);
        assert_eq!(validated.output.format, OutputFormat::Txt);
    }

    #[test]
    fn validate_should_preserve_all_options() {
        use tempfile::TempDir;

        let temp_dir = TempDir::new().expect("创建临时目录失败");
        let mut config = Config::default();
        config.root_path = temp_dir.path().to_path_buf();
        config.scan.show_files = true;
        config.scan.max_depth = Some(3);
        config.scan.respect_gitignore = true;
        config.matching.include_patterns = vec!["*.rs".to_string()];
        config.matching.exclude_patterns = vec!["target".to_string()];
        config.matching.ignore_case = true;
        config.matching.prune_empty = true;
        config.render.charset = CharsetMode::Ascii;
        config.render.path_mode = PathMode::Full;
        config.render.show_size = true;
        config.render.show_date = true;
        config.render.sort_key = SortKey::Size;
        config.render.reverse_sort = true;
        config.render.show_report = true;
        config.render.no_win_banner = true;
        config.render.quote_names = true;
        config.render.dirs_first = true;
        config.output.output_path = Some(PathBuf::from("out.toml"));

        let validated = config.validate().unwrap();

        // 路径已被规范化，不再比较具体值
        assert!(validated.root_path.is_absolute());
        assert!(validated.scan.show_files);
        assert_eq!(validated.scan.max_depth, Some(3));
        assert!(validated.scan.respect_gitignore);
        assert_eq!(validated.matching.include_patterns, vec!["*.rs"]);
        assert_eq!(validated.matching.exclude_patterns, vec!["target"]);
        assert!(validated.matching.ignore_case);
        assert!(validated.matching.prune_empty);
        assert_eq!(validated.render.charset, CharsetMode::Ascii);
        assert_eq!(validated.render.path_mode, PathMode::Full);
        assert!(validated.render.show_size);
        assert!(validated.render.show_date);
        assert_eq!(validated.render.sort_key, SortKey::Size);
        assert!(validated.render.reverse_sort);
        assert!(validated.render.show_report);
        assert!(validated.render.no_win_banner);
        assert!(validated.render.quote_names);
        assert!(validated.render.dirs_first);
        assert_eq!(validated.output.format, OutputFormat::Toml);
    }

    // ------------------------------------------------------------------------
    // ConfigError 测试
    // ------------------------------------------------------------------------

    #[test]
    fn config_error_display_should_contain_relevant_info() {
        let err = ConfigError::ConflictingOptions {
            opt_a: "--foo".to_string(),
            opt_b: "--bar".to_string(),
            reason: "test reason".to_string(),
        };
        let msg = err.to_string();
        assert!(msg.contains("--foo"));
        assert!(msg.contains("--bar"));
        assert!(msg.contains("test reason"));

        let err = ConfigError::InvalidValue {
            option: "--level".to_string(),
            value: "abc".to_string(),
            reason: "must be a number".to_string(),
        };
        let msg = err.to_string();
        assert!(msg.contains("--level"));
        assert!(msg.contains("abc"));
        assert!(msg.contains("must be a number"));

        let err = ConfigError::InvalidPath {
            path: PathBuf::from("/nonexistent"),
            reason: "not found".to_string(),
        };
        let msg = err.to_string();
        assert!(msg.contains("nonexistent"));
        assert!(msg.contains("not found"));

        let err = ConfigError::UnknownOutputFormat {
            path: PathBuf::from("file.xyz"),
        };
        let msg = err.to_string();
        assert!(msg.contains("file.xyz"));
        assert!(msg.contains(".txt"));
        assert!(msg.contains(".json"));
    }

    #[test]
    fn config_error_should_be_cloneable_and_comparable() {
        let err1 = ConfigError::ConflictingOptions {
            opt_a: "a".to_string(),
            opt_b: "b".to_string(),
            reason: "r".to_string(),
        };
        let err2 = err1.clone();
        assert_eq!(err1, err2);
    }

    #[test]
    fn validate_should_fail_for_nonexistent_path() {
        let mut config = Config::default();
        config.root_path = PathBuf::from("/nonexistent/path/12345");

        let err = config.validate().unwrap_err();
        assert!(matches!(err, ConfigError::InvalidPath { .. }));

        if let ConfigError::InvalidPath { reason, .. } = err {
            assert!(reason.contains("不存在"));
        }
    }

    #[test]
    fn validate_should_fail_for_file_as_root() {
        use tempfile::NamedTempFile;

        let temp_file = NamedTempFile::new().expect("创建临时文件失败");
        let mut config = Config::default();
        config.root_path = temp_file.path().to_path_buf();

        let err = config.validate().unwrap_err();
        assert!(matches!(err, ConfigError::InvalidPath { .. }));

        if let ConfigError::InvalidPath { reason, .. } = err {
            assert!(reason.contains("不是目录"));
        }
    }

    #[test]
    fn validate_should_canonicalize_path() {
        use tempfile::TempDir;

        let temp_dir = TempDir::new().expect("创建临时目录失败");
        let mut config = Config::default();
        config.root_path = temp_dir.path().to_path_buf();

        let validated = config.validate().expect("验证应成功");

        // 规范化后的路径应该是绝对路径
        assert!(validated.root_path.is_absolute());
    }
}
```

error.rs:  

```rust
//! 错误处理模块：定义全局统一错误类型
//!
//! 本模块为 tree++ 提供统一的错误类型层次结构，覆盖以下场景：
//!
//! - **CLI 解析错误**：参数格式、冲突、未知选项等
//! - **配置错误**：重导出自 `config` 模块，保持 API 一致性
//! - **扫描错误**：文件系统访问、权限、路径不存在等
//! - **匹配错误**：通配符模式语法、gitignore 规则解析等
//! - **渲染错误**：输出格式化过程中的异常
//! - **输出错误**：文件写入、序列化失败等
//!
//! 所有错误类型实现 `std::error::Error`，支持错误链追溯。
//!
//! 作者: WaterRun
//! 更新于: 2025-01-06

#![forbid(unsafe_code)]

use std::io;
use std::path::PathBuf;
use thiserror::Error;

// 重导出配置错误，保持 API 一致性
pub use crate::config::ConfigError;

// ============================================================================
// 顶层错误类型
// ============================================================================

/// tree++ 全局错误类型
///
/// 聚合所有子模块错误，作为程序主入口的统一错误返回类型。
/// 支持从各子错误类型自动转换。
///
/// # Examples
///
/// ```
/// use treepp::error::{TreeppError, CliError};
///
/// fn example_cli_error() -> Result<(), TreeppError> {
///     Err(CliError::UnknownOption {
///         option: "/Z".to_string(),
///     }.into())
/// }
///
/// let err = example_cli_error().unwrap_err();
/// assert!(err.to_string().contains("/Z"));
/// ```
#[derive(Debug, Error)]
pub enum TreeppError {
    /// CLI 解析错误
    #[error(transparent)]
    Cli(#[from] CliError),

    /// 配置验证错误
    #[error(transparent)]
    Config(#[from] ConfigError),

    /// 扫描错误
    #[error(transparent)]
    Scan(#[from] ScanError),

    /// 匹配规则错误
    #[error(transparent)]
    Match(#[from] MatchError),

    /// 渲染错误
    #[error(transparent)]
    Render(#[from] RenderError),

    /// 输出错误
    #[error(transparent)]
    Output(#[from] OutputError),
}

/// 全局结果类型别名
pub type TreeppResult<T> = Result<T, TreeppError>;

// ============================================================================
// CLI 解析错误
// ============================================================================

/// CLI 参数解析错误
///
/// 表示命令行参数解析阶段产生的错误，包括：
/// - 未知选项
/// - 缺少必需参数值
/// - 参数值格式错误
/// - 参数冲突
///
/// # Examples
///
/// ```
/// use treepp::error::CliError;
///
/// let err = CliError::MissingValue {
///     option: "--level".to_string(),
/// };
/// assert!(err.to_string().contains("--level"));
/// ```
#[derive(Debug, Error, Clone, PartialEq, Eq)]
pub enum CliError {
    /// 未知选项
    #[error("未知选项: {option}")]
    UnknownOption {
        /// 未识别的选项名
        option: String,
    },

    /// 选项缺少必需的参数值
    #[error("选项 {option} 需要一个参数值")]
    MissingValue {
        /// 选项名
        option: String,
    },

    /// 参数值格式错误
    #[error("选项 {option} 的值 '{value}' 无效: {reason}")]
    InvalidValue {
        /// 选项名
        option: String,
        /// 提供的值
        value: String,
        /// 错误原因
        reason: String,
    },

    /// 选项重复指定
    #[error("选项 {option} 重复指定")]
    DuplicateOption {
        /// 选项名
        option: String,
    },

    /// 选项之间冲突
    #[error("选项冲突: {opt_a} 与 {opt_b} 不能同时使用")]
    ConflictingOptions {
        /// 冲突选项 A
        opt_a: String,
        /// 冲突选项 B
        opt_b: String,
    },

    /// 路径参数出现在选项之后
    #[error("路径参数必须在所有选项之前: '{path}' 出现在选项 '{after_option}' 之后")]
    PathAfterOptions {
        /// 路径参数
        path: String,
        /// 之前出现的选项
        after_option: String,
    },

    /// 指定了多个路径
    #[error("只能指定一个路径，但发现多个: {paths:?}")]
    MultiplePaths {
        /// 所有发现的路径
        paths: Vec<String>,
    },

    /// 无法解析的路径参数
    #[error("无法解析路径参数: {arg}")]
    InvalidPath {
        /// 原始参数
        arg: String,
    },

    /// 底层解析错误
    #[error("参数解析错误: {message}")]
    ParseError {
        /// 错误消息
        message: String,
    },
}

// ============================================================================
// 扫描错误
// ============================================================================

/// 目录扫描错误
///
/// 表示目录遍历过程中产生的错误。
///
/// # Examples
///
/// ```
/// use std::path::PathBuf;
/// use treepp::error::ScanError;
///
/// let err = ScanError::PathNotFound {
///     path: PathBuf::from("C:\\nonexistent"),
/// };
/// assert!(err.to_string().contains("nonexistent"));
/// ```
#[derive(Debug, Error)]
pub enum ScanError {
    /// 路径不存在
    #[error("路径不存在: {path}")]
    PathNotFound {
        /// 不存在的路径
        path: PathBuf,
    },

    /// 路径不是目录
    #[error("路径不是目录: {path}")]
    NotADirectory {
        /// 非目录路径
        path: PathBuf,
    },

    /// 权限不足
    #[error("权限不足，无法访问: {path}")]
    PermissionDenied {
        /// 无权访问的路径
        path: PathBuf,
    },

    /// 读取目录失败
    #[error("读取目录失败: {path}")]
    ReadDirFailed {
        /// 目录路径
        path: PathBuf,
        /// 底层 IO 错误
        #[source]
        source: io::Error,
    },

    /// 获取元数据失败
    #[error("获取元数据失败: {path}")]
    MetadataFailed {
        /// 文件路径
        path: PathBuf,
        /// 底层 IO 错误
        #[source]
        source: io::Error,
    },

    /// 路径规范化失败
    #[error("路径规范化失败: {path}")]
    CanonicalizeFailed {
        /// 原始路径
        path: PathBuf,
        /// 底层 IO 错误
        #[source]
        source: io::Error,
    },

    /// walkdir 遍历错误
    #[error("目录遍历错误: {message}")]
    WalkError {
        /// 错误消息
        message: String,
        /// 相关路径（如有）
        path: Option<PathBuf>,
    },
}

impl ScanError {
    /// 从 IO 错误和路径创建适当的扫描错误
    ///
    /// 根据 IO 错误类型自动选择合适的错误变体。
    ///
    /// # Examples
    ///
    /// ```
    /// use std::io::{self, ErrorKind};
    /// use std::path::PathBuf;
    /// use treepp::error::ScanError;
    ///
    /// let io_err = io::Error::new(ErrorKind::NotFound, "not found");
    /// let scan_err = ScanError::from_io_error(io_err, PathBuf::from("/missing"));
    ///
    /// assert!(matches!(scan_err, ScanError::PathNotFound { .. }));
    /// ```
    #[must_use]
    pub fn from_io_error(err: io::Error, path: PathBuf) -> Self {
        match err.kind() {
            io::ErrorKind::NotFound => Self::PathNotFound { path },
            io::ErrorKind::PermissionDenied => Self::PermissionDenied { path },
            _ => Self::ReadDirFailed { path, source: err },
        }
    }
}

// ============================================================================
// 匹配规则错误
// ============================================================================

/// 匹配规则错误
///
/// 表示模式匹配和 gitignore 规则解析过程中的错误。
///
/// # Examples
///
/// ```
/// use treepp::error::MatchError;
///
/// let err = MatchError::InvalidPattern {
///     pattern: "[invalid".to_string(),
///     reason: "未闭合的字符类".to_string(),
/// };
/// assert!(err.to_string().contains("[invalid"));
/// ```
#[derive(Debug, Error, Clone, PartialEq, Eq)]
pub enum MatchError {
    /// 无效的通配符模式
    #[error("无效的匹配模式 '{pattern}': {reason}")]
    InvalidPattern {
        /// 无效的模式字符串
        pattern: String,
        /// 错误原因
        reason: String,
    },

    /// gitignore 文件解析失败
    #[error("解析 .gitignore 失败: {path}")]
    GitignoreParseError {
        /// gitignore 文件路径
        path: PathBuf,
        /// 错误详情
        detail: String,
    },

    /// gitignore 规则构建失败
    #[error("构建 gitignore 规则失败: {reason}")]
    GitignoreBuildError {
        /// 错误原因
        reason: String,
    },
}

impl MatchError {
    /// 从 glob 模式错误创建
    ///
    /// # Examples
    ///
    /// ```
    /// use treepp::error::MatchError;
    ///
    /// let err = MatchError::from_glob_error("[bad", "unclosed bracket");
    /// assert!(matches!(err, MatchError::InvalidPattern { .. }));
    /// ```
    #[must_use]
    pub fn from_glob_error(pattern: &str, reason: &str) -> Self {
        Self::InvalidPattern {
            pattern: pattern.to_string(),
            reason: reason.to_string(),
        }
    }
}

// ============================================================================
// 渲染错误
// ============================================================================

/// 渲染错误
///
/// 表示树形结构渲染过程中的错误。
/// 此类错误较少见，主要用于处理极端情况。
///
/// # Examples
///
/// ```
/// use treepp::error::RenderError;
///
/// let err = RenderError::FormatError {
///     context: "日期格式化".to_string(),
///     detail: "时间戳超出范围".to_string(),
/// };
/// assert!(err.to_string().contains("日期格式化"));
/// ```
#[derive(Debug, Error, Clone, PartialEq, Eq)]
pub enum RenderError {
    /// 格式化错误
    #[error("格式化错误 ({context}): {detail}")]
    FormatError {
        /// 错误上下文
        context: String,
        /// 错误详情
        detail: String,
    },

    /// 编码错误
    #[error("编码错误: 路径包含无效 UTF-8 字符")]
    InvalidUtf8Path {
        /// 问题路径（尽可能转换）
        path_lossy: String,
    },

    /// Windows 样板信息获取失败
    #[error("获取 Windows tree 样板信息失败: {reason}")]
    BannerFetchFailed {
        /// 失败原因
        reason: String,
    },
}

// ============================================================================
// 输出错误
// ============================================================================

/// 输出错误
///
/// 表示结果输出过程中的错误，包括文件写入和序列化。
///
/// # Examples
///
/// ```
/// use std::path::PathBuf;
/// use treepp::error::OutputError;
///
/// let err = OutputError::SerializationFailed {
///     format: "JSON".to_string(),
///     reason: "循环引用".to_string(),
/// };
/// assert!(err.to_string().contains("JSON"));
/// ```
#[derive(Debug, Error)]
pub enum OutputError {
    /// 文件创建失败
    #[error("无法创建输出文件: {path}")]
    FileCreateFailed {
        /// 目标文件路径
        path: PathBuf,
        /// 底层 IO 错误
        #[source]
        source: io::Error,
    },

    /// 文件写入失败
    #[error("写入文件失败: {path}")]
    WriteFailed {
        /// 目标文件路径
        path: PathBuf,
        /// 底层 IO 错误
        #[source]
        source: io::Error,
    },

    /// 序列化失败
    #[error("{format} 序列化失败: {reason}")]
    SerializationFailed {
        /// 输出格式名称
        format: String,
        /// 失败原因
        reason: String,
    },

    /// 标准输出写入失败
    #[error("写入标准输出失败")]
    StdoutFailed {
        /// 底层 IO 错误
        #[source]
        source: io::Error,
    },

    /// 输出路径无效
    #[error("输出路径无效: {path} ({reason})")]
    InvalidOutputPath {
        /// 输出路径
        path: PathBuf,
        /// 原因
        reason: String,
    },
}

impl OutputError {
    /// 创建 JSON 序列化错误
    #[must_use]
    pub fn json_error(reason: impl Into<String>) -> Self {
        Self::SerializationFailed {
            format: "JSON".to_string(),
            reason: reason.into(),
        }
    }

    /// 创建 YAML 序列化错误
    #[must_use]
    pub fn yaml_error(reason: impl Into<String>) -> Self {
        Self::SerializationFailed {
            format: "YAML".to_string(),
            reason: reason.into(),
        }
    }

    /// 创建 TOML 序列化错误
    #[must_use]
    pub fn toml_error(reason: impl Into<String>) -> Self {
        Self::SerializationFailed {
            format: "TOML".to_string(),
            reason: reason.into(),
        }
    }
}

// ============================================================================
// 便捷转换实现
// ============================================================================

impl From<io::Error> for OutputError {
    fn from(err: io::Error) -> Self {
        Self::StdoutFailed { source: err }
    }
}

impl From<walkdir::Error> for ScanError {
    fn from(err: walkdir::Error) -> Self {
        let path = err.path().map(PathBuf::from);
        if let Some(io_err) = err.io_error() {
            match io_err.kind() {
                io::ErrorKind::PermissionDenied => {
                    if let Some(p) = path {
                        return Self::PermissionDenied { path: p };
                    }
                }
                io::ErrorKind::NotFound => {
                    if let Some(p) = path {
                        return Self::PathNotFound { path: p };
                    }
                }
                _ => {}
            }
        }
        Self::WalkError {
            message: err.to_string(),
            path,
        }
    }
}

impl From<glob::PatternError> for MatchError {
    fn from(err: glob::PatternError) -> Self {
        Self::InvalidPattern {
            pattern: err.msg.to_string(),
            reason: format!("位置 {}", err.pos),
        }
    }
}

impl From<ignore::Error> for MatchError {
    fn from(err: ignore::Error) -> Self {
        Self::GitignoreBuildError {
            reason: err.to_string(),
        }
    }
}

// ============================================================================
// 辅助函数
// ============================================================================

/// 将路径转换为可显示字符串
///
/// 处理可能包含无效 UTF-8 的路径，使用有损转换确保总能输出。
///
/// # Examples
///
/// ```
/// use std::path::Path;
/// use treepp::error::path_display;
///
/// let path = Path::new("C:\\Users\\test");
/// assert_eq!(path_display(path), "C:\\Users\\test");
/// ```
#[must_use]
pub fn path_display(path: &std::path::Path) -> String {
    path.to_string_lossy().into_owned()
}

/// 判断错误是否可恢复（可继续处理其他项）
///
/// 某些扫描错误（如单个文件权限不足）不应中断整个遍历。
///
/// # Examples
///
/// ```
/// use std::path::PathBuf;
/// use treepp::error::{ScanError, is_recoverable};
///
/// let err = ScanError::PermissionDenied {
///     path: PathBuf::from("/protected"),
/// };
/// assert!(is_recoverable(&err));
///
/// let err = ScanError::PathNotFound {
///     path: PathBuf::from("/root"),
/// };
/// // 根路径不存在通常不可恢复，但此函数仅判断错误类型
/// assert!(is_recoverable(&err));
/// ```
#[must_use]
pub const fn is_recoverable(err: &ScanError) -> bool {
    matches!(
        err,
        ScanError::PermissionDenied { .. }
            | ScanError::MetadataFailed { .. }
            | ScanError::PathNotFound { .. }
    )
}

// ============================================================================
// 单元测试
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::ErrorKind;

    // ------------------------------------------------------------------------
    // TreeppError 转换测试
    // ------------------------------------------------------------------------

    #[test]
    fn should_convert_cli_error_to_treepp_error() {
        let cli_err = CliError::UnknownOption {
            option: "/X".to_string(),
        };
        let treepp_err: TreeppError = cli_err.into();

        assert!(matches!(treepp_err, TreeppError::Cli(_)));
        assert!(treepp_err.to_string().contains("/X"));
    }

    #[test]
    fn should_convert_scan_error_to_treepp_error() {
        let scan_err = ScanError::PathNotFound {
            path: PathBuf::from("/missing"),
        };
        let treepp_err: TreeppError = scan_err.into();

        assert!(matches!(treepp_err, TreeppError::Scan(_)));
    }

    #[test]
    fn should_convert_match_error_to_treepp_error() {
        let match_err = MatchError::InvalidPattern {
            pattern: "[bad".to_string(),
            reason: "unclosed".to_string(),
        };
        let treepp_err: TreeppError = match_err.into();

        assert!(matches!(treepp_err, TreeppError::Match(_)));
    }

    #[test]
    fn should_convert_output_error_to_treepp_error() {
        let output_err = OutputError::SerializationFailed {
            format: "JSON".to_string(),
            reason: "test".to_string(),
        };
        let treepp_err: TreeppError = output_err.into();

        assert!(matches!(treepp_err, TreeppError::Output(_)));
    }

    // ------------------------------------------------------------------------
    // CliError 测试
    // ------------------------------------------------------------------------

    #[test]
    fn should_format_unknown_option_error() {
        let err = CliError::UnknownOption {
            option: "--unknown".to_string(),
        };
        assert!(err.to_string().contains("--unknown"));
        assert!(err.to_string().contains("未知选项"));
    }

    #[test]
    fn should_format_missing_value_error() {
        let err = CliError::MissingValue {
            option: "--level".to_string(),
        };
        assert!(err.to_string().contains("--level"));
        assert!(err.to_string().contains("需要一个参数值"));
    }

    #[test]
    fn should_format_invalid_value_error() {
        let err = CliError::InvalidValue {
            option: "--thread".to_string(),
            value: "abc".to_string(),
            reason: "必须是正整数".to_string(),
        };
        let msg = err.to_string();
        assert!(msg.contains("--thread"));
        assert!(msg.contains("abc"));
        assert!(msg.contains("必须是正整数"));
    }

    #[test]
    fn should_compare_cli_errors_for_equality() {
        let err1 = CliError::UnknownOption {
            option: "/Z".to_string(),
        };
        let err2 = CliError::UnknownOption {
            option: "/Z".to_string(),
        };
        let err3 = CliError::UnknownOption {
            option: "/Y".to_string(),
        };

        assert_eq!(err1, err2);
        assert_ne!(err1, err3);
    }

    // ------------------------------------------------------------------------
    // ScanError 测试
    // ------------------------------------------------------------------------

    #[test]
    fn should_create_scan_error_from_io_not_found() {
        let io_err = io::Error::new(ErrorKind::NotFound, "file not found");
        let path = PathBuf::from("/test/path");
        let scan_err = ScanError::from_io_error(io_err, path.clone());

        assert!(matches!(scan_err, ScanError::PathNotFound { path: p } if p == path));
    }

    #[test]
    fn should_create_scan_error_from_io_permission_denied() {
        let io_err = io::Error::new(ErrorKind::PermissionDenied, "access denied");
        let path = PathBuf::from("/protected");
        let scan_err = ScanError::from_io_error(io_err, path.clone());

        assert!(matches!(scan_err, ScanError::PermissionDenied { path: p } if p == path));
    }

    #[test]
    fn should_create_scan_error_from_io_other() {
        let io_err = io::Error::new(ErrorKind::Other, "some error");
        let path = PathBuf::from("/some/path");
        let scan_err = ScanError::from_io_error(io_err, path.clone());

        assert!(matches!(scan_err, ScanError::ReadDirFailed { path: p, .. } if p == path));
    }

    #[test]
    fn should_format_path_not_found_error() {
        let err = ScanError::PathNotFound {
            path: PathBuf::from("C:\\missing\\dir"),
        };
        let msg = err.to_string();
        assert!(msg.contains("路径不存在"));
        assert!(msg.contains("C:\\missing\\dir"));
    }

    #[test]
    fn should_format_permission_denied_error() {
        let err = ScanError::PermissionDenied {
            path: PathBuf::from("/root/secret"),
        };
        let msg = err.to_string();
        assert!(msg.contains("权限不足"));
    }

    // ------------------------------------------------------------------------
    // MatchError 测试
    // ------------------------------------------------------------------------

    #[test]
    fn should_create_match_error_from_glob_error() {
        let err = MatchError::from_glob_error("[invalid", "未闭合的括号");

        match err {
            MatchError::InvalidPattern { pattern, reason } => {
                assert_eq!(pattern, "[invalid");
                assert!(reason.contains("未闭合的括号"));
            }
            _ => panic!("期望 InvalidPattern 变体"),
        }
    }

    #[test]
    fn should_format_invalid_pattern_error() {
        let err = MatchError::InvalidPattern {
            pattern: "**[".to_string(),
            reason: "语法错误".to_string(),
        };
        let msg = err.to_string();
        assert!(msg.contains("**["));
        assert!(msg.contains("无效的匹配模式"));
    }

    #[test]
    fn should_format_gitignore_parse_error() {
        let err = MatchError::GitignoreParseError {
            path: PathBuf::from(".gitignore"),
            detail: "第 5 行语法错误".to_string(),
        };
        let msg = err.to_string();
        assert!(msg.contains(".gitignore"));
    }

    #[test]
    fn should_compare_match_errors_for_equality() {
        let err1 = MatchError::InvalidPattern {
            pattern: "*.txt".to_string(),
            reason: "test".to_string(),
        };
        let err2 = MatchError::InvalidPattern {
            pattern: "*.txt".to_string(),
            reason: "test".to_string(),
        };
        assert_eq!(err1, err2);
    }

    // ------------------------------------------------------------------------
    // RenderError 测试
    // ------------------------------------------------------------------------

    #[test]
    fn should_format_render_format_error() {
        let err = RenderError::FormatError {
            context: "大小格式化".to_string(),
            detail: "数值溢出".to_string(),
        };
        let msg = err.to_string();
        assert!(msg.contains("大小格式化"));
        assert!(msg.contains("数值溢出"));
    }

    #[test]
    fn should_format_invalid_utf8_path_error() {
        let err = RenderError::InvalidUtf8Path {
            path_lossy: "some\u{FFFD}path".to_string(),
        };
        let msg = err.to_string();
        assert!(msg.contains("无效 UTF-8"));
    }

    // ------------------------------------------------------------------------
    // OutputError 测试
    // ------------------------------------------------------------------------

    #[test]
    fn should_create_json_error() {
        let err = OutputError::json_error("无效结构");
        match err {
            OutputError::SerializationFailed { format, reason } => {
                assert_eq!(format, "JSON");
                assert!(reason.contains("无效结构"));
            }
            _ => panic!("期望 SerializationFailed 变体"),
        }
    }

    #[test]
    fn should_create_yaml_error() {
        let err = OutputError::yaml_error("缩进错误");
        match err {
            OutputError::SerializationFailed { format, reason } => {
                assert_eq!(format, "YAML");
                assert!(reason.contains("缩进错误"));
            }
            _ => panic!("期望 SerializationFailed 变体"),
        }
    }

    #[test]
    fn should_create_toml_error() {
        let err = OutputError::toml_error("键值对错误");
        match err {
            OutputError::SerializationFailed { format, reason } => {
                assert_eq!(format, "TOML");
                assert!(reason.contains("键值对错误"));
            }
            _ => panic!("期望 SerializationFailed 变体"),
        }
    }

    #[test]
    fn should_convert_io_error_to_output_error() {
        let io_err = io::Error::new(ErrorKind::BrokenPipe, "pipe broken");
        let output_err: OutputError = io_err.into();

        assert!(matches!(output_err, OutputError::StdoutFailed { .. }));
    }

    #[test]
    fn should_format_file_create_failed_error() {
        let err = OutputError::FileCreateFailed {
            path: PathBuf::from("output.json"),
            source: io::Error::new(ErrorKind::PermissionDenied, "denied"),
        };
        let msg = err.to_string();
        assert!(msg.contains("output.json"));
        assert!(msg.contains("无法创建"));
    }

    // ------------------------------------------------------------------------
    // 辅助函数测试
    // ------------------------------------------------------------------------

    #[test]
    fn should_display_path_correctly() {
        let path = std::path::Path::new("C:\\Users\\test\\file.txt");
        let display = path_display(path);
        assert!(display.contains("test"));
        assert!(display.contains("file.txt"));
    }

    #[test]
    fn should_identify_recoverable_permission_denied() {
        let err = ScanError::PermissionDenied {
            path: PathBuf::from("/test"),
        };
        assert!(is_recoverable(&err));
    }

    #[test]
    fn should_identify_recoverable_metadata_failed() {
        let err = ScanError::MetadataFailed {
            path: PathBuf::from("/test"),
            source: io::Error::new(ErrorKind::Other, "test"),
        };
        assert!(is_recoverable(&err));
    }

    #[test]
    fn should_identify_recoverable_path_not_found() {
        let err = ScanError::PathNotFound {
            path: PathBuf::from("/test"),
        };
        assert!(is_recoverable(&err));
    }

    #[test]
    fn should_not_identify_not_a_directory_as_recoverable() {
        let err = ScanError::NotADirectory {
            path: PathBuf::from("/test"),
        };
        assert!(!is_recoverable(&err));
    }

    #[test]
    fn should_not_identify_walk_error_as_recoverable() {
        let err = ScanError::WalkError {
            message: "test error".to_string(),
            path: None,
        };
        assert!(!is_recoverable(&err));
    }

    // ------------------------------------------------------------------------
    // 错误链测试
    // ------------------------------------------------------------------------

    #[test]
    fn should_preserve_source_in_read_dir_failed() {
        let io_err = io::Error::new(ErrorKind::Other, "underlying error");
        let err = ScanError::ReadDirFailed {
            path: PathBuf::from("/test"),
            source: io_err,
        };

        // 验证 source 可访问
        let source = std::error::Error::source(&err);
        assert!(source.is_some());
    }

    #[test]
    fn should_preserve_source_in_file_create_failed() {
        let io_err = io::Error::new(ErrorKind::PermissionDenied, "no permission");
        let err = OutputError::FileCreateFailed {
            path: PathBuf::from("test.txt"),
            source: io_err,
        };

        let source = std::error::Error::source(&err);
        assert!(source.is_some());
    }
}
```

output.rs:  

```rust

//! 输出模块：多格式输出与文件写入
//!
//! 本模块负责将渲染结果输出到不同目标，支持：
//!
//! - **输出策略**：stdout、写文件、silent（仅写文件不写 stdout）
//! - **多格式输出**：txt/json/yml/toml（序列化 schema 固定）
//! - **文件写入策略**：覆盖写入，确保原子性
//!
//! 作者: WaterRun
//! 更新于: 2025-01-06

#![forbid(unsafe_code)]

use std::fs::{self, File};
use std::io::{self, BufWriter, Write};
use std::path::Path;

use serde::Serialize;

use crate::config::{Config, OutputFormat};
use crate::error::OutputError;
use crate::render::RenderResult;
use crate::scan::{EntryKind, TreeNode};

// ============================================================================
// 序列化结构
// ============================================================================

/// 可序列化的树节点
///
/// 用于 JSON/YAML/TOML 格式输出的节点结构。
/// 根据配置选项决定哪些字段被序列化。
#[derive(Debug, Clone, Serialize)]
struct SerializableNode {
    /// 条目名称
    name: String,

    /// 完整路径（仅在 full_path 模式下）
    #[serde(skip_serializing_if = "Option::is_none")]
    full_path: Option<String>,

    /// 文件大小（仅对文件且启用 show_size）
    #[serde(skip_serializing_if = "Option::is_none")]
    size: Option<u64>,

    /// 目录累计大小（仅对目录且启用 disk_usage）
    #[serde(skip_serializing_if = "Option::is_none")]
    disk_usage: Option<u64>,

    /// 修改时间（仅在启用 show_date）
    #[serde(skip_serializing_if = "Option::is_none")]
    modified: Option<String>,

    /// 是否为目录
    is_dir: bool,

    /// 子节点
    #[serde(skip_serializing_if = "Vec::is_empty")]
    children: Vec<SerializableNode>,
}

/// TOML 根结构
///
/// TOML 格式需要顶层表结构，因此包装树节点。
#[derive(Debug, Serialize)]
struct TomlRoot {
    /// 树节点
    tree: SerializableNode,
}

// ============================================================================
// 节点转换
// ============================================================================

/// 将 TreeNode 转换为可序列化节点
///
/// 根据配置过滤和转换节点数据。
///
/// # 参数
///
/// * `node` - 源树节点
/// * `config` - 输出配置
///
/// # 返回值
///
/// 返回可序列化的节点结构。
fn to_serializable(node: &TreeNode, config: &Config) -> SerializableNode {
    let children: Vec<SerializableNode> = node
        .children
        .iter()
        .filter(|c| config.scan.show_files || c.kind == EntryKind::Directory)
        .filter(|c| {
            !config.matching.prune_empty || c.kind != EntryKind::Directory || !c.is_empty_dir()
        })
        .map(|c| to_serializable(c, config))
        .collect();

    let is_file = node.kind == EntryKind::File;
    let is_dir = node.kind == EntryKind::Directory;

    SerializableNode {
        name: node.name.clone(),
        full_path: if config.render.path_mode == crate::config::PathMode::Full {
            Some(node.path.to_string_lossy().into_owned())
        } else {
            None
        },
        size: if config.render.show_size && is_file {
            Some(node.metadata.size)
        } else {
            None
        },
        disk_usage: if config.render.show_disk_usage && is_dir {
            node.disk_usage
        } else {
            None
        },
        modified: if config.render.show_date {
            node.metadata
                .modified
                .as_ref()
                .map(crate::render::format_datetime)
        } else {
            None
        },
        is_dir,
        children,
    }
}

// ============================================================================
// 格式化输出
// ============================================================================

/// 序列化为 JSON 格式
///
/// # 参数
///
/// * `node` - 树节点
/// * `config` - 输出配置
///
/// # 返回值
///
/// 成功返回 JSON 字符串，失败返回错误。
///
/// # Errors
///
/// 返回 `OutputError::SerializationFailed` 如果序列化失败。
///
/// # Examples
///
/// ```no_run
/// use std::path::PathBuf;
/// use treepp::config::Config;
/// use treepp::scan::{TreeNode, EntryKind, EntryMetadata};
/// use treepp::output::serialize_json;
///
/// let node = TreeNode::new(PathBuf::from("."), EntryKind::Directory, EntryMetadata::default());
/// let config = Config::default();
/// let json = serialize_json(&node, &config).unwrap();
/// assert!(json.contains("\"name\""));
/// ```
pub fn serialize_json(node: &TreeNode, config: &Config) -> Result<String, OutputError> {
    let serializable = to_serializable(node, config);
    serde_json::to_string_pretty(&serializable).map_err(|e| OutputError::json_error(e.to_string()))
}

/// 序列化为 YAML 格式
///
/// # 参数
///
/// * `node` - 树节点
/// * `config` - 输出配置
///
/// # 返回值
///
/// 成功返回 YAML 字符串，失败返回错误。
///
/// # Errors
///
/// 返回 `OutputError::SerializationFailed` 如果序列化失败。
///
/// # Examples
///
/// ```no_run
/// use std::path::PathBuf;
/// use treepp::config::Config;
/// use treepp::scan::{TreeNode, EntryKind, EntryMetadata};
/// use treepp::output::serialize_yaml;
///
/// let node = TreeNode::new(PathBuf::from("."), EntryKind::Directory, EntryMetadata::default());
/// let config = Config::default();
/// let yaml = serialize_yaml(&node, &config).unwrap();
/// assert!(yaml.contains("name:"));
/// ```
pub fn serialize_yaml(node: &TreeNode, config: &Config) -> Result<String, OutputError> {
    let serializable = to_serializable(node, config);
    serde_yaml::to_string(&serializable).map_err(|e| OutputError::yaml_error(e.to_string()))
}

/// 序列化为 TOML 格式
///
/// # 参数
///
/// * `node` - 树节点
/// * `config` - 输出配置
///
/// # 返回值
///
/// 成功返回 TOML 字符串，失败返回错误。
///
/// # Errors
///
/// 返回 `OutputError::SerializationFailed` 如果序列化失败。
///
/// # Examples
///
/// ```no_run
/// use std::path::PathBuf;
/// use treepp::config::Config;
/// use treepp::scan::{TreeNode, EntryKind, EntryMetadata};
/// use treepp::output::serialize_toml;
///
/// let node = TreeNode::new(PathBuf::from("."), EntryKind::Directory, EntryMetadata::default());
/// let config = Config::default();
/// let toml = serialize_toml(&node, &config).unwrap();
/// assert!(toml.contains("[tree]"));
/// ```
pub fn serialize_toml(node: &TreeNode, config: &Config) -> Result<String, OutputError> {
    let serializable = to_serializable(node, config);
    let root = TomlRoot { tree: serializable };
    toml::to_string_pretty(&root).map_err(|e| OutputError::toml_error(e.to_string()))
}

// ============================================================================
// 输出目标
// ============================================================================

/// 输出到标准输出
///
/// 如果配置了静默模式则不输出。
///
/// # 参数
///
/// * `content` - 输出内容
/// * `config` - 输出配置
///
/// # Errors
///
/// 返回 `OutputError::StdoutFailed` 如果写入失败。
///
/// # Examples
///
/// ```no_run
/// use treepp::config::Config;
/// use treepp::output::write_stdout;
///
/// let config = Config::default();
/// write_stdout("Hello, World!\n", &config).unwrap();
/// ```
pub fn write_stdout(content: &str, config: &Config) -> Result<(), OutputError> {
    if config.output.silent {
        return Ok(());
    }

    let stdout = io::stdout();
    let mut handle = stdout.lock();
    handle.write_all(content.as_bytes())?;
    handle.flush()?;
    Ok(())
}

/// 写入文件
///
/// 使用覆盖写入策略，确保文件内容完整写入。
///
/// # 参数
///
/// * `content` - 输出内容
/// * `path` - 目标文件路径
///
/// # Errors
///
/// 返回 `OutputError` 如果：
/// - 无法创建文件
/// - 写入失败
///
/// # Examples
///
/// ```no_run
/// use std::path::Path;
/// use treepp::output::write_file;
///
/// write_file("content", Path::new("output.txt")).unwrap();
/// ```
pub fn write_file(content: &str, path: &Path) -> Result<(), OutputError> {
    // 确保父目录存在
    if let Some(parent) = path.parent() {
        if !parent.as_os_str().is_empty() && !parent.exists() {
            fs::create_dir_all(parent).map_err(|e| OutputError::FileCreateFailed {
                path: path.to_path_buf(),
                source: e,
            })?;
        }
    }

    // 创建文件并写入
    let file = File::create(path).map_err(|e| OutputError::FileCreateFailed {
        path: path.to_path_buf(),
        source: e,
    })?;

    let mut writer = BufWriter::new(file);
    writer
        .write_all(content.as_bytes())
        .map_err(|e| OutputError::WriteFailed {
            path: path.to_path_buf(),
            source: e,
        })?;

    writer.flush().map_err(|e| OutputError::WriteFailed {
        path: path.to_path_buf(),
        source: e,
    })?;

    Ok(())
}

/// 输出文件写入提示信息
///
/// 在非静默模式下，向标准输出打印文件写入提示。
///
/// # 参数
///
/// * `path` - 输出文件路径
/// * `config` - 输出配置
///
/// # Errors
///
/// 返回 `OutputError::StdoutFailed` 如果写入失败。
///
/// # Examples
///
/// ```no_run
/// use std::path::Path;
/// use treepp::config::Config;
/// use treepp::output::print_file_notice;
///
/// let config = Config::default();
/// print_file_notice(Path::new("tree.json"), &config).unwrap();
/// ```
pub fn print_file_notice(path: &Path, config: &Config) -> Result<(), OutputError> {
    if config.output.silent {
        return Ok(());
    }

    let notice = format!("\noutput: {}\n", path.display());
    let stdout = io::stdout();
    let mut handle = stdout.lock();
    handle.write_all(notice.as_bytes())?;
    handle.flush()?;
    Ok(())
}

// ============================================================================
// 统一输出接口
// ============================================================================

/// 执行输出操作
///
/// 根据配置执行完整的输出流程：
/// 1. 根据格式选择渲染文本或序列化结构
/// 2. 输出到 stdout（除非静默）
/// 3. 写入文件（如果配置了输出路径）
/// 4. 打印文件写入提示（如果写入了文件且非静默）
///
/// # 参数
///
/// * `render_result` - 渲染结果（用于 TXT 格式）
/// * `tree` - 树节点（用于结构化格式）
/// * `config` - 完整配置
///
/// # 返回值
///
/// 成功返回 `()`，失败返回 `OutputError`。
///
/// # Errors
///
/// 返回 `OutputError` 如果：
/// - 序列化失败
/// - 文件写入失败
/// - 标准输出写入失败
///
/// # Examples
///
/// ```no_run
/// use std::path::PathBuf;
/// use treepp::config::Config;
/// use treepp::scan::scan;
/// use treepp::render::render;
/// use treepp::output::execute_output;
///
/// let config = Config::with_root(PathBuf::from(".")).validate().unwrap();
/// let stats = scan(&config).expect("扫描失败");
/// let result = render(&stats, &config);
/// execute_output(&result, &stats.tree, &config).expect("输出失败");
/// ```
pub fn execute_output(
    render_result: &RenderResult,
    tree: &TreeNode,
    config: &Config,
) -> Result<(), OutputError> {
    // 根据格式生成输出内容
    let content = match config.output.format {
        OutputFormat::Txt => render_result.content.clone(),
        OutputFormat::Json => serialize_json(tree, config)?,
        OutputFormat::Yaml => serialize_yaml(tree, config)?,
        OutputFormat::Toml => serialize_toml(tree, config)?,
    };

    // 输出到 stdout
    write_stdout(&content, config)?;

    // 写入文件（如果配置了输出路径）
    if let Some(ref output_path) = config.output.output_path {
        write_file(&content, output_path)?;
        print_file_notice(output_path, config)?;
    }

    Ok(())
}

/// 仅输出到文件（跳过 stdout）
///
/// 用于明确需要跳过标准输出的场景。
///
/// # 参数
///
/// * `render_result` - 渲染结果（用于 TXT 格式）
/// * `tree` - 树节点（用于结构化格式）
/// * `config` - 完整配置
/// * `path` - 输出文件路径
///
/// # Errors
///
/// 返回 `OutputError` 如果序列化或写入失败。
///
/// # Examples
///
/// ```no_run
/// use std::path::PathBuf;
/// use treepp::config::Config;
/// use treepp::scan::scan;
/// use treepp::render::render;
/// use treepp::output::write_to_file_only;
///
/// let config = Config::with_root(PathBuf::from(".")).validate().unwrap();
/// let stats = scan(&config).expect("扫描失败");
/// let result = render(&stats, &config);
/// write_to_file_only(&result, &stats.tree, &config, &PathBuf::from("tree.txt")).unwrap();
/// ```
pub fn write_to_file_only(
    render_result: &RenderResult,
    tree: &TreeNode,
    config: &Config,
    path: &Path,
) -> Result<(), OutputError> {
    let content = match config.output.format {
        OutputFormat::Txt => render_result.content.clone(),
        OutputFormat::Json => serialize_json(tree, config)?,
        OutputFormat::Yaml => serialize_yaml(tree, config)?,
        OutputFormat::Toml => serialize_toml(tree, config)?,
    };

    write_file(&content, path)
}

// ============================================================================
// 辅助函数
// ============================================================================

/// 从文件路径推断输出格式
///
/// # 参数
///
/// * `path` - 文件路径
///
/// # 返回值
///
/// 返回 `Some(OutputFormat)` 如果能识别扩展名，否则返回 `None`。
///
/// # Examples
///
/// ```
/// use std::path::Path;
/// use treepp::config::OutputFormat;
/// use treepp::output::infer_format;
///
/// assert_eq!(infer_format(Path::new("tree.json")), Some(OutputFormat::Json));
/// assert_eq!(infer_format(Path::new("tree.yml")), Some(OutputFormat::Yaml));
/// assert_eq!(infer_format(Path::new("tree.yaml")), Some(OutputFormat::Yaml));
/// assert_eq!(infer_format(Path::new("tree.toml")), Some(OutputFormat::Toml));
/// assert_eq!(infer_format(Path::new("tree.txt")), Some(OutputFormat::Txt));
/// assert_eq!(infer_format(Path::new("tree.unknown")), None);
/// ```
#[must_use]
pub fn infer_format(path: &Path) -> Option<OutputFormat> {
    OutputFormat::from_extension(path)
}

/// 验证输出路径有效性
///
/// 检查输出路径是否可写入。
///
/// # 参数
///
/// * `path` - 输出文件路径
///
/// # 返回值
///
/// 成功返回 `Ok(())`，失败返回错误原因。
///
/// # Errors
///
/// 返回 `OutputError::InvalidOutputPath` 如果：
/// - 路径指向已存在的目录
/// - 父目录不可访问
///
/// # Examples
///
/// ```
/// use std::path::Path;
/// use treepp::output::validate_output_path;
///
/// // 正常路径
/// assert!(validate_output_path(Path::new("output.txt")).is_ok());
///
/// // 相对路径也可以
/// assert!(validate_output_path(Path::new("subdir/output.txt")).is_ok());
/// ```
pub fn validate_output_path(path: &Path) -> Result<(), OutputError> {
    // 检查是否为已存在的目录
    if path.exists() && path.is_dir() {
        return Err(OutputError::InvalidOutputPath {
            path: path.to_path_buf(),
            reason: "路径指向已存在的目录，需要指定文件名".to_string(),
        });
    }

    // 检查父目录
    if let Some(parent) = path.parent() {
        if !parent.as_os_str().is_empty() && parent.exists() && !parent.is_dir() {
            return Err(OutputError::InvalidOutputPath {
                path: path.to_path_buf(),
                reason: "父路径不是目录".to_string(),
            });
        }
    }

    Ok(())
}

// ============================================================================
// 单元测试
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;
    use crate::scan::EntryMetadata;
    use std::path::PathBuf;
    use tempfile::tempdir;

    /// 创建测试用的树节点
    fn create_test_tree() -> TreeNode {
        let mut root = TreeNode::new(
            PathBuf::from("test_root"),
            EntryKind::Directory,
            EntryMetadata::default(),
        );

        root.children.push(TreeNode::new(
            PathBuf::from("test_root/file1.txt"),
            EntryKind::File,
            EntryMetadata {
                size: 1024,
                ..Default::default()
            },
        ));

        let mut subdir = TreeNode::new(
            PathBuf::from("test_root/subdir"),
            EntryKind::Directory,
            EntryMetadata::default(),
        );
        subdir.children.push(TreeNode::new(
            PathBuf::from("test_root/subdir/file2.txt"),
            EntryKind::File,
            EntryMetadata {
                size: 2048,
                ..Default::default()
            },
        ));
        root.children.push(subdir);

        root
    }

    #[test]
    fn test_serialize_json_basic() {
        let tree = create_test_tree();
        let config = Config::default();

        let json = serialize_json(&tree, &config).expect("JSON 序列化应成功");

        assert!(json.contains("\"name\":"));
        assert!(json.contains("\"is_dir\":"));
        assert!(json.contains("test_root"));
    }

    #[test]
    fn test_serialize_json_with_files() {
        let tree = create_test_tree();
        let mut config = Config::default();
        config.scan.show_files = true;
        config.render.show_size = true;

        let json = serialize_json(&tree, &config).expect("JSON 序列化应成功");

        assert!(json.contains("file1.txt"));
        assert!(json.contains("\"size\":"));
        assert!(json.contains("1024"));
    }

    #[test]
    fn test_serialize_yaml_basic() {
        let tree = create_test_tree();
        let config = Config::default();

        let yaml = serialize_yaml(&tree, &config).expect("YAML 序列化应成功");

        assert!(yaml.contains("name:"));
        assert!(yaml.contains("is_dir:"));
    }

    #[test]
    fn test_serialize_toml_basic() {
        let tree = create_test_tree();
        let config = Config::default();

        let toml = serialize_toml(&tree, &config).expect("TOML 序列化应成功");

        assert!(toml.contains("[tree]"));
        assert!(toml.contains("name ="));
    }

    #[test]
    fn test_infer_format_json() {
        assert_eq!(
            infer_format(Path::new("output.json")),
            Some(OutputFormat::Json)
        );
        assert_eq!(
            infer_format(Path::new("OUTPUT.JSON")),
            Some(OutputFormat::Json)
        );
    }

    #[test]
    fn test_infer_format_yaml() {
        assert_eq!(
            infer_format(Path::new("output.yaml")),
            Some(OutputFormat::Yaml)
        );
        assert_eq!(
            infer_format(Path::new("output.yml")),
            Some(OutputFormat::Yaml)
        );
    }

    #[test]
    fn test_infer_format_toml() {
        assert_eq!(
            infer_format(Path::new("output.toml")),
            Some(OutputFormat::Toml)
        );
    }

    #[test]
    fn test_infer_format_txt() {
        assert_eq!(
            infer_format(Path::new("output.txt")),
            Some(OutputFormat::Txt)
        );
    }

    #[test]
    fn test_infer_format_unknown() {
        assert_eq!(infer_format(Path::new("output.xyz")), None);
        assert_eq!(infer_format(Path::new("output")), None);
    }

    #[test]
    fn test_write_file_creates_file() {
        let dir = tempdir().expect("创建临时目录失败");
        let file_path = dir.path().join("test_output.txt");

        write_file("test content", &file_path).expect("写入文件应成功");

        assert!(file_path.exists());
        let content = fs::read_to_string(&file_path).expect("读取文件失败");
        assert_eq!(content, "test content");
    }

    #[test]
    fn test_write_file_creates_parent_dirs() {
        let dir = tempdir().expect("创建临时目录失败");
        let file_path = dir.path().join("subdir1/subdir2/test.txt");

        write_file("nested content", &file_path).expect("写入嵌套文件应成功");

        assert!(file_path.exists());
    }

    #[test]
    fn test_write_file_overwrites() {
        let dir = tempdir().expect("创建临时目录失败");
        let file_path = dir.path().join("overwrite.txt");

        write_file("first content", &file_path).expect("首次写入应成功");
        write_file("second content", &file_path).expect("覆盖写入应成功");

        let content = fs::read_to_string(&file_path).expect("读取文件失败");
        assert_eq!(content, "second content");
    }

    #[test]
    fn test_validate_output_path_normal() {
        assert!(validate_output_path(Path::new("output.txt")).is_ok());
        assert!(validate_output_path(Path::new("subdir/output.txt")).is_ok());
    }

    #[test]
    fn test_validate_output_path_existing_dir() {
        let dir = tempdir().expect("创建临时目录失败");

        let result = validate_output_path(dir.path());
        assert!(result.is_err());

        if let Err(OutputError::InvalidOutputPath { reason, .. }) = result {
            assert!(reason.contains("目录"));
        }
    }

    #[test]
    fn test_write_stdout_silent_mode() {
        let mut config = Config::default();
        config.output.silent = true;

        // 静默模式下不应报错（即使我们无法真正验证没有输出）
        let result = write_stdout("test", &config);
        assert!(result.is_ok());
    }

    #[test]
    fn test_to_serializable_filters_files_when_not_shown() {
        let tree = create_test_tree();
        let config = Config::default(); // show_files = false

        let serializable = to_serializable(&tree, &config);

        // 根节点的直接子节点应只包含目录
        for child in &serializable.children {
            assert!(child.is_dir, "应只包含目录，但发现文件: {}", child.name);
        }
    }

    #[test]
    fn test_to_serializable_includes_files_when_shown() {
        let tree = create_test_tree();
        let mut config = Config::default();
        config.scan.show_files = true;

        let serializable = to_serializable(&tree, &config);

        let has_file = serializable.children.iter().any(|c| !c.is_dir);
        assert!(has_file, "应包含文件");
    }

    #[test]
    fn test_to_serializable_size_only_when_enabled() {
        let tree = create_test_tree();
        let mut config = Config::default();
        config.scan.show_files = true;
        config.render.show_size = false;

        let serializable = to_serializable(&tree, &config);

        // 递归检查所有节点都没有 size
        fn check_no_size(node: &SerializableNode) {
            assert!(node.size.is_none(), "size 应为 None");
            for child in &node.children {
                check_no_size(child);
            }
        }
        check_no_size(&serializable);
    }

    #[test]
    fn test_to_serializable_with_size() {
        let tree = create_test_tree();
        let mut config = Config::default();
        config.scan.show_files = true;
        config.render.show_size = true;

        let serializable = to_serializable(&tree, &config);

        // 查找文件节点，检查是否有 size
        fn find_file_with_size(node: &SerializableNode) -> bool {
            if !node.is_dir && node.size.is_some() {
                return true;
            }
            node.children.iter().any(|c| find_file_with_size(c))
        }
        assert!(find_file_with_size(&serializable), "应有文件包含 size");
    }
}
```

render.rs:  

```rust
//! 渲染模块：将扫描 IR 渲染为文本树
//!
//! 本模块负责将 `scan` 模块产出的 `TreeNode` 渲染为可展示的文本格式，支持：
//!
//! - **树形风格**：ASCII (`/A`) 或 Unicode（默认）
//! - **无缩进模式**：仅使用空白缩进 (`/NI`)
//! - **路径显示**：相对名称（默认）或完整路径 (`/FP`)
//! - **元信息显示**：文件大小 (`/S`)、人类可读大小 (`/HR`)、修改日期 (`/DT`)、目录累计大小 (`/DU`)
//! - **统计报告**：末尾统计信息 (`/RP`)
//! - **Windows 样板**：默认显示系统卷信息，`/NB` 禁止
//!
//! 作者: WaterRun
//! 更新于: 2025-01-06

#![forbid(unsafe_code)]

use std::fmt::Write as FmtWrite;
use std::fs;
use std::path::Path;
use std::process::Command;
use std::sync::OnceLock;
use std::time::SystemTime;

use crate::config::{CharsetMode, Config, PathMode};
use crate::error::RenderError;
use crate::scan::{EntryKind, ScanStats, TreeNode};

// ============================================================================
// 常量
// ============================================================================

/// Windows tree++ 样板信息目录路径
const TREEPP_BANNER_DIR: &str = r"C:\__tree++__";

/// Windows tree++ 样板信息文件名
const TREEPP_BANNER_FILE: &str = "tree++.txt";

/// 样板文件内容提示
const TREEPP_BANNER_FILE_CONTENT: &str = r#"This directory is automatically created by tree++ to align with the native Windows tree command's banner (boilerplate) output.

You may safely delete this directory. If you do not want tree++ to create it, use the /NB option when running tree++.

GitHub: https://github.com/Water-Run/treepp
"#;

/// 全局缓存的 Windows 样板信息
static CACHED_BANNER: OnceLock<Result<WinBanner, String>> = OnceLock::new();

// ============================================================================
// Windows 样板信息
// ============================================================================

/// Windows tree 命令样板信息
///
/// 包含从 Windows 原生 tree 命令提取的样板信息。
/// 通过在 `C:\__tree++__` 目录执行 `tree` 命令获取系统本地化的样板文本。
///
/// # 输出格式
///
/// Windows `tree` 命令输出固定为 4 行：
/// ```text
/// 卷 系统 的文件夹 PATH 列表      <- 第1行: volume_line
/// 卷序列号为 2810-11C7            <- 第2行: serial_line
/// C:.                             <- 第3行: 当前目录（忽略）
/// 没有子文件夹                    <- 第4行: no_subfolder
/// ```
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct WinBanner {
    /// 卷信息行 (如 "卷 系统 的文件夹 PATH 列表")
    pub volume_line: String,
    /// 卷序列号行 (如 "卷序列号为 2810-11C7")
    pub serial_line: String,
    /// 无子文件夹提示 (如 "没有子文件夹")
    pub no_subfolder: String,
}

impl WinBanner {
    /// 获取 Windows 样板信息（带缓存）
    ///
    /// 首次调用时从系统获取，后续调用返回缓存结果。
    ///
    /// # Errors
    ///
    /// 返回 `RenderError::BannerFetchFailed` 如果：
    /// - 无法创建样板目录
    /// - 无法执行 tree 命令
    /// - tree 输出行数不足
    pub fn get_cached() -> Result<&'static WinBanner, RenderError> {
        CACHED_BANNER
            .get_or_init(|| Self::fetch_from_system().map_err(|e| e.to_string()))
            .as_ref()
            .map_err(|reason| RenderError::BannerFetchFailed {
                reason: reason.clone(),
            })
    }

    /// 直接从系统获取样板信息（不使用缓存）
    ///
    /// 此方法会执行以下操作：
    /// 1. 确保 `C:\__tree++__` 目录存在
    /// 2. 确保 `tree++.txt` 文件存在
    /// 3. 在该目录下执行 `tree` 命令（无参数）
    /// 4. 提取输出的第1行、第2行、最后一行
    pub fn fetch() -> Result<Self, RenderError> {
        Self::fetch_from_system()
    }

    /// 从 tree 命令获取样板信息的内部实现
    fn fetch_from_system() -> Result<Self, RenderError> {
        let dir_path = Path::new(TREEPP_BANNER_DIR);
        let file_path = dir_path.join(TREEPP_BANNER_FILE);

        // 确保目录存在
        if !dir_path.exists() {
            fs::create_dir_all(dir_path).map_err(|e| RenderError::BannerFetchFailed {
                reason: format!("无法创建目录 {}: {}", TREEPP_BANNER_DIR, e),
            })?;
        }

        // 确保样板文件存在（用于标识此目录用途）
        if !file_path.exists() {
            fs::write(&file_path, TREEPP_BANNER_FILE_CONTENT).map_err(|e| {
                RenderError::BannerFetchFailed {
                    reason: format!("无法创建文件 {}: {}", file_path.display(), e),
                }
            })?;
        }

        // 在 C:\__tree++__ 目录下执行 tree 命令（无参数）
        let output = Command::new("cmd")
            .args(["/C", "tree"])
            .current_dir(dir_path)
            .output()
            .map_err(|e| RenderError::BannerFetchFailed {
                reason: format!("执行 tree 命令失败: {}", e),
            })?;

        if !output.status.success() {
            return Err(RenderError::BannerFetchFailed {
                reason: format!("tree 命令返回错误码: {:?}", output.status.code()),
            });
        }

        // 解码 GBK 输出
        let stdout = Self::decode_system_output(&output.stdout)?;

        Self::parse_tree_output(&stdout)
    }

    /// 解码系统输出（处理 Windows GBK/CP936 编码）
    fn decode_system_output(bytes: &[u8]) -> Result<String, RenderError> {
        let (decoded, _, had_errors) = encoding_rs::GBK.decode(bytes);

        if had_errors {
            match std::str::from_utf8(bytes) {
                Ok(s) => Ok(s.to_string()),
                Err(_) => Ok(String::from_utf8_lossy(bytes).into_owned()),
            }
        } else {
            Ok(decoded.into_owned())
        }
    }

    /// 解析 tree 命令输出
    ///
    /// 直接提取第1行、第2行、最后一行，无需关键字匹配。
    fn parse_tree_output(output: &str) -> Result<Self, RenderError> {
        let lines: Vec<&str> = output.lines().collect();

        // tree 输出至少需要 4 行
        if lines.len() < 4 {
            return Err(RenderError::BannerFetchFailed {
                reason: format!(
                    "tree 输出行数不足，期望至少 4 行，实际 {} 行:\n{}",
                    lines.len(),
                    output
                ),
            });
        }

        // 第1行: 卷信息
        let volume_line = lines[0].trim().to_string();
        // 第2行: 序列号
        let serial_line = lines[1].trim().to_string();
        // 最后一行: 无子文件夹提示
        let no_subfolder = lines[lines.len() - 1].trim().to_string();

        Ok(Self {
            volume_line,
            serial_line,
            no_subfolder,
        })
    }

    /// 从字符串解析样板信息（用于测试）
    pub fn parse(output: &str) -> Result<Self, RenderError> {
        Self::parse_tree_output(output)
    }
}

// ============================================================================
// 渲染结果
// ============================================================================

/// 渲染结果
#[derive(Debug, Clone)]
pub struct RenderResult {
    /// 渲染后的文本内容
    pub content: String,
    /// 目录数量
    pub directory_count: usize,
    /// 文件数量
    pub file_count: usize,
}

// ============================================================================
// 树形连接符
// ============================================================================

/// 树形连接符集合
struct TreeChars {
    /// 分支连接符 (├─ 或 +--)
    branch: &'static str,
    /// 最后分支连接符 (└─ 或 \--)
    last_branch: &'static str,
    /// 垂直连接符 (│   或 |   )
    vertical: &'static str,
    /// 空白占位符
    space: &'static str,
}

impl TreeChars {
    /// 根据字符集模式创建连接符集合
    fn from_charset(charset: CharsetMode) -> Self {
        match charset {
            CharsetMode::Unicode => Self {
                branch: "├─",
                last_branch: "└─",
                vertical: "│   ",
                space: "    ",
            },
            CharsetMode::Ascii => Self {
                branch: "+--",
                last_branch: "\\--",
                vertical: "|   ",
                space: "    ",
            },
        }
    }
}

// ============================================================================
// 格式化辅助函数
// ============================================================================

/// 格式化文件大小为人类可读形式
#[must_use]
pub fn format_size_human(size: u64) -> String {
    const KB: u64 = 1024;
    const MB: u64 = 1024 * KB;
    const GB: u64 = 1024 * MB;
    const TB: u64 = 1024 * GB;

    if size >= TB {
        format!("{:.1} TB", size as f64 / TB as f64)
    } else if size >= GB {
        format!("{:.1} GB", size as f64 / GB as f64)
    } else if size >= MB {
        format!("{:.1} MB", size as f64 / MB as f64)
    } else if size >= KB {
        format!("{:.1} KB", size as f64 / KB as f64)
    } else {
        format!("{size} B")
    }
}

/// 格式化 SystemTime 为本地时间日期字符串
///
/// 将 UTC 时间转换为本地时区时间并格式化输出。
///
/// # Examples
///
/// ```
/// use std::time::SystemTime;
/// use treepp::render::format_datetime;
///
/// let now = SystemTime::now();
/// let formatted = format_datetime(&now);
/// // 输出格式: "2025-01-06 15:30:45"
/// assert!(formatted.len() == 19);
/// ```
#[must_use]
pub fn format_datetime(time: &SystemTime) -> String {
    use chrono::{DateTime, Local};

    let datetime: DateTime<Local> = (*time).into();
    datetime.format("%Y-%m-%d %H:%M:%S").to_string()
}

/// 格式化条目名称
fn format_entry_name(node: &TreeNode, config: &Config) -> String {
    let name = match config.render.path_mode {
        PathMode::Full => node.path.to_string_lossy().into_owned(),
        PathMode::Relative => node.name.clone(),
    };

    if config.render.quote_names {
        format!("\"{}\"", name)
    } else {
        name
    }
}

/// 格式化条目元信息 (大小、日期)
fn format_entry_meta(node: &TreeNode, config: &Config) -> String {
    let mut parts = Vec::new();

    // 文件大小
    if config.render.show_size && node.kind == EntryKind::File {
        let size = node.metadata.size;
        let size_str = if config.render.human_readable {
            format_size_human(size)
        } else {
            size.to_string()
        };
        parts.push(size_str);
    }

    // 目录累计大小
    if config.render.show_disk_usage && node.kind == EntryKind::Directory {
        if let Some(usage) = node.disk_usage {
            let usage_str = if config.render.human_readable {
                format_size_human(usage)
            } else {
                usage.to_string()
            };
            parts.push(usage_str);
        }
    }

    // 修改日期
    if config.render.show_date {
        if let Some(ref modified) = node.metadata.modified {
            parts.push(format_datetime(modified));
        }
    }

    if parts.is_empty() {
        String::new()
    } else {
        format!("        {}", parts.join("  "))
    }
}

// ============================================================================
// 渲染器
// ============================================================================

/// 渲染树形结构为文本
#[must_use]
pub fn render(stats: &ScanStats, config: &Config) -> RenderResult {
    let mut output = String::new();
    let chars = TreeChars::from_charset(config.render.charset);

    let root_path = config.root_path.to_string_lossy();

    // Windows 样板头信息
    let banner = if config.render.no_win_banner {
        None
    } else {
        match WinBanner::get_cached() {
            Ok(b) => Some(b),
            Err(e) => {
                let _ = writeln!(output, "警告: {}", e);
                None
            }
        }
    };

    // 输出样板头
    if let Some(b) = &banner {
        output.push_str(&b.volume_line);
        output.push('\n');
        output.push_str(&b.serial_line);
        output.push('\n');
    }

    // 根路径
    output.push_str(&root_path);
    output.push('\n');

    // 渲染子节点
    if config.render.no_indent {
        render_children_no_indent(&mut output, &stats.tree, config, 0);
    } else {
        render_children(&mut output, &stats.tree, &chars, config, "");
    }

    // 无子目录提示
    if let Some(b) = &banner {
        if stats.directory_count == 0 {
            output.push('\n');
            output.push_str(&b.no_subfolder);
            output.push('\n');
        }
    }

    // gitignore 提示
    if config.scan.respect_gitignore {
        output.push('\n');
        output.push_str(".gitignore rules applied");
        output.push('\n');
    }

    // 统计报告
    if config.render.show_report {
        let time_str = format!(" in {:.3}s", stats.duration.as_secs_f64());

        output.push('\n');
        if config.scan.show_files {
            let _ = writeln!(
                output,
                "{} directory, {} files{}",
                stats.directory_count, stats.file_count, time_str
            );
        } else {
            let _ = writeln!(output, "{} directory{}", stats.directory_count, time_str);
        }
    }

    RenderResult {
        content: output,
        directory_count: stats.directory_count,
        file_count: stats.file_count,
    }
}

/// 渲染子节点 (带树形连接符)
fn render_children(
    output: &mut String,
    node: &TreeNode,
    chars: &TreeChars,
    config: &Config,
    prefix: &str,
) {
    let children = get_filtered_children(node, config);
    let count = children.len();

    for (i, child) in children.iter().enumerate() {
        let is_last = i == count - 1;
        let connector = if is_last {
            chars.last_branch
        } else {
            chars.branch
        };

        let name = format_entry_name(child, config);
        let meta = format_entry_meta(child, config);

        let _ = writeln!(output, "{prefix}{connector}{name}{meta}");

        if !child.children.is_empty() {
            let new_prefix = if is_last {
                format!("{}{}", prefix, chars.space)
            } else {
                format!("{}{}", prefix, chars.vertical)
            };
            render_children(output, child, chars, config, &new_prefix);
        }
    }
}

/// 渲染子节点 (无树形连接符，仅缩进)
fn render_children_no_indent(output: &mut String, node: &TreeNode, config: &Config, depth: usize) {
    let children = get_filtered_children(node, config);
    let indent = "  ".repeat(depth);

    for child in &children {
        let name = format_entry_name(child, config);
        let meta = format_entry_meta(child, config);

        let _ = writeln!(output, "{indent}{name}{meta}");

        if !child.children.is_empty() {
            render_children_no_indent(output, child, config, depth + 1);
        }
    }
}

/// 获取过滤后的子节点列表
fn get_filtered_children<'a>(node: &'a TreeNode, config: &Config) -> Vec<&'a TreeNode> {
    node.children
        .iter()
        .filter(|c| config.scan.show_files || c.kind == EntryKind::Directory)
        .filter(|c| {
            !config.matching.prune_empty || c.kind != EntryKind::Directory || !c.is_empty_dir()
        })
        .collect()
}

/// 仅渲染树形文本，不包含 banner 和统计信息
#[must_use]
pub fn render_tree_only(node: &TreeNode, config: &Config) -> String {
    let mut output = String::new();
    let chars = TreeChars::from_charset(config.render.charset);

    let root_name = format_entry_name(node, config);
    let root_meta = format_entry_meta(node, config);
    let _ = writeln!(output, "{root_name}{root_meta}");

    if config.render.no_indent {
        render_children_no_indent(&mut output, node, config, 0);
    } else {
        render_children(&mut output, node, &chars, config, "");
    }

    output
}

// ============================================================================
// 单元测试
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;
    use crate::scan::EntryMetadata;
    use std::path::PathBuf;
    use std::time::Duration;

    /// 创建测试用的简单树结构
    fn create_test_tree() -> TreeNode {
        let mut root = TreeNode::new(
            PathBuf::from("test_root"),
            EntryKind::Directory,
            EntryMetadata::default(),
        );

        let mut src = TreeNode::new(
            PathBuf::from("test_root/src"),
            EntryKind::Directory,
            EntryMetadata::default(),
        );

        src.children.push(TreeNode::new(
            PathBuf::from("test_root/src/main.rs"),
            EntryKind::File,
            EntryMetadata {
                size: 1024,
                ..Default::default()
            },
        ));

        src.children.push(TreeNode::new(
            PathBuf::from("test_root/src/lib.rs"),
            EntryKind::File,
            EntryMetadata {
                size: 2048,
                ..Default::default()
            },
        ));

        root.children.push(src);

        root.children.push(TreeNode::new(
            PathBuf::from("test_root/Cargo.toml"),
            EntryKind::File,
            EntryMetadata {
                size: 512,
                ..Default::default()
            },
        ));

        root
    }

    fn create_test_stats(tree: TreeNode) -> ScanStats {
        let directory_count = tree.count_directories();
        let file_count = tree.count_files();

        ScanStats {
            tree,
            duration: Duration::from_millis(100),
            directory_count,
            file_count,
        }
    }

    // ========================================================================
    // WinBanner 测试
    // ========================================================================

    #[test]
    fn test_win_banner_parse_valid_4_lines() {
        let output = "卷 系统 的文件夹 PATH 列表\n卷序列号为 2810-11C7\nC:.\n没有子文件夹";
        let banner = WinBanner::parse(output).expect("解析应成功");

        assert_eq!(banner.volume_line, "卷 系统 的文件夹 PATH 列表");
        assert_eq!(banner.serial_line, "卷序列号为 2810-11C7");
        assert_eq!(banner.no_subfolder, "没有子文件夹");
    }

    #[test]
    fn test_win_banner_parse_with_trailing_whitespace() {
        let output =
            "卷 系统 的文件夹 PATH 列表  \n  卷序列号为 2810-11C7\nC:.\n没有子文件夹  \n";
        let banner = WinBanner::parse(output).expect("解析应成功");

        assert_eq!(banner.volume_line, "卷 系统 的文件夹 PATH 列表");
        assert_eq!(banner.serial_line, "卷序列号为 2810-11C7");
        assert_eq!(banner.no_subfolder, "没有子文件夹");
    }

    #[test]
    fn test_win_banner_parse_english_locale() {
        let output =
            "Folder PATH listing for volume OS\nVolume serial number is ABCD-1234\nC:.\nNo subfolders exist";
        let banner = WinBanner::parse(output).expect("解析应成功");

        assert_eq!(banner.volume_line, "Folder PATH listing for volume OS");
        assert_eq!(banner.serial_line, "Volume serial number is ABCD-1234");
        assert_eq!(banner.no_subfolder, "No subfolders exist");
    }

    #[test]
    fn test_win_banner_parse_too_few_lines() {
        let output = "只有一行";
        let result = WinBanner::parse(output);
        assert!(result.is_err());

        let output = "第一行\n第二行";
        let result = WinBanner::parse(output);
        assert!(result.is_err());

        let output = "第一行\n第二行\n第三行";
        let result = WinBanner::parse(output);
        assert!(result.is_err());
    }

    #[test]
    fn test_win_banner_parse_exactly_4_lines() {
        let output = "line1\nline2\nline3\nline4";
        let banner = WinBanner::parse(output).expect("4行应该解析成功");

        assert_eq!(banner.volume_line, "line1");
        assert_eq!(banner.serial_line, "line2");
        assert_eq!(banner.no_subfolder, "line4");
    }

    #[test]
    fn test_win_banner_parse_more_than_4_lines() {
        // 如果目录有子目录，输出会更多行，最后一行可能是目录名
        let output = "卷 系统 的文件夹 PATH 列表\n卷序列号为 2810-11C7\nC:.\n├─subdir\n└─another";
        let banner = WinBanner::parse(output).expect("多行应该解析成功");

        assert_eq!(banner.volume_line, "卷 系统 的文件夹 PATH 列表");
        assert_eq!(banner.serial_line, "卷序列号为 2810-11C7");
        assert_eq!(banner.no_subfolder, "└─another"); // 最后一行
    }

    #[test]
    fn test_win_banner_empty_input() {
        let output = "";
        let result = WinBanner::parse(output);
        assert!(result.is_err());
    }

    // ========================================================================
    // format_size_human 测试
    // ========================================================================

    #[test]
    fn test_format_size_human() {
        assert_eq!(format_size_human(0), "0 B");
        assert_eq!(format_size_human(512), "512 B");
        assert_eq!(format_size_human(1023), "1023 B");
        assert_eq!(format_size_human(1024), "1.0 KB");
        assert_eq!(format_size_human(1536), "1.5 KB");
        assert_eq!(format_size_human(1048576), "1.0 MB");
        assert_eq!(format_size_human(1073741824), "1.0 GB");
        assert_eq!(format_size_human(1099511627776), "1.0 TB");
    }

    // ========================================================================
    // format_datetime 测试
    // ========================================================================

    #[test]
    fn test_format_datetime_format() {
        use std::time::SystemTime;

        let now = SystemTime::now();
        let formatted = format_datetime(&now);

        // 验证格式: YYYY-MM-DD HH:MM:SS (19 字符)
        assert_eq!(formatted.len(), 19);
        assert_eq!(&formatted[4..5], "-");
        assert_eq!(&formatted[7..8], "-");
        assert_eq!(&formatted[10..11], " ");
        assert_eq!(&formatted[13..14], ":");
        assert_eq!(&formatted[16..17], ":");
    }

    #[test]
    fn test_format_datetime_returns_local_time() {
        use chrono::Local;
        use std::time::SystemTime;

        let now = SystemTime::now();
        let formatted = format_datetime(&now);

        // 获取当前本地时间进行比较
        let local_now = Local::now();
        let expected_date = local_now.format("%Y-%m-%d").to_string();

        // 日期部分应该匹配本地时间
        assert!(
            formatted.starts_with(&expected_date),
            "格式化时间 {} 应以本地日期 {} 开头",
            formatted,
            expected_date
        );
    }

    // ========================================================================
    // TreeChars 测试
    // ========================================================================

    #[test]
    fn test_tree_chars_unicode() {
        let chars = TreeChars::from_charset(CharsetMode::Unicode);
        assert_eq!(chars.branch, "├─");
        assert_eq!(chars.last_branch, "└─");
        assert_eq!(chars.vertical, "│   ");
    }

    #[test]
    fn test_tree_chars_ascii() {
        let chars = TreeChars::from_charset(CharsetMode::Ascii);
        assert_eq!(chars.branch, "+--");
        assert_eq!(chars.last_branch, "\\--");
        assert_eq!(chars.vertical, "|   ");
    }

    // ========================================================================
    // render 测试
    // ========================================================================

    #[test]
    fn test_render_basic() {
        let tree = create_test_tree();
        let stats = create_test_stats(tree);

        let mut config = Config::with_root(PathBuf::from("test_root"));
        config.render.no_win_banner = true;
        config.scan.show_files = true;

        let result = render(&stats, &config);

        assert!(result.content.contains("test_root"));
        assert!(result.content.contains("src"));
        assert!(result.content.contains("main.rs"));
        assert!(result.content.contains("Cargo.toml"));
        assert_eq!(result.directory_count, 1);
        assert_eq!(result.file_count, 3);
    }

    #[test]
    fn test_render_ascii() {
        let tree = create_test_tree();
        let stats = create_test_stats(tree);

        let mut config = Config::with_root(PathBuf::from("test_root"));
        config.render.no_win_banner = true;
        config.render.charset = CharsetMode::Ascii;
        config.scan.show_files = true;

        let result = render(&stats, &config);

        assert!(result.content.contains("+--") || result.content.contains("\\--"));
    }

    #[test]
    fn test_render_no_indent() {
        let tree = create_test_tree();
        let stats = create_test_stats(tree);

        let mut config = Config::with_root(PathBuf::from("test_root"));
        config.render.no_win_banner = true;
        config.render.no_indent = true;
        config.scan.show_files = true;

        let result = render(&stats, &config);

        assert!(!result.content.contains("├"));
        assert!(!result.content.contains("└"));
        assert!(!result.content.contains("+--"));
    }

    #[test]
    fn test_render_with_size() {
        let tree = create_test_tree();
        let stats = create_test_stats(tree);

        let mut config = Config::with_root(PathBuf::from("test_root"));
        config.render.no_win_banner = true;
        config.render.show_size = true;
        config.scan.show_files = true;

        let result = render(&stats, &config);

        assert!(result.content.contains("1024") || result.content.contains("2048"));
    }

    #[test]
    fn test_render_human_readable_size() {
        let tree = create_test_tree();
        let stats = create_test_stats(tree);

        let mut config = Config::with_root(PathBuf::from("test_root"));
        config.render.no_win_banner = true;
        config.render.show_size = true;
        config.render.human_readable = true;
        config.scan.show_files = true;

        let result = render(&stats, &config);

        assert!(result.content.contains("KB") || result.content.contains("B"));
    }

    #[test]
    fn test_render_with_report() {
        let tree = create_test_tree();
        let stats = create_test_stats(tree);

        let mut config = Config::with_root(PathBuf::from("test_root"));
        config.render.no_win_banner = true;
        config.render.show_report = true;
        config.scan.show_files = true;

        let result = render(&stats, &config);

        assert!(result.content.contains("directory"));
        assert!(result.content.contains("files"));
    }

    #[test]
    fn test_render_directories_only() {
        let tree = create_test_tree();
        let stats = create_test_stats(tree);

        let mut config = Config::with_root(PathBuf::from("test_root"));
        config.render.no_win_banner = true;
        config.scan.show_files = false;

        let result = render(&stats, &config);

        assert!(!result.content.contains("main.rs"));
        assert!(!result.content.contains("Cargo.toml"));
        assert!(result.content.contains("src"));
    }

    #[test]
    fn test_render_tree_only() {
        let tree = create_test_tree();

        let mut config = Config::with_root(PathBuf::from("test_root"));
        config.scan.show_files = true;

        let result = render_tree_only(&tree, &config);

        assert!(result.contains("test_root"));
        assert!(result.contains("src"));
        assert!(result.contains("main.rs"));
    }

    #[test]
    fn test_render_result_struct() {
        let result = RenderResult {
            content: "test".to_string(),
            directory_count: 5,
            file_count: 10,
        };
        assert_eq!(result.content, "test");
        assert_eq!(result.directory_count, 5);
        assert_eq!(result.file_count, 10);
    }

    #[test]
    fn test_format_entry_name_with_quote() {
        let node = TreeNode::new(
            PathBuf::from("test.txt"),
            EntryKind::File,
            EntryMetadata::default(),
        );

        let mut config = Config::with_root(PathBuf::from("."));
        config.render.quote_names = false;

        let name = format_entry_name(&node, &config);
        assert_eq!(name, "test.txt");

        config.render.quote_names = true;
        let name = format_entry_name(&node, &config);
        assert_eq!(name, "\"test.txt\"");
    }

    #[test]
    fn test_format_entry_name_full_path_with_quote() {
        let node = TreeNode::new(
            PathBuf::from("/path/to/test.txt"),
            EntryKind::File,
            EntryMetadata::default(),
        );

        let mut config = Config::with_root(PathBuf::from("."));
        config.render.path_mode = PathMode::Full;
        config.render.quote_names = true;

        let name = format_entry_name(&node, &config);
        assert!(name.starts_with('"'));
        assert!(name.ends_with('"'));
        assert!(name.contains("test.txt"));
    }

    #[test]
    fn test_render_with_quote() {
        let tree = create_test_tree();
        let stats = create_test_stats(tree);

        let mut config = Config::with_root(PathBuf::from("test_root"));
        config.render.no_win_banner = true;
        config.render.quote_names = true;
        config.scan.show_files = true;

        let result = render(&stats, &config);

        assert!(result.content.contains("\"src\""));
        assert!(result.content.contains("\"main.rs\""));
    }

    #[test]
    fn test_render_with_dirs_first() {
        use crate::config::SortKey;
        use crate::scan::sort_tree;

        let mut tree = TreeNode::new(
            PathBuf::from("root"),
            EntryKind::Directory,
            EntryMetadata::default(),
        );
        tree.children.push(TreeNode::new(
            PathBuf::from("root/z_file.txt"),
            EntryKind::File,
            EntryMetadata::default(),
        ));
        tree.children.push(TreeNode::new(
            PathBuf::from("root/a_dir"),
            EntryKind::Directory,
            EntryMetadata::default(),
        ));

        // 在渲染前需要排序（模拟 scan 模块的行为）
        sort_tree(&mut tree, SortKey::Name, false, true);

        let stats = ScanStats {
            tree,
            duration: Duration::from_millis(100),
            directory_count: 1,
            file_count: 1,
        };

        let mut config = Config::with_root(PathBuf::from("root"));
        config.render.no_win_banner = true;
        config.render.dirs_first = true;
        config.scan.show_files = true;

        let result = render(&stats, &config);

        // 目录应该在文件之前
        let a_dir_pos = result.content.find("a_dir").unwrap();
        let z_file_pos = result.content.find("z_file.txt").unwrap();
        assert!(a_dir_pos < z_file_pos, "目录应该在文件之前");
    }
}
```

scan.rs:  

```rust
//! 扫描模块：目录树扫描引擎与统一 IR
//!
//! 本模块负责目录树的遍历与构建，提供：
//!
//! - **统一 IR**：`TreeNode` 与 `EntryKind` 表示目录树结构
//! - **扫描统计**：`ScanStats` 记录扫描结果与耗时
//! - **双模式扫描**：单线程 `walk` 与多线程 `parallel` 模式，输出保证一致
//! - **过滤功能**：include/exclude 通配、ignore-case、level 限制、prune 空目录
//! - **gitignore 支持**：分层叠加 `.gitignore` 规则，支持规则链继承与缓存
//! - **确定性排序**：按 `SortKey` 排序，支持逆序
//!
//! 作者: WaterRun
//! 更新于: 2025-01-06

#![forbid(unsafe_code)]

use std::cmp::Ordering;
use std::collections::HashMap;
use std::fs::{self, Metadata};
use std::path::{Path, PathBuf};
use std::sync::{Arc, Mutex};
use std::time::{Duration, Instant, SystemTime};

use glob::Pattern;
use ignore::gitignore::{Gitignore, GitignoreBuilder};
use rayon::prelude::*;
use rayon::ThreadPoolBuilder;

use crate::config::{Config, SortKey};
use crate::error::{MatchError, ScanError, TreeppResult};

// ============================================================================
// 类型定义
// ============================================================================

/// 文件系统条目类型
///
/// 区分目录与文件两种基本类型。
///
/// # Examples
///
/// ```
/// use treepp::scan::EntryKind;
///
/// let dir = EntryKind::Directory;
/// let file = EntryKind::File;
/// assert_ne!(dir, file);
/// ```
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum EntryKind {
    /// 目录
    Directory,
    /// 文件
    File,
}

impl EntryKind {
    /// 从文件系统元数据判断条目类型
    #[must_use]
    pub fn from_metadata(meta: &Metadata) -> Self {
        if meta.is_dir() {
            Self::Directory
        } else {
            Self::File
        }
    }
}

/// 条目元数据
///
/// 存储文件/目录的附加信息，用于显示和排序。
///
/// # Examples
///
/// ```
/// use treepp::scan::EntryMetadata;
///
/// let meta = EntryMetadata::default();
/// assert_eq!(meta.size, 0);
/// assert!(meta.modified.is_none());
/// ```
#[derive(Debug, Clone, Default)]
pub struct EntryMetadata {
    /// 文件大小（字节），目录为 0
    pub size: u64,
    /// 最后修改时间
    pub modified: Option<SystemTime>,
    /// 创建时间
    pub created: Option<SystemTime>,
}

impl EntryMetadata {
    /// 从文件系统元数据创建
    ///
    /// # Examples
    ///
    /// ```no_run
    /// use std::fs;
    /// use treepp::scan::EntryMetadata;
    ///
    /// let meta = fs::metadata(".").unwrap();
    /// let entry_meta = EntryMetadata::from_fs_metadata(&meta);
    /// ```
    #[must_use]
    pub fn from_fs_metadata(meta: &Metadata) -> Self {
        Self {
            size: if meta.is_file() { meta.len() } else { 0 },
            modified: meta.modified().ok(),
            created: meta.created().ok(),
        }
    }
}

/// 目录树节点
///
/// 表示目录树中的单个条目，可递归包含子节点。
/// 这是扫描输出的统一中间表示（IR）。
///
/// # Examples
///
/// ```
/// use std::path::PathBuf;
/// use treepp::scan::{TreeNode, EntryKind, EntryMetadata};
///
/// let node = TreeNode::new(
///     PathBuf::from("src"),
///     EntryKind::Directory,
///     EntryMetadata::default(),
/// );
/// assert_eq!(node.name, "src");
/// assert!(node.children.is_empty());
/// ```
#[derive(Debug, Clone)]
pub struct TreeNode {
    /// 条目名称（不含路径）
    pub name: String,
    /// 完整路径
    pub path: PathBuf,
    /// 条目类型
    pub kind: EntryKind,
    /// 元数据
    pub metadata: EntryMetadata,
    /// 子节点（仅目录有效）
    pub children: Vec<TreeNode>,
    /// 目录累计大小（用于 disk_usage 显示）
    pub disk_usage: Option<u64>,
}

impl TreeNode {
    /// 创建新的叶子节点
    ///
    /// # Examples
    ///
    /// ```
    /// use std::path::PathBuf;
    /// use treepp::scan::{TreeNode, EntryKind, EntryMetadata};
    ///
    /// let node = TreeNode::new(
    ///     PathBuf::from("main.rs"),
    ///     EntryKind::File,
    ///     EntryMetadata { size: 1024, ..Default::default() },
    /// );
    /// assert_eq!(node.name, "main.rs");
    /// assert_eq!(node.metadata.size, 1024);
    /// ```
    #[must_use]
    pub fn new(path: PathBuf, kind: EntryKind, metadata: EntryMetadata) -> Self {
        let name = path
            .file_name()
            .map(|s| s.to_string_lossy().into_owned())
            .unwrap_or_else(|| path.to_string_lossy().into_owned());

        Self {
            name,
            path,
            kind,
            metadata,
            children: Vec::new(),
            disk_usage: None,
        }
    }

    /// 创建带子节点的目录节点
    #[must_use]
    pub fn with_children(
        path: PathBuf,
        kind: EntryKind,
        metadata: EntryMetadata,
        children: Vec<Self>,
    ) -> Self {
        let name = path
            .file_name()
            .map(|s| s.to_string_lossy().into_owned())
            .unwrap_or_else(|| path.to_string_lossy().into_owned());

        Self {
            name,
            path,
            kind,
            metadata,
            children,
            disk_usage: None,
        }
    }

    /// 递归统计目录数量（不含根节点自身）
    ///
    /// # Examples
    ///
    /// ```
    /// use std::path::PathBuf;
    /// use treepp::scan::{TreeNode, EntryKind, EntryMetadata};
    ///
    /// let mut root = TreeNode::new(PathBuf::from("."), EntryKind::Directory, EntryMetadata::default());
    /// root.children.push(TreeNode::new(PathBuf::from("src"), EntryKind::Directory, EntryMetadata::default()));
    /// assert_eq!(root.count_directories(), 1);
    /// ```
    #[must_use]
    pub fn count_directories(&self) -> usize {
        self.children
            .iter()
            .map(|c| {
                if c.kind == EntryKind::Directory {
                    1 + c.count_directories()
                } else {
                    0
                }
            })
            .sum()
    }

    /// 递归统计文件数量
    ///
    /// # Examples
    ///
    /// ```
    /// use std::path::PathBuf;
    /// use treepp::scan::{TreeNode, EntryKind, EntryMetadata};
    ///
    /// let mut root = TreeNode::new(PathBuf::from("."), EntryKind::Directory, EntryMetadata::default());
    /// root.children.push(TreeNode::new(PathBuf::from("main.rs"), EntryKind::File, EntryMetadata::default()));
    /// assert_eq!(root.count_files(), 1);
    /// ```
    #[must_use]
    pub fn count_files(&self) -> usize {
        let self_count = if self.kind == EntryKind::File { 1 } else { 0 };
        self_count + self.children.iter().map(Self::count_files).sum::<usize>()
    }

    /// 递归计算目录累计大小
    ///
    /// # Examples
    ///
    /// ```
    /// use std::path::PathBuf;
    /// use treepp::scan::{TreeNode, EntryKind, EntryMetadata};
    ///
    /// let mut root = TreeNode::new(PathBuf::from("."), EntryKind::Directory, EntryMetadata::default());
    /// root.children.push(TreeNode::new(
    ///     PathBuf::from("file.txt"),
    ///     EntryKind::File,
    ///     EntryMetadata { size: 100, ..Default::default() },
    /// ));
    /// root.compute_disk_usage();
    /// assert_eq!(root.disk_usage, Some(100));
    /// ```
    pub fn compute_disk_usage(&mut self) -> u64 {
        if self.kind == EntryKind::File {
            return self.metadata.size;
        }

        let total: u64 = self
            .children
            .iter_mut()
            .map(|c| c.compute_disk_usage())
            .sum();

        self.disk_usage = Some(total);
        total
    }

    /// 检查是否为空目录（无子节点或仅含空子目录）
    ///
    /// # Examples
    ///
    /// ```
    /// use std::path::PathBuf;
    /// use treepp::scan::{TreeNode, EntryKind, EntryMetadata};
    ///
    /// let empty = TreeNode::new(PathBuf::from("empty"), EntryKind::Directory, EntryMetadata::default());
    /// assert!(empty.is_empty_dir());
    ///
    /// let mut with_file = TreeNode::new(PathBuf::from("src"), EntryKind::Directory, EntryMetadata::default());
    /// with_file.children.push(TreeNode::new(PathBuf::from("main.rs"), EntryKind::File, EntryMetadata::default()));
    /// assert!(!with_file.is_empty_dir());
    /// ```
    #[must_use]
    pub fn is_empty_dir(&self) -> bool {
        if self.kind != EntryKind::Directory {
            return false;
        }
        self.children.is_empty() || self.children.iter().all(Self::is_empty_dir)
    }

    /// 修剪空目录
    ///
    /// 递归移除所有空目录节点。
    pub fn prune_empty_dirs(&mut self) {
        // 先递归处理子节点
        for child in &mut self.children {
            child.prune_empty_dirs();
        }
        // 移除空目录
        self.children.retain(|c| {
            if c.kind == EntryKind::Directory {
                !c.is_empty_dir()
            } else {
                true
            }
        });
    }
}

/// 扫描统计结果
///
/// 包含扫描产出的目录树、耗时统计和条目计数。
///
/// # Examples
///
/// ```
/// use std::path::PathBuf;
/// use std::time::Duration;
/// use treepp::scan::{ScanStats, TreeNode, EntryKind, EntryMetadata};
///
/// let tree = TreeNode::new(PathBuf::from("."), EntryKind::Directory, EntryMetadata::default());
/// let stats = ScanStats {
///     tree,
///     duration: Duration::from_millis(100),
///     directory_count: 5,
///     file_count: 20,
/// };
/// assert_eq!(stats.directory_count, 5);
/// ```
#[derive(Debug)]
pub struct ScanStats {
    /// 根节点
    pub tree: TreeNode,
    /// 扫描耗时
    pub duration: Duration,
    /// 目录总数（不含根）
    pub directory_count: usize,
    /// 文件总数
    pub file_count: usize,
}

// ============================================================================
// 匹配规则
// ============================================================================

/// 编译后的匹配规则集
struct CompiledRules {
    /// 包含模式
    include_patterns: Vec<Pattern>,
    /// 排除模式
    exclude_patterns: Vec<Pattern>,
    /// 是否忽略大小写（已在编译时处理）
    ignore_case: bool,
}

impl CompiledRules {
    /// 从配置编译匹配规则
    fn compile(config: &Config) -> Result<Self, MatchError> {
        let ignore_case = config.matching.ignore_case;

        let include_patterns = config
            .matching
            .include_patterns
            .iter()
            .map(|p| compile_pattern(p, ignore_case))
            .collect::<Result<Vec<_>, _>>()?;

        let exclude_patterns = config
            .matching
            .exclude_patterns
            .iter()
            .map(|p| compile_pattern(p, ignore_case))
            .collect::<Result<Vec<_>, _>>()?;

        Ok(Self {
            include_patterns,
            exclude_patterns,
            ignore_case,
        })
    }

    /// 检查名称是否应被包含
    fn should_include(&self, name: &str, is_dir: bool) -> bool {
        // 目录始终包含（除非被排除）
        if is_dir {
            return true;
        }

        // 无 include 模式时包含所有
        if self.include_patterns.is_empty() {
            return true;
        }

        let match_name = if self.ignore_case {
            name.to_lowercase()
        } else {
            name.to_string()
        };

        self.include_patterns.iter().any(|p| p.matches(&match_name))
    }

    /// 检查名称是否应被排除
    fn should_exclude(&self, name: &str) -> bool {
        if self.exclude_patterns.is_empty() {
            return false;
        }

        let match_name = if self.ignore_case {
            name.to_lowercase()
        } else {
            name.to_string()
        };

        self.exclude_patterns.iter().any(|p| p.matches(&match_name))
    }
}

/// 编译单个通配符模式
fn compile_pattern(pattern: &str, ignore_case: bool) -> Result<Pattern, MatchError> {
    let pat = if ignore_case {
        pattern.to_lowercase()
    } else {
        pattern.to_string()
    };

    Pattern::new(&pat).map_err(|e| MatchError::InvalidPattern {
        pattern: pattern.to_string(),
        reason: e.msg.to_string(),
    })
}

// ============================================================================
// Gitignore 支持
// ============================================================================

/// Gitignore 规则链
///
/// 支持多级目录的 gitignore 规则叠加，子目录继承父目录规则。
/// 使用 `Arc<Gitignore>` 实现跨线程安全共享。
#[derive(Clone, Default)]
struct GitignoreChain {
    /// 规则链（从根到当前目录），使用 Arc 共享以支持多线程
    rules: Vec<Arc<Gitignore>>,
}

impl GitignoreChain {
    /// 创建空的规则链
    fn new() -> Self {
        Self { rules: Vec::new() }
    }

    /// 创建包含新规则的子链
    ///
    /// 返回一个新的链，包含当前链的所有规则加上新规则。
    fn with_child(&self, gitignore: Arc<Gitignore>) -> Self {
        let mut new_chain = self.clone();
        new_chain.rules.push(gitignore);
        new_chain
    }

    /// 检查路径是否被任一规则忽略
    ///
    /// 从最具体（最深层）的规则开始检查，支持白名单规则。
    fn is_ignored(&self, path: &Path, is_dir: bool) -> bool {
        // 从最具体（最深层）的规则开始检查
        for gi in self.rules.iter().rev() {
            let matched = gi.matched(path, is_dir);
            if matched.is_ignore() {
                return true;
            }
            if matched.is_whitelist() {
                return false;
            }
        }
        false
    }
}

/// Gitignore 缓存
///
/// 避免重复加载同一目录的 .gitignore 文件。
/// 线程安全，支持并发访问。
struct GitignoreCache {
    /// 缓存映射：目录路径 -> 可选的 gitignore 规则
    cache: Mutex<HashMap<PathBuf, Option<Arc<Gitignore>>>>,
}

impl GitignoreCache {
    /// 创建新的缓存
    fn new() -> Self {
        Self {
            cache: Mutex::new(HashMap::new()),
        }
    }

    /// 获取或加载指定目录的 gitignore 规则
    ///
    /// 如果已缓存则直接返回，否则从文件系统加载并缓存。
    fn get_or_load(&self, dir: &Path) -> Option<Arc<Gitignore>> {
        let mut cache = self.cache.lock().unwrap();

        if let Some(cached) = cache.get(dir) {
            return cached.clone();
        }

        let gitignore = load_gitignore_from_path(dir).map(Arc::new);
        cache.insert(dir.to_path_buf(), gitignore.clone());
        gitignore
    }
}

/// 从指定目录加载 .gitignore 规则
fn load_gitignore_from_path(dir: &Path) -> Option<Gitignore> {
    let gitignore_path = dir.join(".gitignore");
    if !gitignore_path.exists() {
        return None;
    }

    let mut builder = GitignoreBuilder::new(dir);
    if builder.add(&gitignore_path).is_some() {
        return None;
    }

    builder.build().ok()
}

// ============================================================================
// 排序
// ============================================================================

/// 对树节点进行确定性排序（递归）
pub fn sort_tree(node: &mut TreeNode, sort_key: SortKey, reverse: bool, dirs_first: bool) {
    // 排序子节点
    node.children.sort_by(|a, b| {
        // 目录优先排序（仅当 dirs_first 为 true 时）
        let kind_order = if dirs_first {
            match (a.kind, b.kind) {
                (EntryKind::Directory, EntryKind::File) => Ordering::Less,
                (EntryKind::File, EntryKind::Directory) => Ordering::Greater,
                _ => Ordering::Equal,
            }
        } else {
            Ordering::Equal
        };

        if kind_order != Ordering::Equal {
            return kind_order;
        }

        // 按指定键排序
        let cmp = match sort_key {
            SortKey::Name => a.name.to_lowercase().cmp(&b.name.to_lowercase()),
            SortKey::Size => {
                let size_a = a.disk_usage.unwrap_or(a.metadata.size);
                let size_b = b.disk_usage.unwrap_or(b.metadata.size);
                size_a.cmp(&size_b)
            }
            SortKey::Mtime => a.metadata.modified.cmp(&b.metadata.modified),
            SortKey::Ctime => a.metadata.created.cmp(&b.metadata.created),
        };

        if reverse {
            cmp.reverse()
        } else {
            cmp
        }
    });

    // 递归排序子节点的子节点
    for child in &mut node.children {
        sort_tree(child, sort_key, reverse, dirs_first);
    }
}

// ============================================================================
// 扫描上下文
// ============================================================================

/// 扫描上下文，包含所有扫描配置
struct ScanContext {
    /// 是否显示文件
    show_files: bool,
    /// 最大递归深度
    max_depth: Option<usize>,
    /// 是否遵循 gitignore
    respect_gitignore: bool,
    /// 编译后的匹配规则
    rules: CompiledRules,
    /// 排序键
    sort_key: SortKey,
    /// 是否逆序
    reverse: bool,
    /// 是否目录优先
    dirs_first: bool,
    /// 是否修剪空目录
    prune_empty: bool,
    /// 是否需要大小信息
    needs_size: bool,
    /// Gitignore 缓存（多线程共享）
    gitignore_cache: Arc<GitignoreCache>,
}

impl ScanContext {
    /// 从配置创建扫描上下文
    fn from_config(config: &Config) -> Result<Self, MatchError> {
        Ok(Self {
            show_files: config.scan.show_files,
            max_depth: config.scan.max_depth,
            respect_gitignore: config.scan.respect_gitignore,
            rules: CompiledRules::compile(config)?,
            sort_key: config.render.sort_key,
            reverse: config.render.reverse_sort,
            dirs_first: config.render.dirs_first,
            prune_empty: config.matching.prune_empty,
            needs_size: config.needs_size_info(),
            gitignore_cache: Arc::new(GitignoreCache::new()),
        })
    }

    /// 检查条目是否应被过滤
    fn should_filter(&self, name: &str, is_dir: bool) -> bool {
        // 排除检查
        if self.rules.should_exclude(name) {
            return true;
        }

        // 包含检查（仅对文件）
        if !is_dir && !self.rules.should_include(name, is_dir) {
            return true;
        }

        // 文件显示检查
        if !is_dir && !self.show_files {
            return true;
        }

        false
    }

    /// 获取或加载指定目录的 gitignore 规则
    fn get_gitignore(&self, dir: &Path) -> Option<Arc<Gitignore>> {
        if !self.respect_gitignore {
            return None;
        }
        self.gitignore_cache.get_or_load(dir)
    }
}

// ============================================================================
// 单线程扫描
// ============================================================================

/// 单线程递归扫描
fn walk_recursive(
    path: &Path,
    depth: usize,
    ctx: &ScanContext,
    parent_chain: &GitignoreChain,
) -> Option<TreeNode> {
    // 深度限制检查
    if let Some(max) = ctx.max_depth {
        if depth > max {
            return None;
        }
    }

    let meta = fs::metadata(path).ok()?;
    let kind = EntryKind::from_metadata(&meta);
    let metadata = EntryMetadata::from_fs_metadata(&meta);

    // 构建当前目录的 gitignore 链
    let current_chain = if ctx.respect_gitignore && kind == EntryKind::Directory {
        if let Some(gi) = ctx.get_gitignore(path) {
            parent_chain.with_child(gi)
        } else {
            parent_chain.clone()
        }
    } else {
        parent_chain.clone()
    };

    let mut node = TreeNode::new(path.to_path_buf(), kind, metadata);

    if kind == EntryKind::Directory {
        let entries = match fs::read_dir(path) {
            Ok(e) => e,
            Err(_) => return Some(node),
        };

        for entry in entries.flatten() {
            let entry_path = entry.path();
            let entry_name = entry_path
                .file_name()
                .map(|s| s.to_string_lossy().into_owned())
                .unwrap_or_default();

            let entry_meta = match entry.metadata() {
                Ok(m) => m,
                Err(_) => continue,
            };

            let is_dir = entry_meta.is_dir();

            // gitignore 检查
            if ctx.respect_gitignore && current_chain.is_ignored(&entry_path, is_dir) {
                continue;
            }

            // 过滤检查
            if ctx.should_filter(&entry_name, is_dir) {
                continue;
            }

            // 递归处理
            if let Some(child) = walk_recursive(&entry_path, depth + 1, ctx, &current_chain) {
                node.children.push(child);
            }
        }
    }

    Some(node)
}

/// 单线程扫描入口
///
/// 使用深度优先递归遍历目录树。
///
/// # Errors
///
/// 返回 `ScanError` 如果根路径不存在或无法访问。
///
/// # Examples
///
/// ```no_run
/// use std::path::PathBuf;
/// use treepp::config::Config;
/// use treepp::scan::scan_walk;
///
/// let config = Config::with_root(PathBuf::from("."));
/// let stats = scan_walk(&config).expect("扫描失败");
/// println!("目录: {}, 文件: {}", stats.directory_count, stats.file_count);
/// ```
pub fn scan_walk(config: &Config) -> TreeppResult<ScanStats> {
    let start = Instant::now();

    // 验证根路径
    if !config.root_path.exists() {
        return Err(ScanError::PathNotFound {
            path: config.root_path.clone(),
        }
            .into());
    }

    if !config.root_path.is_dir() {
        return Err(ScanError::NotADirectory {
            path: config.root_path.clone(),
        }
            .into());
    }

    // 创建扫描上下文
    let ctx = ScanContext::from_config(config)?;

    // 初始化空的 gitignore 链
    let initial_chain = GitignoreChain::new();

    // 执行扫描
    let mut tree =
        walk_recursive(&config.root_path, 0, &ctx, &initial_chain).ok_or_else(|| {
            ScanError::ReadDirFailed {
                path: config.root_path.clone(),
                source: std::io::Error::new(std::io::ErrorKind::Other, "无法读取根目录"),
            }
        })?;

    // 计算目录累计大小（如需要）
    if ctx.needs_size {
        tree.compute_disk_usage();
    }

    // 修剪空目录（如需要）
    if ctx.prune_empty {
        tree.prune_empty_dirs();
    }

    // 排序
    sort_tree(&mut tree, ctx.sort_key, ctx.reverse, ctx.dirs_first);

    let duration = start.elapsed();
    let directory_count = tree.count_directories();
    let file_count = tree.count_files();

    Ok(ScanStats {
        tree,
        duration,
        directory_count,
        file_count,
    })
}

// ============================================================================
// 多线程扫描
// ============================================================================

/// 多线程分治扫描（内部函数）
fn parallel_scan_dir(
    path: &Path,
    depth: usize,
    ctx: &ScanContext,
    parent_chain: GitignoreChain,
) -> Option<TreeNode> {
    // 深度限制检查
    if let Some(max) = ctx.max_depth {
        if depth > max {
            return None;
        }
    }

    let meta = fs::metadata(path).ok()?;
    let kind = EntryKind::from_metadata(&meta);
    let metadata = EntryMetadata::from_fs_metadata(&meta);

    if kind != EntryKind::Directory {
        return Some(TreeNode::new(path.to_path_buf(), kind, metadata));
    }

    // 构建当前目录的 gitignore 链
    let current_chain = if ctx.respect_gitignore {
        if let Some(gi) = ctx.get_gitignore(path) {
            parent_chain.with_child(gi)
        } else {
            parent_chain
        }
    } else {
        parent_chain
    };

    // 读取目录条目
    let entries: Vec<_> = fs::read_dir(path).ok()?.flatten().collect();

    // 分离子目录和文件
    let mut subdirs = Vec::new();
    let mut files = Vec::new();

    for entry in entries {
        let entry_path = entry.path();
        let entry_name = entry_path
            .file_name()
            .map(|s| s.to_string_lossy().into_owned())
            .unwrap_or_default();

        let entry_meta = match entry.metadata() {
            Ok(m) => m,
            Err(_) => continue,
        };

        let is_dir = entry_meta.is_dir();

        // gitignore 检查
        if ctx.respect_gitignore && current_chain.is_ignored(&entry_path, is_dir) {
            continue;
        }

        // 过滤检查
        if ctx.should_filter(&entry_name, is_dir) {
            continue;
        }

        if is_dir {
            subdirs.push(entry_path);
        } else {
            let file_metadata = EntryMetadata::from_fs_metadata(&entry_meta);
            files.push(TreeNode::new(entry_path, EntryKind::File, file_metadata));
        }
    }

    // 并行处理子目录，正确传递 gitignore 链
    let subdir_trees: Vec<TreeNode> = subdirs
        .into_par_iter()
        .filter_map(|subdir| {
            // 克隆当前链传递给子目录
            parallel_scan_dir(&subdir, depth + 1, ctx, current_chain.clone())
        })
        .collect();

    // 合并结果
    let mut children = subdir_trees;
    children.extend(files);

    Some(TreeNode::with_children(
        path.to_path_buf(),
        EntryKind::Directory,
        metadata,
        children,
    ))
}

/// 多线程扫描入口
///
/// 使用 rayon 分治策略并行扫描目录树。
/// 对于小目录或单核系统，内部可能回退到单线程模式。
///
/// # 保证
///
/// 输出结果与 `scan_walk` 在结构上完全一致（经过相同的排序后）。
///
/// # Errors
///
/// 返回 `ScanError` 如果根路径不存在、线程池创建失败等。
///
/// # Examples
///
/// ```no_run
/// use std::path::PathBuf;
/// use treepp::config::Config;
/// use treepp::scan::scan_parallel;
///
/// let config = Config::with_root(PathBuf::from("."));
/// let stats = scan_parallel(&config).expect("扫描失败");
/// println!("耗时: {:?}", stats.duration);
/// ```
pub fn scan_parallel(config: &Config) -> TreeppResult<ScanStats> {
    let start = Instant::now();

    // 验证根路径
    if !config.root_path.exists() {
        return Err(ScanError::PathNotFound {
            path: config.root_path.clone(),
        }
            .into());
    }

    if !config.root_path.is_dir() {
        return Err(ScanError::NotADirectory {
            path: config.root_path.clone(),
        }
            .into());
    }

    // 创建扫描上下文
    let ctx = ScanContext::from_config(config)?;

    // 创建线程池
    let thread_count = config.scan.thread_count.get();
    let pool = ThreadPoolBuilder::new()
        .num_threads(thread_count)
        .build()
        .map_err(|e| ScanError::WalkError {
            message: format!("线程池创建失败: {}", e),
            path: Some(config.root_path.clone()),
        })?;

    // 初始化空的 gitignore 链
    let initial_chain = GitignoreChain::new();

    // 在线程池中执行扫描
    let root_path = config.root_path.clone();
    let mut tree = pool
        .install(|| parallel_scan_dir(&root_path, 0, &ctx, initial_chain))
        .ok_or_else(|| ScanError::ReadDirFailed {
            path: config.root_path.clone(),
            source: std::io::Error::new(std::io::ErrorKind::Other, "无法读取根目录"),
        })?;

    // 计算目录累计大小（如需要）
    if ctx.needs_size {
        tree.compute_disk_usage();
    }

    // 修剪空目录（如需要）
    if ctx.prune_empty {
        tree.prune_empty_dirs();
    }

    // 排序（确保与 walk 模式输出一致）
    sort_tree(&mut tree, ctx.sort_key, ctx.reverse, ctx.dirs_first);

    let duration = start.elapsed();
    let directory_count = tree.count_directories();
    let file_count = tree.count_files();

    Ok(ScanStats {
        tree,
        duration,
        directory_count,
        file_count,
    })
}

// ============================================================================
// 统一扫描入口
// ============================================================================

/// 执行目录扫描
///
/// 根据配置的线程数自动选择扫描模式：
/// - 线程数为 1 时使用单线程模式
/// - 否则使用多线程模式
///
/// # Errors
///
/// 返回 `TreeppError` 如果扫描过程中发生错误。
///
/// # Examples
///
/// ```no_run
/// use std::path::PathBuf;
/// use treepp::config::Config;
/// use treepp::scan::scan;
///
/// let config = Config::with_root(PathBuf::from(".")).validate().unwrap();
/// let stats = scan(&config).expect("扫描失败");
/// println!("{} 个目录, {} 个文件", stats.directory_count, stats.file_count);
/// ```
pub fn scan(config: &Config) -> TreeppResult<ScanStats> {
    if config.scan.thread_count.get() == 1 {
        scan_walk(config)
    } else {
        scan_parallel(config)
    }
}

// ============================================================================
// 单元测试
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs::{self, File};
    use std::io::Write;
    use tempfile::TempDir;

    // ------------------------------------------------------------------------
    // 测试辅助函数
    // ------------------------------------------------------------------------

    /// 创建基本测试目录结构
    fn setup_test_dir() -> TempDir {
        let dir = TempDir::new().expect("创建临时目录失败");
        let root = dir.path();

        // 创建目录结构
        fs::create_dir(root.join("src")).unwrap();
        fs::create_dir(root.join("tests")).unwrap();
        fs::create_dir(root.join("empty")).unwrap();

        // 创建文件
        File::create(root.join("Cargo.toml"))
            .unwrap()
            .write_all(b"[package]")
            .unwrap();
        File::create(root.join("README.md"))
            .unwrap()
            .write_all(b"# Test")
            .unwrap();
        File::create(root.join("src/main.rs"))
            .unwrap()
            .write_all(b"fn main() {}")
            .unwrap();
        File::create(root.join("src/lib.rs"))
            .unwrap()
            .write_all(b"pub fn lib() {}")
            .unwrap();
        File::create(root.join("tests/test.rs"))
            .unwrap()
            .write_all(b"#[test]")
            .unwrap();

        dir
    }

    /// 创建带 .gitignore 的测试目录
    fn setup_gitignore_dir() -> TempDir {
        let dir = setup_test_dir();
        let root = dir.path();

        // 创建 .gitignore
        File::create(root.join(".gitignore"))
            .unwrap()
            .write_all(b"target/\n*.log\n")
            .unwrap();

        // 创建应被忽略的目录和文件
        fs::create_dir(root.join("target")).unwrap();
        File::create(root.join("target/debug"))
            .unwrap()
            .write_all(b"")
            .unwrap();
        File::create(root.join("app.log"))
            .unwrap()
            .write_all(b"log")
            .unwrap();

        dir
    }

    /// 创建嵌套 .gitignore 的测试目录
    fn setup_nested_gitignore_dir() -> TempDir {
        let dir = TempDir::new().expect("创建临时目录失败");
        let root = dir.path();

        // 创建目录结构
        fs::create_dir(root.join("level1")).unwrap();
        fs::create_dir(root.join("level1/level2")).unwrap();
        fs::create_dir(root.join("level1/level2/level3")).unwrap();

        // 根目录 .gitignore：忽略 *.tmp
        File::create(root.join(".gitignore"))
            .unwrap()
            .write_all(b"*.tmp\n")
            .unwrap();

        // level1 .gitignore：忽略 *.bak
        File::create(root.join("level1/.gitignore"))
            .unwrap()
            .write_all(b"*.bak\n")
            .unwrap();

        // level2 .gitignore：忽略 *.cache
        File::create(root.join("level1/level2/.gitignore"))
            .unwrap()
            .write_all(b"*.cache\n")
            .unwrap();

        // 创建各种应被忽略的文件
        File::create(root.join("root.tmp"))
            .unwrap()
            .write_all(b"")
            .unwrap();
        File::create(root.join("root.txt"))
            .unwrap()
            .write_all(b"")
            .unwrap();

        File::create(root.join("level1/l1.tmp"))
            .unwrap()
            .write_all(b"")
            .unwrap();
        File::create(root.join("level1/l1.bak"))
            .unwrap()
            .write_all(b"")
            .unwrap();
        File::create(root.join("level1/l1.txt"))
            .unwrap()
            .write_all(b"")
            .unwrap();

        File::create(root.join("level1/level2/l2.tmp"))
            .unwrap()
            .write_all(b"")
            .unwrap();
        File::create(root.join("level1/level2/l2.bak"))
            .unwrap()
            .write_all(b"")
            .unwrap();
        File::create(root.join("level1/level2/l2.cache"))
            .unwrap()
            .write_all(b"")
            .unwrap();
        File::create(root.join("level1/level2/l2.txt"))
            .unwrap()
            .write_all(b"")
            .unwrap();

        File::create(root.join("level1/level2/level3/l3.tmp"))
            .unwrap()
            .write_all(b"")
            .unwrap();
        File::create(root.join("level1/level2/level3/l3.bak"))
            .unwrap()
            .write_all(b"")
            .unwrap();
        File::create(root.join("level1/level2/level3/l3.cache"))
            .unwrap()
            .write_all(b"")
            .unwrap();
        File::create(root.join("level1/level2/level3/l3.txt"))
            .unwrap()
            .write_all(b"")
            .unwrap();

        dir
    }

    /// 收集树中所有节点名称（递归）
    fn collect_names(node: &TreeNode) -> Vec<String> {
        let mut names = vec![node.name.clone()];
        for child in &node.children {
            names.extend(collect_names(child));
        }
        names.sort();
        names
    }

    /// 检查树中是否存在指定名称的节点
    fn has_node_with_name(node: &TreeNode, name: &str) -> bool {
        if node.name == name {
            return true;
        }
        node.children.iter().any(|c| has_node_with_name(c, name))
    }

    // ------------------------------------------------------------------------
    // EntryKind 测试
    // ------------------------------------------------------------------------

    #[test]
    fn test_entry_kind_from_metadata_file() {
        let dir = TempDir::new().unwrap();
        let file_path = dir.path().join("test.txt");
        File::create(&file_path).unwrap();

        let file_meta = fs::metadata(&file_path).unwrap();
        assert_eq!(EntryKind::from_metadata(&file_meta), EntryKind::File);
    }

    #[test]
    fn test_entry_kind_from_metadata_directory() {
        let dir = TempDir::new().unwrap();
        let dir_meta = fs::metadata(dir.path()).unwrap();
        assert_eq!(EntryKind::from_metadata(&dir_meta), EntryKind::Directory);
    }

    #[test]
    fn test_entry_kind_equality() {
        assert_eq!(EntryKind::Directory, EntryKind::Directory);
        assert_eq!(EntryKind::File, EntryKind::File);
        assert_ne!(EntryKind::Directory, EntryKind::File);
    }

    // ------------------------------------------------------------------------
    // EntryMetadata 测试
    // ------------------------------------------------------------------------

    #[test]
    fn test_entry_metadata_default() {
        let meta = EntryMetadata::default();
        assert_eq!(meta.size, 0);
        assert!(meta.modified.is_none());
        assert!(meta.created.is_none());
    }

    #[test]
    fn test_entry_metadata_from_fs_metadata() {
        let dir = TempDir::new().unwrap();
        let file_path = dir.path().join("test.txt");
        File::create(&file_path)
            .unwrap()
            .write_all(b"hello world")
            .unwrap();

        let fs_meta = fs::metadata(&file_path).unwrap();
        let entry_meta = EntryMetadata::from_fs_metadata(&fs_meta);

        assert_eq!(entry_meta.size, 11); // "hello world" = 11 bytes
        assert!(entry_meta.modified.is_some());
    }

    #[test]
    fn test_entry_metadata_directory_size_is_zero() {
        let dir = TempDir::new().unwrap();
        let fs_meta = fs::metadata(dir.path()).unwrap();
        let entry_meta = EntryMetadata::from_fs_metadata(&fs_meta);

        assert_eq!(entry_meta.size, 0);
    }

    // ------------------------------------------------------------------------
    // TreeNode 测试
    // ------------------------------------------------------------------------

    #[test]
    fn test_tree_node_new() {
        let node = TreeNode::new(
            PathBuf::from("/test/main.rs"),
            EntryKind::File,
            EntryMetadata {
                size: 1024,
                ..Default::default()
            },
        );

        assert_eq!(node.name, "main.rs");
        assert_eq!(node.path, PathBuf::from("/test/main.rs"));
        assert_eq!(node.kind, EntryKind::File);
        assert_eq!(node.metadata.size, 1024);
        assert!(node.children.is_empty());
        assert!(node.disk_usage.is_none());
    }

    #[test]
    fn test_tree_node_with_children() {
        let child = TreeNode::new(
            PathBuf::from("file.txt"),
            EntryKind::File,
            EntryMetadata::default(),
        );

        let node = TreeNode::with_children(
            PathBuf::from("dir"),
            EntryKind::Directory,
            EntryMetadata::default(),
            vec![child],
        );

        assert_eq!(node.name, "dir");
        assert_eq!(node.children.len(), 1);
        assert_eq!(node.children[0].name, "file.txt");
    }

    #[test]
    fn test_tree_node_count_files_single() {
        let node = TreeNode::new(
            PathBuf::from("file.txt"),
            EntryKind::File,
            EntryMetadata::default(),
        );
        assert_eq!(node.count_files(), 1);
    }

    #[test]
    fn test_tree_node_count_files_nested() {
        let mut root = TreeNode::new(
            PathBuf::from("."),
            EntryKind::Directory,
            EntryMetadata::default(),
        );
        root.children.push(TreeNode::new(
            PathBuf::from("a.txt"),
            EntryKind::File,
            EntryMetadata::default(),
        ));
        root.children.push(TreeNode::new(
            PathBuf::from("b.txt"),
            EntryKind::File,
            EntryMetadata::default(),
        ));

        let mut subdir = TreeNode::new(
            PathBuf::from("sub"),
            EntryKind::Directory,
            EntryMetadata::default(),
        );
        subdir.children.push(TreeNode::new(
            PathBuf::from("c.txt"),
            EntryKind::File,
            EntryMetadata::default(),
        ));
        root.children.push(subdir);

        assert_eq!(root.count_files(), 3);
    }

    #[test]
    fn test_tree_node_count_directories_empty() {
        let root = TreeNode::new(
            PathBuf::from("."),
            EntryKind::Directory,
            EntryMetadata::default(),
        );
        assert_eq!(root.count_directories(), 0);
    }

    #[test]
    fn test_tree_node_count_directories_nested() {
        let mut root = TreeNode::new(
            PathBuf::from("."),
            EntryKind::Directory,
            EntryMetadata::default(),
        );

        let mut sub1 = TreeNode::new(
            PathBuf::from("sub1"),
            EntryKind::Directory,
            EntryMetadata::default(),
        );
        sub1.children.push(TreeNode::new(
            PathBuf::from("nested"),
            EntryKind::Directory,
            EntryMetadata::default(),
        ));

        root.children.push(sub1);
        root.children.push(TreeNode::new(
            PathBuf::from("sub2"),
            EntryKind::Directory,
            EntryMetadata::default(),
        ));

        assert_eq!(root.count_directories(), 3);
    }

    #[test]
    fn test_tree_node_is_empty_dir_empty() {
        let empty = TreeNode::new(
            PathBuf::from("empty"),
            EntryKind::Directory,
            EntryMetadata::default(),
        );
        assert!(empty.is_empty_dir());
    }

    #[test]
    fn test_tree_node_is_empty_dir_file() {
        let file = TreeNode::new(
            PathBuf::from("file.txt"),
            EntryKind::File,
            EntryMetadata::default(),
        );
        assert!(!file.is_empty_dir());
    }

    #[test]
    fn test_tree_node_is_empty_dir_with_content() {
        let mut with_content = TreeNode::new(
            PathBuf::from("dir"),
            EntryKind::Directory,
            EntryMetadata::default(),
        );
        with_content.children.push(TreeNode::new(
            PathBuf::from("file.txt"),
            EntryKind::File,
            EntryMetadata::default(),
        ));
        assert!(!with_content.is_empty_dir());
    }

    #[test]
    fn test_tree_node_is_empty_dir_nested_empty() {
        let mut root = TreeNode::new(
            PathBuf::from("root"),
            EntryKind::Directory,
            EntryMetadata::default(),
        );
        root.children.push(TreeNode::new(
            PathBuf::from("empty_child"),
            EntryKind::Directory,
            EntryMetadata::default(),
        ));
        // 只含空子目录也算空
        assert!(root.is_empty_dir());
    }

    #[test]
    fn test_tree_node_compute_disk_usage_single_file() {
        let mut file = TreeNode::new(
            PathBuf::from("file.txt"),
            EntryKind::File,
            EntryMetadata {
                size: 100,
                ..Default::default()
            },
        );
        let usage = file.compute_disk_usage();
        assert_eq!(usage, 100);
    }

    #[test]
    fn test_tree_node_compute_disk_usage_directory() {
        let mut root = TreeNode::new(
            PathBuf::from("."),
            EntryKind::Directory,
            EntryMetadata::default(),
        );
        root.children.push(TreeNode::new(
            PathBuf::from("a.txt"),
            EntryKind::File,
            EntryMetadata {
                size: 100,
                ..Default::default()
            },
        ));
        root.children.push(TreeNode::new(
            PathBuf::from("b.txt"),
            EntryKind::File,
            EntryMetadata {
                size: 200,
                ..Default::default()
            },
        ));

        root.compute_disk_usage();
        assert_eq!(root.disk_usage, Some(300));
    }

    #[test]
    fn test_tree_node_compute_disk_usage_nested() {
        let mut root = TreeNode::new(
            PathBuf::from("."),
            EntryKind::Directory,
            EntryMetadata::default(),
        );

        let mut subdir = TreeNode::new(
            PathBuf::from("sub"),
            EntryKind::Directory,
            EntryMetadata::default(),
        );
        subdir.children.push(TreeNode::new(
            PathBuf::from("nested.txt"),
            EntryKind::File,
            EntryMetadata {
                size: 50,
                ..Default::default()
            },
        ));

        root.children.push(subdir);
        root.children.push(TreeNode::new(
            PathBuf::from("root.txt"),
            EntryKind::File,
            EntryMetadata {
                size: 100,
                ..Default::default()
            },
        ));

        root.compute_disk_usage();
        assert_eq!(root.disk_usage, Some(150));
    }

    #[test]
    fn test_tree_node_prune_empty_dirs_removes_empty() {
        let mut root = TreeNode::new(
            PathBuf::from("."),
            EntryKind::Directory,
            EntryMetadata::default(),
        );
        root.children.push(TreeNode::new(
            PathBuf::from("empty"),
            EntryKind::Directory,
            EntryMetadata::default(),
        ));
        root.children.push(TreeNode::new(
            PathBuf::from("file.txt"),
            EntryKind::File,
            EntryMetadata::default(),
        ));

        assert_eq!(root.children.len(), 2);
        root.prune_empty_dirs();
        assert_eq!(root.children.len(), 1);
        assert_eq!(root.children[0].name, "file.txt");
    }

    #[test]
    fn test_tree_node_prune_empty_dirs_keeps_non_empty() {
        let mut root = TreeNode::new(
            PathBuf::from("."),
            EntryKind::Directory,
            EntryMetadata::default(),
        );

        let mut non_empty = TreeNode::new(
            PathBuf::from("non_empty"),
            EntryKind::Directory,
            EntryMetadata::default(),
        );
        non_empty.children.push(TreeNode::new(
            PathBuf::from("file.txt"),
            EntryKind::File,
            EntryMetadata::default(),
        ));
        root.children.push(non_empty);

        root.prune_empty_dirs();
        assert_eq!(root.children.len(), 1);
        assert_eq!(root.children[0].name, "non_empty");
    }

    #[test]
    fn test_tree_node_prune_empty_dirs_recursive() {
        let mut root = TreeNode::new(
            PathBuf::from("."),
            EntryKind::Directory,
            EntryMetadata::default(),
        );

        let mut level1 = TreeNode::new(
            PathBuf::from("level1"),
            EntryKind::Directory,
            EntryMetadata::default(),
        );
        level1.children.push(TreeNode::new(
            PathBuf::from("empty_nested"),
            EntryKind::Directory,
            EntryMetadata::default(),
        ));
        root.children.push(level1);

        root.prune_empty_dirs();
        assert!(root.children.is_empty());
    }

    // ------------------------------------------------------------------------
    // GitignoreChain 测试
    // ------------------------------------------------------------------------

    #[test]
    fn test_gitignore_chain_new_empty() {
        let chain = GitignoreChain::new();
        assert!(!chain.is_ignored(Path::new("test.txt"), false));
        assert!(!chain.is_ignored(Path::new("anything"), true));
    }

    #[test]
    fn test_gitignore_chain_with_child() {
        let chain1 = GitignoreChain::new();
        let chain2 = chain1.clone();

        // 验证克隆独立
        assert_eq!(chain1.rules.len(), chain2.rules.len());
    }

    #[test]
    fn test_gitignore_chain_is_ignored_basic() {
        let dir = TempDir::new().unwrap();
        let root = dir.path();

        File::create(root.join(".gitignore"))
            .unwrap()
            .write_all(b"*.log\n")
            .unwrap();

        let gi = load_gitignore_from_path(root).unwrap();
        let chain = GitignoreChain::new().with_child(Arc::new(gi));

        assert!(chain.is_ignored(&root.join("test.log"), false));
        assert!(!chain.is_ignored(&root.join("test.txt"), false));
    }

    // ------------------------------------------------------------------------
    // GitignoreCache 测试
    // ------------------------------------------------------------------------

    #[test]
    fn test_gitignore_cache_returns_none_for_missing() {
        let dir = TempDir::new().unwrap();
        let cache = GitignoreCache::new();

        let result = cache.get_or_load(dir.path());
        assert!(result.is_none());
    }

    #[test]
    fn test_gitignore_cache_loads_existing() {
        let dir = TempDir::new().unwrap();
        let root = dir.path();

        File::create(root.join(".gitignore"))
            .unwrap()
            .write_all(b"*.log\n")
            .unwrap();

        let cache = GitignoreCache::new();
        let result = cache.get_or_load(root);

        assert!(result.is_some());
    }

    #[test]
    fn test_gitignore_cache_caches_result() {
        let dir = TempDir::new().unwrap();
        let root = dir.path();

        File::create(root.join(".gitignore"))
            .unwrap()
            .write_all(b"*.log\n")
            .unwrap();

        let cache = GitignoreCache::new();

        let result1 = cache.get_or_load(root);
        let result2 = cache.get_or_load(root);

        assert!(result1.is_some());
        assert!(result2.is_some());

        // 验证返回的是同一个 Arc
        assert!(Arc::ptr_eq(&result1.unwrap(), &result2.unwrap()));
    }

    #[test]
    fn test_gitignore_cache_caches_none() {
        let dir = TempDir::new().unwrap();
        let cache = GitignoreCache::new();

        let _result1 = cache.get_or_load(dir.path());
        let _result2 = cache.get_or_load(dir.path());

        // 验证缓存了 None 结果
        let inner = cache.cache.lock().unwrap();
        assert!(inner.contains_key(dir.path()));
    }

    // ------------------------------------------------------------------------
    // 匹配规则测试
    // ------------------------------------------------------------------------

    #[test]
    fn test_compile_pattern_basic() {
        let pattern = compile_pattern("*.rs", false).expect("编译失败");
        assert!(pattern.matches("main.rs"));
        assert!(pattern.matches("lib.rs"));
        assert!(!pattern.matches("main.txt"));
    }

    #[test]
    fn test_compile_pattern_case_sensitive() {
        let pattern = compile_pattern("*.RS", false).expect("编译失败");
        assert!(pattern.matches("main.RS"));
        assert!(!pattern.matches("main.rs"));
    }

    #[test]
    fn test_compile_pattern_ignore_case() {
        let pattern = compile_pattern("*.RS", true).expect("编译失败");
        // 忽略大小写时模式被转为小写
        assert!(pattern.matches("main.rs"));
        assert!(pattern.matches("lib.rs"));
    }

    #[test]
    fn test_compile_pattern_invalid() {
        let result = compile_pattern("[invalid", false);
        assert!(result.is_err());

        if let Err(MatchError::InvalidPattern { pattern, .. }) = result {
            assert_eq!(pattern, "[invalid");
        } else {
            panic!("期望 InvalidPattern 错误");
        }
    }

    #[test]
    fn test_compiled_rules_should_include_no_patterns() {
        let config = Config::default();
        let rules = CompiledRules::compile(&config).unwrap();

        assert!(rules.should_include("any.rs", false));
        assert!(rules.should_include("any.txt", false));
    }

    #[test]
    fn test_compiled_rules_should_include_with_pattern() {
        let mut config = Config::default();
        config.matching.include_patterns = vec!["*.rs".to_string()];

        let rules = CompiledRules::compile(&config).unwrap();

        assert!(rules.should_include("main.rs", false));
        assert!(!rules.should_include("main.txt", false));
    }

    #[test]
    fn test_compiled_rules_should_include_directory_always() {
        let mut config = Config::default();
        config.matching.include_patterns = vec!["*.rs".to_string()];

        let rules = CompiledRules::compile(&config).unwrap();

        // 目录始终包含
        assert!(rules.should_include("src", true));
        assert!(rules.should_include("tests", true));
    }

    #[test]
    fn test_compiled_rules_should_exclude_no_patterns() {
        let config = Config::default();
        let rules = CompiledRules::compile(&config).unwrap();

        assert!(!rules.should_exclude("any.rs"));
        assert!(!rules.should_exclude("any.txt"));
    }

    #[test]
    fn test_compiled_rules_should_exclude_with_pattern() {
        let mut config = Config::default();
        config.matching.exclude_patterns = vec!["*.log".to_string()];

        let rules = CompiledRules::compile(&config).unwrap();

        assert!(rules.should_exclude("app.log"));
        assert!(!rules.should_exclude("app.txt"));
    }

    // ------------------------------------------------------------------------
    // 排序测试
    // ------------------------------------------------------------------------

    #[test]
    fn test_sort_tree_by_name() {
        let mut root = TreeNode::new(
            PathBuf::from("."),
            EntryKind::Directory,
            EntryMetadata::default(),
        );
        root.children.push(TreeNode::new(
            PathBuf::from("zebra.txt"),
            EntryKind::File,
            EntryMetadata::default(),
        ));
        root.children.push(TreeNode::new(
            PathBuf::from("alpha.txt"),
            EntryKind::File,
            EntryMetadata::default(),
        ));
        root.children.push(TreeNode::new(
            PathBuf::from("beta.txt"),
            EntryKind::File,
            EntryMetadata::default(),
        ));

        sort_tree(&mut root, SortKey::Name, false, false);

        assert_eq!(root.children[0].name, "alpha.txt");
        assert_eq!(root.children[1].name, "beta.txt");
        assert_eq!(root.children[2].name, "zebra.txt");
    }

    #[test]
    fn test_sort_tree_by_name_case_insensitive() {
        let mut root = TreeNode::new(
            PathBuf::from("."),
            EntryKind::Directory,
            EntryMetadata::default(),
        );
        root.children.push(TreeNode::new(
            PathBuf::from("Zebra.txt"),
            EntryKind::File,
            EntryMetadata::default(),
        ));
        root.children.push(TreeNode::new(
            PathBuf::from("alpha.txt"),
            EntryKind::File,
            EntryMetadata::default(),
        ));
        root.children.push(TreeNode::new(
            PathBuf::from("Beta.txt"),
            EntryKind::File,
            EntryMetadata::default(),
        ));

        sort_tree(&mut root, SortKey::Name, false, false);

        assert_eq!(root.children[0].name, "alpha.txt");
        assert_eq!(root.children[1].name, "Beta.txt");
        assert_eq!(root.children[2].name, "Zebra.txt");
    }

    #[test]
    fn test_sort_tree_by_size() {
        let mut root = TreeNode::new(
            PathBuf::from("."),
            EntryKind::Directory,
            EntryMetadata::default(),
        );
        root.children.push(TreeNode::new(
            PathBuf::from("large.txt"),
            EntryKind::File,
            EntryMetadata {
                size: 1000,
                ..Default::default()
            },
        ));
        root.children.push(TreeNode::new(
            PathBuf::from("small.txt"),
            EntryKind::File,
            EntryMetadata {
                size: 100,
                ..Default::default()
            },
        ));
        root.children.push(TreeNode::new(
            PathBuf::from("medium.txt"),
            EntryKind::File,
            EntryMetadata {
                size: 500,
                ..Default::default()
            },
        ));

        sort_tree(&mut root, SortKey::Size, false, false);

        assert_eq!(root.children[0].name, "small.txt");
        assert_eq!(root.children[1].name, "medium.txt");
        assert_eq!(root.children[2].name, "large.txt");
    }

    #[test]
    fn test_sort_tree_reverse() {
        let mut root = TreeNode::new(
            PathBuf::from("."),
            EntryKind::Directory,
            EntryMetadata::default(),
        );
        root.children.push(TreeNode::new(
            PathBuf::from("a.txt"),
            EntryKind::File,
            EntryMetadata::default(),
        ));
        root.children.push(TreeNode::new(
            PathBuf::from("b.txt"),
            EntryKind::File,
            EntryMetadata::default(),
        ));
        root.children.push(TreeNode::new(
            PathBuf::from("c.txt"),
            EntryKind::File,
            EntryMetadata::default(),
        ));

        sort_tree(&mut root, SortKey::Name, true, false);

        assert_eq!(root.children[0].name, "c.txt");
        assert_eq!(root.children[1].name, "b.txt");
        assert_eq!(root.children[2].name, "a.txt");
    }

    #[test]
    fn test_sort_tree_dirs_first_disabled() {
        let mut root = TreeNode::new(
            PathBuf::from("."),
            EntryKind::Directory,
            EntryMetadata::default(),
        );
        root.children.push(TreeNode::new(
            PathBuf::from("z_file.txt"),
            EntryKind::File,
            EntryMetadata::default(),
        ));
        root.children.push(TreeNode::new(
            PathBuf::from("a_dir"),
            EntryKind::Directory,
            EntryMetadata::default(),
        ));
        root.children.push(TreeNode::new(
            PathBuf::from("b_file.txt"),
            EntryKind::File,
            EntryMetadata::default(),
        ));

        // dirs_first = false，按名称排序，不区分目录和文件
        sort_tree(&mut root, SortKey::Name, false, false);

        assert_eq!(root.children[0].name, "a_dir");
        assert_eq!(root.children[1].name, "b_file.txt");
        assert_eq!(root.children[2].name, "z_file.txt");
    }

    #[test]
    fn test_sort_tree_dirs_before_files() {
        let mut root = TreeNode::new(
            PathBuf::from("."),
            EntryKind::Directory,
            EntryMetadata::default(),
        );
        root.children.push(TreeNode::new(
            PathBuf::from("file.txt"),
            EntryKind::File,
            EntryMetadata::default(),
        ));
        root.children.push(TreeNode::new(
            PathBuf::from("dir"),
            EntryKind::Directory,
            EntryMetadata::default(),
        ));
        root.children.push(TreeNode::new(
            PathBuf::from("another.txt"),
            EntryKind::File,
            EntryMetadata::default(),
        ));

        sort_tree(&mut root, SortKey::Name, false, true);

        assert_eq!(root.children[0].kind, EntryKind::Directory);
        assert_eq!(root.children[1].kind, EntryKind::File);
        assert_eq!(root.children[2].kind, EntryKind::File);
    }

    #[test]
    fn test_sort_tree_recursive() {
        let mut root = TreeNode::new(
            PathBuf::from("."),
            EntryKind::Directory,
            EntryMetadata::default(),
        );

        let mut subdir = TreeNode::new(
            PathBuf::from("sub"),
            EntryKind::Directory,
            EntryMetadata::default(),
        );
        subdir.children.push(TreeNode::new(
            PathBuf::from("z.txt"),
            EntryKind::File,
            EntryMetadata::default(),
        ));
        subdir.children.push(TreeNode::new(
            PathBuf::from("a.txt"),
            EntryKind::File,
            EntryMetadata::default(),
        ));

        root.children.push(subdir);

        sort_tree(&mut root, SortKey::Name, false, true);

        // 验证子目录内容也被排序
        assert_eq!(root.children[0].children[0].name, "a.txt");
        assert_eq!(root.children[0].children[1].name, "z.txt");
    }

    // ------------------------------------------------------------------------
    // 基本扫描测试
    // ------------------------------------------------------------------------

    #[test]
    fn test_scan_walk_basic() {
        let dir = setup_test_dir();
        let mut config = Config::with_root(dir.path().to_path_buf());
        config.scan.show_files = true;

        let stats = scan_walk(&config).expect("扫描失败");

        assert_eq!(stats.directory_count, 3); // src, tests, empty
        assert_eq!(stats.file_count, 5); // Cargo.toml, README.md, main.rs, lib.rs, test.rs
    }

    #[test]
    fn test_scan_walk_dirs_only() {
        let dir = setup_test_dir();
        let config = Config::with_root(dir.path().to_path_buf());

        let stats = scan_walk(&config).expect("扫描失败");

        assert_eq!(stats.directory_count, 3);
        assert_eq!(stats.file_count, 0);
    }

    #[test]
    fn test_scan_walk_max_depth_zero() {
        let dir = setup_test_dir();
        let mut config = Config::with_root(dir.path().to_path_buf());
        config.scan.show_files = true;
        config.scan.max_depth = Some(0);

        let stats = scan_walk(&config).expect("扫描失败");

        // 深度 0 只包含根目录本身
        assert_eq!(stats.directory_count, 0);
        assert_eq!(stats.file_count, 0);
    }

    #[test]
    fn test_scan_walk_max_depth_one() {
        let dir = setup_test_dir();
        let mut config = Config::with_root(dir.path().to_path_buf());
        config.scan.show_files = true;
        config.scan.max_depth = Some(1);

        let stats = scan_walk(&config).expect("扫描失败");

        // 深度 1 包含根目录下的直接子项
        assert_eq!(stats.directory_count, 3); // src, tests, empty
        assert_eq!(stats.file_count, 2); // Cargo.toml, README.md
    }

    #[test]
    fn test_scan_walk_with_prune() {
        let dir = setup_test_dir();
        let mut config = Config::with_root(dir.path().to_path_buf());
        config.scan.show_files = true;
        config.matching.prune_empty = true;

        let stats = scan_walk(&config).expect("扫描失败");

        assert_eq!(stats.directory_count, 2); // src, tests (empty 被修剪)
    }

    #[test]
    fn test_scan_walk_with_include() {
        let dir = setup_test_dir();
        let mut config = Config::with_root(dir.path().to_path_buf());
        config.scan.show_files = true;
        config.matching.include_patterns = vec!["*.rs".to_string()];

        let stats = scan_walk(&config).expect("扫描失败");

        assert_eq!(stats.file_count, 3); // main.rs, lib.rs, test.rs
    }

    #[test]
    fn test_scan_walk_with_exclude() {
        let dir = setup_test_dir();
        let mut config = Config::with_root(dir.path().to_path_buf());
        config.scan.show_files = true;
        config.matching.exclude_patterns = vec!["*.md".to_string()];

        let stats = scan_walk(&config).expect("扫描失败");

        assert_eq!(stats.file_count, 4); // 不包含 README.md
        assert!(!has_node_with_name(&stats.tree, "README.md"));
    }

    #[test]
    fn test_scan_walk_nonexistent_path() {
        let config = Config::with_root(PathBuf::from("/nonexistent/path/12345"));
        let result = scan_walk(&config);
        assert!(result.is_err());
    }

    #[test]
    fn test_scan_walk_file_as_root() {
        let dir = TempDir::new().unwrap();
        let file_path = dir.path().join("file.txt");
        File::create(&file_path).unwrap();

        let config = Config::with_root(file_path);
        let result = scan_walk(&config);
        assert!(result.is_err());
    }

    // ------------------------------------------------------------------------
    // Gitignore 扫描测试
    // ------------------------------------------------------------------------

    #[test]
    fn test_scan_walk_with_gitignore() {
        let dir = setup_gitignore_dir();
        let mut config = Config::with_root(dir.path().to_path_buf());
        config.scan.show_files = true;
        config.scan.respect_gitignore = true;

        let stats = scan_walk(&config).expect("扫描失败");

        // target 目录和 .log 文件应被忽略
        assert!(!has_node_with_name(&stats.tree, "target"));
        assert!(!has_node_with_name(&stats.tree, "app.log"));

        // 其他文件应存在
        assert!(has_node_with_name(&stats.tree, "Cargo.toml"));
    }

    #[test]
    fn test_scan_walk_without_gitignore() {
        let dir = setup_gitignore_dir();
        let mut config = Config::with_root(dir.path().to_path_buf());
        config.scan.show_files = true;
        config.scan.respect_gitignore = false;

        let stats = scan_walk(&config).expect("扫描失败");

        // 不启用 gitignore 时，所有文件都应存在
        assert!(has_node_with_name(&stats.tree, "target"));
        assert!(has_node_with_name(&stats.tree, "app.log"));
    }

    #[test]
    fn test_scan_walk_nested_gitignore_inheritance() {
        let dir = setup_nested_gitignore_dir();
        let mut config = Config::with_root(dir.path().to_path_buf());
        config.scan.show_files = true;
        config.scan.respect_gitignore = true;

        let stats = scan_walk(&config).expect("扫描失败");

        // 验证根目录规则生效：所有 *.tmp 被忽略
        assert!(!has_node_with_name(&stats.tree, "root.tmp"));
        assert!(!has_node_with_name(&stats.tree, "l1.tmp"));
        assert!(!has_node_with_name(&stats.tree, "l2.tmp"));
        assert!(!has_node_with_name(&stats.tree, "l3.tmp"));

        // 验证 level1 规则生效：level1 及以下 *.bak 被忽略
        assert!(!has_node_with_name(&stats.tree, "l1.bak"));
        assert!(!has_node_with_name(&stats.tree, "l2.bak"));
        assert!(!has_node_with_name(&stats.tree, "l3.bak"));

        // 验证 level2 规则生效：level2 及以下 *.cache 被忽略
        assert!(!has_node_with_name(&stats.tree, "l2.cache"));
        assert!(!has_node_with_name(&stats.tree, "l3.cache"));

        // 验证正常文件存在
        assert!(has_node_with_name(&stats.tree, "root.txt"));
        assert!(has_node_with_name(&stats.tree, "l1.txt"));
        assert!(has_node_with_name(&stats.tree, "l2.txt"));
        assert!(has_node_with_name(&stats.tree, "l3.txt"));
    }

    // ------------------------------------------------------------------------
    // 多线程扫描测试
    // ------------------------------------------------------------------------

    #[test]
    fn test_scan_parallel_basic() {
        let dir = setup_test_dir();
        let mut config = Config::with_root(dir.path().to_path_buf());
        config.scan.show_files = true;

        let stats = scan_parallel(&config).expect("扫描失败");

        assert_eq!(stats.directory_count, 3);
        assert_eq!(stats.file_count, 5);
    }

    #[test]
    fn test_scan_parallel_with_gitignore() {
        let dir = setup_gitignore_dir();
        let mut config = Config::with_root(dir.path().to_path_buf());
        config.scan.show_files = true;
        config.scan.respect_gitignore = true;

        let stats = scan_parallel(&config).expect("扫描失败");

        assert!(!has_node_with_name(&stats.tree, "target"));
        assert!(!has_node_with_name(&stats.tree, "app.log"));
    }

    #[test]
    fn test_scan_parallel_nested_gitignore() {
        let dir = setup_nested_gitignore_dir();
        let mut config = Config::with_root(dir.path().to_path_buf());
        config.scan.show_files = true;
        config.scan.respect_gitignore = true;

        let stats = scan_parallel(&config).expect("扫描失败");

        // 验证嵌套规则生效
        assert!(!has_node_with_name(&stats.tree, "l3.tmp"));
        assert!(!has_node_with_name(&stats.tree, "l3.bak"));
        assert!(!has_node_with_name(&stats.tree, "l3.cache"));
        assert!(has_node_with_name(&stats.tree, "l3.txt"));
    }

    // ------------------------------------------------------------------------
    // 单线程与多线程一致性测试
    // ------------------------------------------------------------------------

    #[test]
    fn test_scan_walk_parallel_consistency_basic() {
        let dir = setup_test_dir();
        let mut config = Config::with_root(dir.path().to_path_buf());
        config.scan.show_files = true;

        let walk_stats = scan_walk(&config).expect("walk 扫描失败");
        let parallel_stats = scan_parallel(&config).expect("parallel 扫描失败");

        assert_eq!(walk_stats.directory_count, parallel_stats.directory_count);
        assert_eq!(walk_stats.file_count, parallel_stats.file_count);

        let walk_names = collect_names(&walk_stats.tree);
        let parallel_names = collect_names(&parallel_stats.tree);
        assert_eq!(walk_names, parallel_names);
    }

    #[test]
    fn test_scan_walk_parallel_consistency_with_gitignore() {
        let dir = setup_gitignore_dir();
        let mut config = Config::with_root(dir.path().to_path_buf());
        config.scan.show_files = true;
        config.scan.respect_gitignore = true;

        let walk_stats = scan_walk(&config).expect("walk 扫描失败");
        let parallel_stats = scan_parallel(&config).expect("parallel 扫描失败");

        assert_eq!(walk_stats.directory_count, parallel_stats.directory_count);
        assert_eq!(walk_stats.file_count, parallel_stats.file_count);

        let walk_names = collect_names(&walk_stats.tree);
        let parallel_names = collect_names(&parallel_stats.tree);
        assert_eq!(walk_names, parallel_names);
    }

    #[test]
    fn test_scan_walk_parallel_consistency_nested_gitignore() {
        let dir = setup_nested_gitignore_dir();
        let mut config = Config::with_root(dir.path().to_path_buf());
        config.scan.show_files = true;
        config.scan.respect_gitignore = true;

        let walk_stats = scan_walk(&config).expect("walk 扫描失败");
        let parallel_stats = scan_parallel(&config).expect("parallel 扫描失败");

        // 验证计数一致
        assert_eq!(
            walk_stats.directory_count, parallel_stats.directory_count,
            "目录数量不一致"
        );
        assert_eq!(
            walk_stats.file_count, parallel_stats.file_count,
            "文件数量不一致"
        );

        // 验证结构一致
        let walk_names = collect_names(&walk_stats.tree);
        let parallel_names = collect_names(&parallel_stats.tree);
        assert_eq!(walk_names, parallel_names, "节点名称集合不一致");
    }

    #[test]
    fn test_scan_walk_parallel_consistency_with_filters() {
        let dir = setup_test_dir();
        let mut config = Config::with_root(dir.path().to_path_buf());
        config.scan.show_files = true;
        config.matching.include_patterns = vec!["*.rs".to_string()];
        config.matching.prune_empty = true;

        let walk_stats = scan_walk(&config).expect("walk 扫描失败");
        let parallel_stats = scan_parallel(&config).expect("parallel 扫描失败");

        assert_eq!(walk_stats.file_count, parallel_stats.file_count);

        let walk_names = collect_names(&walk_stats.tree);
        let parallel_names = collect_names(&parallel_stats.tree);
        assert_eq!(walk_names, parallel_names);
    }

    // ------------------------------------------------------------------------
    // 统一入口测试
    // ------------------------------------------------------------------------

    #[test]
    fn test_unified_scan_selects_walk_for_single_thread() {
        let dir = setup_test_dir();
        let mut config = Config::with_root(dir.path().to_path_buf());
        config.scan.show_files = true;
        config.scan.thread_count = std::num::NonZeroUsize::new(1).unwrap();

        let stats = scan(&config).expect("扫描失败");

        assert_eq!(stats.file_count, 5);
    }

    #[test]
    fn test_unified_scan_selects_parallel_for_multi_thread() {
        let dir = setup_test_dir();
        let mut config = Config::with_root(dir.path().to_path_buf());
        config.scan.show_files = true;
        config.scan.thread_count = std::num::NonZeroUsize::new(4).unwrap();

        let stats = scan(&config).expect("扫描失败");

        assert_eq!(stats.file_count, 5);
    }

    #[test]
    fn test_unified_scan_consistency() {
        let dir = setup_test_dir();

        let mut config1 = Config::with_root(dir.path().to_path_buf());
        config1.scan.show_files = true;
        config1.scan.thread_count = std::num::NonZeroUsize::new(1).unwrap();

        let mut config8 = Config::with_root(dir.path().to_path_buf());
        config8.scan.show_files = true;
        config8.scan.thread_count = std::num::NonZeroUsize::new(8).unwrap();

        let stats1 = scan(&config1).expect("单线程扫描失败");
        let stats8 = scan(&config8).expect("多线程扫描失败");

        assert_eq!(stats1.file_count, stats8.file_count);
        assert_eq!(stats1.directory_count, stats8.directory_count);
    }

    // ------------------------------------------------------------------------
    // 边界条件测试
    // ------------------------------------------------------------------------

    #[test]
    fn test_scan_empty_directory() {
        let dir = TempDir::new().unwrap();
        let mut config = Config::with_root(dir.path().to_path_buf());
        config.scan.show_files = true;

        let stats = scan_walk(&config).expect("扫描失败");

        assert_eq!(stats.directory_count, 0);
        assert_eq!(stats.file_count, 0);
    }

    #[test]
    fn test_scan_single_file_directory() {
        let dir = TempDir::new().unwrap();
        File::create(dir.path().join("only.txt")).unwrap();

        let mut config = Config::with_root(dir.path().to_path_buf());
        config.scan.show_files = true;

        let stats = scan_walk(&config).expect("扫描失败");

        assert_eq!(stats.file_count, 1);
    }

    #[test]
    fn test_scan_deeply_nested() {
        let dir = TempDir::new().unwrap();
        let root = dir.path();

        // 创建 5 层嵌套
        let mut current = root.to_path_buf();
        for i in 0..5 {
            current = current.join(format!("level{}", i));
            fs::create_dir(&current).unwrap();
        }
        File::create(current.join("deep.txt")).unwrap();

        let mut config = Config::with_root(root.to_path_buf());
        config.scan.show_files = true;

        let stats = scan_walk(&config).expect("扫描失败");

        assert_eq!(stats.directory_count, 5);
        assert_eq!(stats.file_count, 1);
        assert!(has_node_with_name(&stats.tree, "deep.txt"));
    }

    #[test]
    fn test_scan_with_ignore_case() {
        let dir = TempDir::new().unwrap();
        let root = dir.path();

        File::create(root.join("Test.RS")).unwrap();
        File::create(root.join("other.txt")).unwrap();

        let mut config = Config::with_root(root.to_path_buf());
        config.scan.show_files = true;
        config.matching.include_patterns = vec!["*.rs".to_string()];
        config.matching.ignore_case = true;

        let stats = scan_walk(&config).expect("扫描失败");

        assert_eq!(stats.file_count, 1);
        assert!(has_node_with_name(&stats.tree, "Test.RS"));
    }

    // ------------------------------------------------------------------------
    // 统计信息测试
    // ------------------------------------------------------------------------

    #[test]
    fn test_scan_stats_duration_is_measured() {
        let dir = setup_test_dir();
        let config = Config::with_root(dir.path().to_path_buf());

        let stats = scan_walk(&config).expect("扫描失败");

        // 扫描应该花费一些时间（虽然可能很短）
        assert!(stats.duration.as_nanos() > 0);
    }

    #[test]
    fn test_scan_stats_counts_match_tree() {
        let dir = setup_test_dir();
        let mut config = Config::with_root(dir.path().to_path_buf());
        config.scan.show_files = true;

        let stats = scan_walk(&config).expect("扫描失败");

        // 验证统计信息与树结构一致
        assert_eq!(stats.directory_count, stats.tree.count_directories());
        assert_eq!(stats.file_count, stats.tree.count_files());
    }
}
```

编码规范:  

```markdown
# Rust编码规范说明

## 1. 总体要求

在编写/修改代码时，你使用**中文**编写注释，并遵循以下规范：

- **语言级别:** `Rust 2024 Edition`
- **目标:** 极其严谨、可维护、可审计；代码清晰易读；在最严格工具链下 **0 Warning**。
- **强制工具约束（必须通过）:**
    - `cargo fmt --all --check`
    - `cargo clippy --all-targets --all-features -- -D warnings`
    - `cargo test --all --all-features`
    - `cargo test --doc --all-features`（文档注释必须可测试）
- **严格零警告含义（示例，不限于此）:**
    - 不声明不使用的变量/导入/依赖。
    - 不需要可变的变量**不得**声明为 `mut`（同时确保通过 `clippy::needless_mut` 等相关lint）。
    - 不需要分配/克隆时**不得**无谓 `clone()`/`to_string()`/`Vec::from`。
    - 不得使用“先写出来再说”的占位代码；确需占位应使用明确的 `todo!()` 并附带任务编号/原因/边界（且不得进入主分支产物）。
- **更接近Rust官方风格的额外约束（强制）:**
    - 默认禁止 `unsafe`：优先 `#![forbid(unsafe_code)]`；若必须使用，需在同文件中以最小封装边界隔离，并用文档注释声明不变量与安全性前提。
    - 公共API稳定性优先：避免暴露内部实现细节；优先通过类型系统表达约束（而不是靠注释/约定）。
    - 依赖最小化：不引入未使用/仅为“方便”的crate；引入必须有明确价值与替代方案说明（写在模块文档注释中即可）。

---

## 2. 时间信息维护（修改代码必须同步更新）

任何修改代码的行为，都必须同步更新对应的**时间信息**到最新，且保持一致性：

- 每个文件（模块）开头的模块级文档注释（`//!`）必须包含：
    - `作者: WaterRun`
    - `更新于: YYYY-MM-DD`
- 若文件内存在协议/数据格式/行为约定的时间戳说明：
    - 必须更新到本次修改的实际日期，并确保同文件内不出现相互矛盾的日期。

---

## 3. 类型与API约束（强类型、清晰边界）

- Rust 是静态强类型语言，编译器可推导类型，但在以下位置必须明确标注类型：
    - 函数签名（参数与返回值）
    - 结构体字段
    - 公共 `pub` API
    - 重要 type alias（尤其是跨模块/跨层级语义边界的别名）
- 善用高级类型能力：
    - 泛型 + trait bounds + 关联类型
    - 生命周期参数（必要且最小化暴露）
    - `impl Trait` 简化返回类型（避免暴露内部实现细节）
- 公共API设计遵循 Rust API 习惯：
    - 语义稳定、错误可诊断、命名一致、行为可预期
    - 能用类型表达的不使用运行时检查/魔法值/隐式约定

---

## 4. 编码规范与风格（rustfmt + Clippy + 代码可读性）

- **格式化:** 严格使用 `rustfmt`，不允许手工风格分歧。
- **lint策略（同文件可设置crate级属性）:**
    - `#![deny(warnings)]`（或至少确保等效：`clippy -D warnings`）
    - `#![deny(missing_docs)]`（公共API必须有文档）
    - `#![forbid(unsafe_code)]`（默认禁止；如必须使用，见“总体要求”）
- **可读性优先规则（强制）:**
    - 函数短小、单一职责；超过合理长度必须拆分。
    - 命名表达意图，避免 `tmp/data/foo` 等无语义名。
    - 复杂逻辑用类型/结构化拆解表达，而不是堆注释。
    - 尽量减少“聪明写法”；在清晰与微小性能收益冲突时优先清晰（除非有明确基准证据）。
- **可变性规则（强制，0 Warning导向）:**
    - 默认 `let`；只有确有必要才 `let mut`。
    - 不需可变的绑定/字段/引用不得可变（满足 `clippy::needless_mut` / `clippy::unused_mut` 等）。
    - 缩小可变借用作用域：能在更小块内完成修改就不要跨越更大作用域。
- **未使用值处理（强制）:**
    - 不允许“声明但不使用”。
    - 确需忽略返回值时使用 `let _ = expr;` 或 `_ = expr;`（表达“刻意忽略”）。
    - 迭代中未使用的变量使用 `_` 或 `_name`，且必须是语义上确实不需要。

---

## 5. 错误处理（Result/Option，避免panic）

- 使用 `Result<T, E>` 与 `Option<T>` 表达失败与缺失。
- 避免 `panic! / unwrap() / expect()`：
    - **生产代码**默认禁止；确需不可恢复逻辑错误时必须给出严格不变量说明（写在相关API的文档注释中）。
    - **测试代码**允许 `unwrap/expect`，但失败信息必须清晰可定位。
- 错误类型策略（单文件视角）：
    - 可枚举错误：优先自定义 `enum`（可配合 `thiserror`），保证可匹配与可诊断。
    - 应用层聚合：可用 `anyhow`，但边界处仍需结构化信息（至少错误上下文清晰）。

---

## 6. 文档注释（rustdoc）与“就近测试”（强制）

> “就近的测试”指**写在文档注释中的doctest**：用于验证该API/类型的**基本功能与典型用法**，保持短小、直观、可运行。

- 在以下位置必须写**rustdoc**文档注释：
    - 文件（模块）开头：`//!`
    - 所有公共 `pub` 的函数/结构体/枚举/trait/宏：`///`
- 文档注释必须包含可执行示例，且通过 doctest：
    - 示例使用 ` ```rust ` 代码块，确保 `cargo test --doc --all-features` 通过。
    - 文档示例用于**基本功能验证**：
        - 1～3个短例子覆盖“正常路径”的关键点
        - 避免在文档里堆边界与组合矩阵（这些进入统一单元测试）
    - 对于需要不可运行/仅编译检查的示例，使用：
        - ` ```rust,no_run `（编译但不运行）
        - ` ```compile_fail `（用于验证错误用法）
        - ` ```rust,ignore `（仅在有充分理由时使用，并在文档中说明原因）
- 公共API的文档最低要求：
    - 语义（解决什么问题）
    - 参数/返回值/错误语义
    - `# Examples`（至少1个可测试例子）

---

## 7. 统一单元测试（高覆盖率，放到文件最后）

> 单元测试统一放在文件最后，追求高覆盖率与边缘条件覆盖；与文档示例分工明确：
> - 文档示例：基本功能与典型用法（短）
> - 单元测试：高覆盖率、边界情况、错误分支、组合验证（全）

- 单元测试统一放在文件末尾：
    - `#[cfg(test)] mod tests { ... }`
- 覆盖要求（强制）：
    - 关键逻辑分支必须覆盖（成功/失败路径）
    - 边界条件必须覆盖（空值、最小/最大、溢出/截断、非法输入等按语义定义）
    - 错误分支必须断言错误类型/错误码/错误消息关键片段（避免“只断言失败”）
- 测试命名与结构：
    - 测试名表达行为与条件：`should_xxx_when_yyy`
    - 避免脆弱测试（不要过度依赖内部实现细节）
    - 失败信息清晰可定位（必要时使用 `assert!(.., "context: ...")`）

---

## 8. 命名约定

- **snake_case**: 变量名、函数名、模块名、宏名、字段名（如 `user_name`, `get_total`）
- **SCREAMING_SNAKE_CASE**: 常量、静态变量（如 `MAX_SIZE`, `DEFAULT_TIMEOUT`）
- **PascalCase**: 类型名、trait名、枚举名、枚举变体（如 `DataProcessor`, `ProcessingStatus::Pending`）
- **'a, 'b**: 生命周期参数（如 `'static`, `'a`）
- **T, U, K, V**: 泛型类型参数（如 `T`, `ResultT`）

---

## 9. 文件结构（模块组织顺序）

每个 Rust 文件（模块）必须按以下顺序组织：

1. 模块级文档注释（`//!`，含作者与最后更新日期）
2. 属性声明（`#![...]` / `#[...]`）
3. `use` 语句（按 标准库 / 外部crate / 当前crate 分组；组内按字母序）
4. 模块声明（`mod`，若存在）
5. 常量定义
6. 类型定义（`struct`、`enum`、type alias、`trait`）
7. `impl`（按类型分组，先固有实现再trait实现）
8. 函数定义（按可见性与用途分组）
9. `#[cfg(test)]` 测试模块（**统一放在文件最后**）

---

## 10. 代码即文档（最终原则）

- **原则:** 最大化代码可读性，同时保证库级别高质量规范。
- 除文档注释外尽量减少零散注释；优先通过：
    - 更好的命名
    - 类型与结构拆解
    - 明确的不变量封装
      来表达意图。
- 任何“看起来不直观”的实现都必须满足至少其一：
    - 文档注释中给出可测试示例或不变量说明
    - 有基准/性能约束证据证明必要性
    - 有清晰的审计点与回退策略

```

我需要将输出修改为:  

| 实时滚动输出 | 扫描完成后一次性输出全部内容 | 边扫描边输出，提供实时反馈 | `scan.rs`, `render.rs`, `output.rs`, `main.rs` | 重构为流式架构：扫描模块提供迭代器/channel，渲染模块逐行输出并 flush|

就和原先的tree一样.  
本次对话中, 先不写代码, 构思修改计划, 包括列出所有涉及的文件.  
