# 项目原型合并  

考虑我的项目:  

```plaintext
D:\Rust\tree++
│  Cargo.toml
│  LICENSE
│  OPTIONS-zh.md
│  OPTIONS.md
│  README-zh.md
│  README.md
│
└─src
        cli.rs
        config.rs
        main.rs
        output.rs
        render.rs
        scan.rs
        error.rs
```

文档:  

```markdown
# `tree++`: 好的多的Windows`tree`命令

*[English](./README.md)*

Windows上的`tree`命令自从近40年前发布以来几乎就没有改动. 在如今LLM的时代, 作为描述项目结构非常常用的工具, 仅有的`/f`和`/a`两个参数的功能显然捉襟见肘. 同时, 它很慢.  

**`tree++`是对`tree`的一次全面升级**, 为Windows平台下的`tree`命令引入了:  

- ***扩展参数集, 支持功能涵盖包括显示文件大小, 递归深度限制, 修改输出风格, 将结果输出至文件, 及排除指定目录(包括遵循`.gitignore`)等常用功能***  
- ***支持多线程, 在大且复杂的目录中提供显著的性能提升***
- ***与原有的Windows`tree`命令参数和输出完全兼容, 并兼容使用Unix风格的参数(如`-f`和`--files`)***

**`tree++`使用`Rust`实现**, 开源于[GitHub](https://github.com/Water-Run/treepp).  

*性能对比(以`C:\Windows`为示例):*  

| 类型                | 耗时(`ms`)   | 倍率    |  
|-------------------|------------|-------|  
| 原生`tree`          | `34055.50` | 1.0x  |
| `treepp`(默认, 8线程) | `3480.12`  | 9.79x |
| `treepp`(1线程)     | `6687.58`  | 5.09x |

## 安装

从[Release](https://github.com/Water-Run/treepp/releases/tag/0.1.0)下载`tree++.zip`, 解压到合适目录, 并将目录添加至环境变量.  

开启Windows终端, 执行:  

```powershell
treepp /v
```

有输出:

```plaintext
tree++ version 0.1.0

A Better tree command for Windows.

author: WaterRun
link: https://github.com/Water-Run/treepp
```

即完成安装.

随后, 你可以以和普通的Windows `tree`命令一样的方式使用:

```powershell
treepp /f
```

## 速览

| 参数集(等价写法)                     | 说明                                         |
|-------------------------------|--------------------------------------------|
| `--help` `-h` `/?`            | 显示帮助信息                                     |
| `--version` `-v` `/V`         | 显示版本信息                                     |
| `--ascii` `-a` `/A`           | 使用 ASCII 字符绘制树                             |
| `--files` `-f` `/F`           | 显示文件                                       |
| `--full-path` `-p` `/FP`      | 显示完整路径                                     |
| `--human-readable` `-H` `/HR` | 以人类可读方式显示文件大小                              |
| `--no-indent` `-i` `/NI`      | 不显示树形连接线                                   |
| `--reverse` `-r` `/R`         | 逆序排序                                       |
| `--size` `-s` `/S`            | 显示文件大小(字节)                                 |
| `--date` `-d` `/DT`           | 显示最后修改日期                                   |
| `--exclude` `-I` `/X`         | 排除匹配的文件                                    |
| `--level` `-L` `/L`           | 限制递归深度                                     |
| `--include` `-m` `/M`         | 仅显示匹配的文件                                   |
| `--disk-usage` `-u` `/DU`     | 显示目录累计大小                                   |
| `--ignore-case` `-c` `/IC`    | 匹配时忽略大小写                                   |
| `--report` `-e` `/RP`         | 显示末尾统计信息                                   |
| `--prune` `-P` `/P`           | 修剪空目录                                      |
| `--sort` `-S` `/SO`           | 指定排序方式(`name`、`size`、`mtime` 等)            |
| `--no-win-banner` `-N` `/NB`  | 不显示 Windows 原生 tree 的样板信息                  |
| `--silent` `-l` `/SI`         | 终端静默(结合`output`指令使用)                       |
| `--output` `-o` `/O`          | 将结果输出至文件(`.txt`, `.json`, `.yml`, `.toml`) |
| `--thread` `-t` `/T`          | 扫描线程数(默认为8)                                |
| `--gitignore` `-g` `/G`       | 遵循`.gitignore`                             |


> 完整参数集参阅: [tree++参数集文档](./OPTIONS-zh.md)
```

参数集说明:  

```markdown
# `tree++`: 完整参数说明和示例文档

本文档简述 [tree++](https://github.com/Water-Run/treepp) 所支持的全部参数与使用示例。

## 模拟目录

指令的示例输出基于此模拟目录：

```powershell
PS D:\Rust\tree++> treepp /F
卷 存储 的文件夹 PATH 列表
卷序列号为 26E9-52C1
D:\Rust\tree++
│  Cargo.toml
│  LICENSE
│  OPTIONS-zh.md
│  OPTIONS.md
│  README-zh.md
│  README.md
│
└─src
        cli.rs
        config.rs
        main.rs
        output.rs
        render.rs
        scan.rs
```

> `treepp /F` 与 Windows 原生 `tree /F` 行为完全一致：显示卷头信息和树形结构。直接执行 `treepp` 时亦保持原始语义仅展示目录结构。

## 全局用法

```powershell
treepp [<PATH>] [<OPTIONS>...]
```

- `<PATH>`：可选，默认为当前目录。
- `<OPTIONS>`：可重复、可混用。支持下表列出的 `--`（GNU）、`-`（短参数）与 `/`（CMD，大小写不敏感）三种形式。

## 指令的具体说明

### `/?`: 显示帮助

**功能：** 显示完整的参数帮助信息。

**语法：**

```powershell
treepp (--help | -h | /?) [<PATH>]
```

**示例：**

```powershell
PS D:\Rust\tree++> treepp /?
tree++ - a better tree command for Windows
Usage:
  treepp [path] [options]
Options:
  /H, /?, -h, --help        Show help information
  /V, -v, --version     Show version information
  ...
```

### `/V`: 显示版本

**功能：** 输出当前版本信息。

**语法：**

```powershell
treepp (--version | -v | /V)
```

**示例：**

```powershell
PS D:\Rust\tree++> treepp /V
tree++ version 0.1.0
author: WaterRun
link: https://github.com/Water-Run/treepp
```

### `/A`: 使用 ASCII 字符绘制树

**功能：** 以 ASCII 树形字符输出，兼容 `tree /A`。

**语法：**

```powershell
treepp (--ascii | -a | /A) [<PATH>]
```

**示例：**

```powershell
PS D:\Rust\tree++> treepp /A
卷 存储 的文件夹 PATH 列表
卷序列号为 26E9-52C1
D:\Rust\tree++
\---src
```

### `/F`: 显示文件

**功能：** 在目录树中列出文件条目。

**语法：**

```powershell
treepp (--files | -f | /F) [<PATH>]
```

**示例（与 `/A` 组合）：**

```powershell
PS D:\Rust\tree++> treepp /A /F
卷 存储 的文件夹 PATH 列表
卷序列号为 26E9-52C1
D:\Rust\tree++
|   Cargo.toml
|   LICENSE
|   OPTIONS-zh.md
|   OPTIONS.md
|   README-zh.md
|   README.md
|
\---src
        cli.rs
        config.rs
        main.rs
        output.rs
        render.rs
        scan.rs
```

### `/FP`: 显示完整路径

**功能：** 以绝对路径展示所有条目。

**语法：**

```powershell
treepp (--full-path | -p | /FP) [<PATH>]
```

**示例（与 `/F` 组合）：**

```powershell
PS D:\Rust\tree++> treepp /F /FP
卷 存储 的文件夹 PATH 列表
卷序列号为 26E9-52C1
D:\Rust\tree++
│  D:\Rust\tree++\Cargo.toml
│  D:\Rust\tree++\LICENSE
│  D:\Rust\tree++\OPTIONS-zh.md
│  D:\Rust\tree++\OPTIONS.md
│  D:\Rust\tree++\README-zh.md
│  D:\Rust\tree++\README.md
│
└─D:\Rust\tree++\src
        D:\Rust\tree++\src\cli.rs
        D:\Rust\tree++\src\config.rs
        D:\Rust\tree++\src\main.rs
        D:\Rust\tree++\src\output.rs
        D:\Rust\tree++\src\render.rs
        D:\Rust\tree++\src\scan.rs
```

### `/HR`: 人类可读文件大小

**功能：** 将文件大小转换为 B/KB/MB 等易读单位，常与 `/S` 搭配。

**语法：**

```powershell
treepp (--human-readable | -H | /HR) [<PATH>]
```

**示例（`/S /HR /F`）：**

```powershell
PS D:\Rust\tree++> treepp /S /HR /F
卷 存储 的文件夹 PATH 列表
卷序列号为 26E9-52C1
D:\Rust\tree++
│  Cargo.toml        982 B
│  LICENSE           1.0 KB
│  OPTIONS-zh.md     7.9 KB
│  OPTIONS.md        7.5 KB
│  README-zh.md      10.2 KB
│  README.md         9.1 KB
│
└─src
        cli.rs         6.0 KB
        config.rs      2.8 KB
        main.rs        1.9 KB
        output.rs      7.3 KB
        render.rs      5.2 KB
        scan.rs        8.8 KB
```

### `/S`: 显示文件大小（字节）

**功能：** 显示文件字节数，可与 `/HR` 联用。

**语法：**

```powershell
treepp (--size | -s | /S) [<PATH>]
```

**示例：**

```powershell
PS D:\Rust\tree++> treepp /S /F
卷 存储 的文件夹 PATH 列表
卷序列号为 26E9-52C1
D:\Rust\tree++
│  Cargo.toml        982
│  LICENSE           1067
│  OPTIONS-zh.md     8120
│  OPTIONS.md        7644
│  README-zh.md     10420
│  README.md         9288
│
└─src
        cli.rs         6120
        config.rs      2840
        main.rs        1980
        output.rs      7440
        render.rs      5360
        scan.rs        9020
```

### `/NI`: 不显示树形连接线

**功能：** 用缩进取代树形符号。

**语法：**

```powershell
treepp (--no-indent | -i | /NI) [<PATH>]
```

**示例：**

```powershell
PS D:\Rust\tree++> treepp /F /NI
卷 存储 的文件夹 PATH 列表
卷序列号为 26E9-52C1
D:\Rust\tree++
  Cargo.toml
  LICENSE
  OPTIONS-zh.md
  OPTIONS.md
  README-zh.md
  README.md

  src
    cli.rs
    config.rs
    main.rs
    output.rs
    render.rs
    scan.rs
```

### `/R`: 逆序排序

**功能：** 将当前排序结果倒序输出，可与 `/SO` 组合。

**语法：**

```powershell
treepp (--reverse | -r | /R) [<PATH>]
```

**示例：**

```powershell
PS D:\Rust\tree++> treepp /F /R
卷 存储 的文件夹 PATH 列表
卷序列号为 26E9-52C1
D:\Rust\tree++
│  README.md
│  README-zh.md
│  OPTIONS.md
│  OPTIONS-zh.md
│  LICENSE
│  Cargo.toml
│
└─src
        scan.rs
        render.rs
        output.rs
        main.rs
        config.rs
        cli.rs
```

### `/DT`: 显示最后修改日期

**功能：** 在条目后追加文件/目录的最后修改时间。

**语法：**

```powershell
treepp (--date | -d | /DT) [<PATH>]
```

**示例：**

```powershell
PS D:\Rust\tree++> treepp /F /DT
卷 存储 的文件夹 PATH 列表
卷序列号为 26E9-52C1
D:\Rust\tree++
│  Cargo.toml        2025-12-16 10:02:11
│  LICENSE           2024-11-03 09:00:29
│  OPTIONS-zh.md     2025-12-17 14:20:16
│  OPTIONS.md        2025-12-17 14:18:05
│  README-zh.md      2025-12-18 09:12:40
│  README.md         2025-12-18 09:10:03
│
└─src
        cli.rs         2025-12-17 22:41:12
        config.rs      2025-12-17 22:35:09
        main.rs        2025-12-17 22:12:47
        output.rs      2025-12-17 23:01:58
        render.rs      2025-12-17 22:58:47
        scan.rs        2025-12-17 23:05:58
```

### `/X`: 排除匹配项

**功能：** 忽略与模式匹配的文件或目录。

**语法：**

```powershell
treepp (--exclude | -I | /X) <PATTERN> [<PATH>]
```

**示例（排除 `*.md`）：**

```powershell
PS D:\Rust\tree++> treepp /F /X *.md
卷 存储 的文件夹 PATH 列表
卷序列号为 26E9-52C1
D:\Rust\tree++
│  Cargo.toml
│  LICENSE
│
└─src
        cli.rs
        config.rs
        main.rs
        output.rs
        render.rs
        scan.rs
```

### `/L`: 限制递归深度

**功能：** 指定最大递归层级。

**语法：**

```powershell
treepp (--level | -L | /L) <LEVEL> [<PATH>]
```

**示例（仅展示 1 层）：**

```powershell
PS D:\Rust\tree++> treepp /F /L 1
卷 存储 的文件夹 PATH 列表
卷序列号为 26E9-52C1
D:\Rust\tree++
│  Cargo.toml
│  LICENSE
│  OPTIONS-zh.md
│  OPTIONS.md
│  README-zh.md
│  README.md
│
└─src
```

### `/M`: 仅显示匹配项

**功能：** 只保留符合模式的条目。

**语法：**

```powershell
treepp (--include | -m | /M) <PATTERN> [<PATH>]
```

**示例（仅显示 `*.rs`）：**

```powershell
PS D:\Rust\tree++> treepp /F /M *.rs
卷 存储 的文件夹 PATH 列表
卷序列号为 26E9-52C1
D:\Rust\tree++
│
└─src
        cli.rs
        config.rs
        main.rs
        output.rs
        render.rs
        scan.rs
```

### `/DU`: 显示目录累计大小

**功能：** 统计每个目录的累计磁盘用量，与 `/HR` 配合。

**语法：**

```powershell
treepp (--disk-usage | -u | /DU) [<PATH>]
```

**示例：**

```powershell
PS D:\Rust\tree++> treepp /DU /HR
卷 存储 的文件夹 PATH 列表
卷序列号为 26E9-52C1
D:\Rust\tree++
src             31.5 KB
```

### `/IC`: 匹配时忽略大小写

**功能：** 使 `/M`、`/X` 等匹配指令忽略大小写。

**语法：**

```powershell
treepp (--ignore-case | -c | /IC) [<PATH>]
```

**示例（`/F /M *.MD /IC`）：**

```powershell
PS D:\Rust\tree++> treepp /F /M *.MD /IC
卷 存储 的文件夹 PATH 列表
卷序列号为 26E9-52C1
D:\Rust\tree++
│  OPTIONS-zh.md
│  OPTIONS.md
│  README-zh.md
│  README.md
```

### `/RP`: 显示末尾统计信息

**功能：** 在输出末尾统计信息汇总。

**语法：**

```powershell
treepp (--report | -e | /RP) [<PATH>]
```

**示例：**

```powershell
PS D:\Rust\tree++> treepp /F /RP
卷 存储 的文件夹 PATH 列表
卷序列号为 26E9-52C1
D:\Rust\tree++
│  Cargo.toml
│  LICENSE
│  OPTIONS-zh.md
│  OPTIONS.md
│  README-zh.md
│  README.md
│
└─src
        cli.rs
        config.rs
        main.rs
        output.rs
        render.rs
        scan.rs

1 directory, 12 files in 0.123s
```

### `/P`: 修剪空目录

**功能：** 隐藏不包含内容的目录节点。

**语法：**

```powershell
treepp (--prune | -P | /P) [<PATH>]
```

**示例：**

```powershell
PS D:\Rust\tree++> treepp /P /F
卷 存储 的文件夹 PATH 列表
卷序列号为 26E9-52C1
D:\Rust\tree++
│  Cargo.toml
│  LICENSE
│  OPTIONS-zh.md
│  OPTIONS.md
│  README-zh.md
│  README.md
│
└─src
        cli.rs
        config.rs
        main.rs
        output.rs
        render.rs
        scan.rs
```

### `/SO`: 指定排序方式

**功能：** 依据 `name`、`size`、`mtime` 等字段进行排序，可与 `/R` 组合。

**语法：**

```powershell
treepp (--sort | -S | /SO) <KEY> [<PATH>]
```

**示例（`/F /SO name`）：**

```powershell
PS D:\Rust\tree++> treepp /F /SO name
卷 存储 的文件夹 PATH 列表
卷序列号为 26E9-52C1
D:\Rust\tree++
│  Cargo.toml
│  LICENSE
│  OPTIONS-zh.md
│  OPTIONS.md
│  README-zh.md
│  README.md
│
└─src
        cli.rs
        config.rs
        main.rs
        output.rs
        render.rs
        scan.rs
```

*可选的排序字段及说明:*

| 字段      | 说明        |  
|---------|-----------|  
| `name`  | 按文件名字母表升序 |
| `size`  | 按文件大小升序   |
| `mtime` | 按修改时间升序   |
| `ctime` | 按创建时间升序   |

### `/NB`: 不显示 Windows 原生样板信息

**功能：**
省略 Windows 原生 `tree` 的样板输出。

**语法：**

```powershell
treepp (--no-win-banner | -N | /NB) [<PATH>]
```

**示例：**

```powershell
PS D:\Rust\tree++> treepp /F /NB
D:\Rust\tree++
│  Cargo.toml
│  LICENSE
│  OPTIONS-zh.md
│  OPTIONS.md
│  README-zh.md
│  README.md
│
└─src
        cli.rs
        config.rs
        main.rs
        output.rs
        render.rs
        scan.rs
```

> 建议在性能敏感时开启: `tree++`的对应样板输出是调用原生`tree`对指定的`C:\__treepp__`执行获取的

### `/SI`: 终端静默

**功能：** 禁止向标准输出写入结果，一般与 `/O` 搭配，静默写入文件。

**语法：**

```powershell
treepp (--silent | -l | /SI) [<PATH>]
```

**示例（`/F /O tree.json /SI`）：**

```powershell
PS D:\Rust\tree++> treepp /F /O tree.json /SI
PS D:\Rust\tree++>
```

### `/O`: 输出到文件

**功能：** 将结果持久化到 `.txt` / `.json` / `.yml` / `.toml` 文件。默认仍在控制台输出，可配合 `/SI` 静默。

**语法：**

```powershell
treepp (--output | -o | /O) <FILE.{txt|json|yml|toml}> [<PATH>]
```

**示例：**

```powershell
PS D:\Rust\tree++> treepp /F /O tree.json
卷 存储 的文件夹 PATH 列表
卷序列号为 26E9-52C1
D:\Rust\tree++
│  Cargo.toml
│  LICENSE
│  OPTIONS-zh.md
│  OPTIONS.md
│  README-zh.md
│  README.md
│
└─src
        cli.rs
        config.rs
        main.rs
        output.rs
        render.rs
        scan.rs

output: D:\Rust\tree++\tree.json
```

### `/T`: 扫描线程数

**功能：** 指定扫描线程数量，默认为 8。

**语法：**

```powershell
treepp (--thread | -t | /T) <N> [<PATH>]
```

**示例：**

```powershell
PS D:\Rust\tree++> treepp /F /T 32
卷 存储 的文件夹 PATH 列表
卷序列号为 26E9-52C1
D:\Rust\tree++
│  Cargo.toml
│  LICENSE
│  OPTIONS-zh.md
│  OPTIONS.md
│  README-zh.md
│  README.md
│
└─src
        cli.rs
        config.rs
        main.rs
        output.rs
        render.rs
        scan.rs
```

### `/G`: 遵循 `.gitignore`

**功能：** 解析每级目录中的 `.gitignore` 文件，自动忽略匹配条目。

**语法：**

```powershell
treepp (--gitignore | -g | /G) [<PATH>]
```

**示例：**

```powershell
PS D:\Rust\tree++> treepp /F /G
卷 存储 的文件夹 PATH 列表
卷序列号为 26E9-52C1
D:\Rust\tree++
│  Cargo.toml
│  LICENSE
│  OPTIONS-zh.md
│  OPTIONS.md
│  README-zh.md
│  README.md
│
└─src
        cli.rs
        config.rs
        main.rs
        output.rs
        render.rs
        scan.rs

.gitignore rules applied
```
```

在编写代码时, 有编码规范:  

```markdown
# Rust编码规范说明

## 1. 总体要求

在编写/修改代码时，你使用**中文**编写注释，并遵循以下规范：

- **语言级别:** `Rust 2024 Edition`
- **目标:** 极其严谨、可维护、可审计；代码清晰易读；在最严格工具链下 **0 Warning**。
- **强制工具约束（必须通过）:**
    - `cargo fmt --all --check`
    - `cargo clippy --all-targets --all-features -- -D warnings`
    - `cargo test --all --all-features`
    - `cargo test --doc --all-features`（文档注释必须可测试）
- **严格零警告含义（示例，不限于此）:**
    - 不声明不使用的变量/导入/依赖。
    - 不需要可变的变量**不得**声明为 `mut`（同时确保通过 `clippy::needless_mut` 等相关lint）。
    - 不需要分配/克隆时**不得**无谓 `clone()`/`to_string()`/`Vec::from`。
    - 不得使用“先写出来再说”的占位代码；确需占位应使用明确的 `todo!()` 并附带任务编号/原因/边界（且不得进入主分支产物）。
- **更接近Rust官方风格的额外约束（强制）:**
    - 默认禁止 `unsafe`：优先 `#![forbid(unsafe_code)]`；若必须使用，需在同文件中以最小封装边界隔离，并用文档注释声明不变量与安全性前提。
    - 公共API稳定性优先：避免暴露内部实现细节；优先通过类型系统表达约束（而不是靠注释/约定）。
    - 依赖最小化：不引入未使用/仅为“方便”的crate；引入必须有明确价值与替代方案说明（写在模块文档注释中即可）。

---

## 2. 时间信息维护（修改代码必须同步更新）

任何修改代码的行为，都必须同步更新对应的**时间信息**到最新，且保持一致性：

- 每个文件（模块）开头的模块级文档注释（`//!`）必须包含：
    - `作者: WaterRun`
    - `更新于: YYYY-MM-DD`
- 若文件内存在协议/数据格式/行为约定的时间戳说明：
    - 必须更新到本次修改的实际日期，并确保同文件内不出现相互矛盾的日期。

---

## 3. 类型与API约束（强类型、清晰边界）

- Rust 是静态强类型语言，编译器可推导类型，但在以下位置必须明确标注类型：
    - 函数签名（参数与返回值）
    - 结构体字段
    - 公共 `pub` API
    - 重要 type alias（尤其是跨模块/跨层级语义边界的别名）
- 善用高级类型能力：
    - 泛型 + trait bounds + 关联类型
    - 生命周期参数（必要且最小化暴露）
    - `impl Trait` 简化返回类型（避免暴露内部实现细节）
- 公共API设计遵循 Rust API 习惯：
    - 语义稳定、错误可诊断、命名一致、行为可预期
    - 能用类型表达的不使用运行时检查/魔法值/隐式约定

---

## 4. 编码规范与风格（rustfmt + Clippy + 代码可读性）

- **格式化:** 严格使用 `rustfmt`，不允许手工风格分歧。
- **lint策略（同文件可设置crate级属性）:**
    - `#![deny(warnings)]`（或至少确保等效：`clippy -D warnings`）
    - `#![deny(missing_docs)]`（公共API必须有文档）
    - `#![forbid(unsafe_code)]`（默认禁止；如必须使用，见“总体要求”）
- **可读性优先规则（强制）:**
    - 函数短小、单一职责；超过合理长度必须拆分。
    - 命名表达意图，避免 `tmp/data/foo` 等无语义名。
    - 复杂逻辑用类型/结构化拆解表达，而不是堆注释。
    - 尽量减少“聪明写法”；在清晰与微小性能收益冲突时优先清晰（除非有明确基准证据）。
- **可变性规则（强制，0 Warning导向）:**
    - 默认 `let`；只有确有必要才 `let mut`。
    - 不需可变的绑定/字段/引用不得可变（满足 `clippy::needless_mut` / `clippy::unused_mut` 等）。
    - 缩小可变借用作用域：能在更小块内完成修改就不要跨越更大作用域。
- **未使用值处理（强制）:**
    - 不允许“声明但不使用”。
    - 确需忽略返回值时使用 `let _ = expr;` 或 `_ = expr;`（表达“刻意忽略”）。
    - 迭代中未使用的变量使用 `_` 或 `_name`，且必须是语义上确实不需要。

---

## 5. 错误处理（Result/Option，避免panic）

- 使用 `Result<T, E>` 与 `Option<T>` 表达失败与缺失。
- 避免 `panic! / unwrap() / expect()`：
    - **生产代码**默认禁止；确需不可恢复逻辑错误时必须给出严格不变量说明（写在相关API的文档注释中）。
    - **测试代码**允许 `unwrap/expect`，但失败信息必须清晰可定位。
- 错误类型策略（单文件视角）：
    - 可枚举错误：优先自定义 `enum`（可配合 `thiserror`），保证可匹配与可诊断。
    - 应用层聚合：可用 `anyhow`，但边界处仍需结构化信息（至少错误上下文清晰）。

---

## 6. 文档注释（rustdoc）与“就近测试”（强制）

> “就近的测试”指**写在文档注释中的doctest**：用于验证该API/类型的**基本功能与典型用法**，保持短小、直观、可运行。

- 在以下位置必须写**rustdoc**文档注释：
    - 文件（模块）开头：`//!`
    - 所有公共 `pub` 的函数/结构体/枚举/trait/宏：`///`
- 文档注释必须包含可执行示例，且通过 doctest：
    - 示例使用 ` ```rust ` 代码块，确保 `cargo test --doc --all-features` 通过。
    - 文档示例用于**基本功能验证**：
        - 1～3个短例子覆盖“正常路径”的关键点
        - 避免在文档里堆边界与组合矩阵（这些进入统一单元测试）
    - 对于需要不可运行/仅编译检查的示例，使用：
        - ` ```rust,no_run `（编译但不运行）
        - ` ```compile_fail `（用于验证错误用法）
        - ` ```rust,ignore `（仅在有充分理由时使用，并在文档中说明原因）
- 公共API的文档最低要求：
    - 语义（解决什么问题）
    - 参数/返回值/错误语义
    - `# Examples`（至少1个可测试例子）

---

## 7. 统一单元测试（高覆盖率，放到文件最后）

> 单元测试统一放在文件最后，追求高覆盖率与边缘条件覆盖；与文档示例分工明确：
> - 文档示例：基本功能与典型用法（短）
> - 单元测试：高覆盖率、边界情况、错误分支、组合验证（全）

- 单元测试统一放在文件末尾：
    - `#[cfg(test)] mod tests { ... }`
- 覆盖要求（强制）：
    - 关键逻辑分支必须覆盖（成功/失败路径）
    - 边界条件必须覆盖（空值、最小/最大、溢出/截断、非法输入等按语义定义）
    - 错误分支必须断言错误类型/错误码/错误消息关键片段（避免“只断言失败”）
- 测试命名与结构：
    - 测试名表达行为与条件：`should_xxx_when_yyy`
    - 避免脆弱测试（不要过度依赖内部实现细节）
    - 失败信息清晰可定位（必要时使用 `assert!(.., "context: ...")`）

---

## 8. 命名约定

- **snake_case**: 变量名、函数名、模块名、宏名、字段名（如 `user_name`, `get_total`）
- **SCREAMING_SNAKE_CASE**: 常量、静态变量（如 `MAX_SIZE`, `DEFAULT_TIMEOUT`）
- **PascalCase**: 类型名、trait名、枚举名、枚举变体（如 `DataProcessor`, `ProcessingStatus::Pending`）
- **'a, 'b**: 生命周期参数（如 `'static`, `'a`）
- **T, U, K, V**: 泛型类型参数（如 `T`, `ResultT`）

---

## 9. 文件结构（模块组织顺序）

每个 Rust 文件（模块）必须按以下顺序组织：

1. 模块级文档注释（`//!`，含作者与最后更新日期）
2. 属性声明（`#![...]` / `#[...]`）
3. `use` 语句（按 标准库 / 外部crate / 当前crate 分组；组内按字母序）
4. 模块声明（`mod`，若存在）
5. 常量定义
6. 类型定义（`struct`、`enum`、type alias、`trait`）
7. `impl`（按类型分组，先固有实现再trait实现）
8. 函数定义（按可见性与用途分组）
9. `#[cfg(test)]` 测试模块（**统一放在文件最后**）

---

## 10. 代码即文档（最终原则）

- **原则:** 最大化代码可读性，同时保证库级别高质量规范。
- 除文档注释外尽量减少零散注释；优先通过：
    - 更好的命名
    - 类型与结构拆解
    - 明确的不变量封装
      来表达意图。
- 任何“看起来不直观”的实现都必须满足至少其一：
    - 文档注释中给出可测试示例或不变量说明
    - 有基准/性能约束证据证明必要性
    - 有清晰的审计点与回退策略
```

我编写了多个原型, 这些原型经过了测试, 用于对应部分的最小化实现:  

```plaintext
01_cli_compat:
  参数解析与等价映射. 验证 /,-,-- 三种风格混用、大小写不敏感与冲突校验; 输出解析后的Config用于对拍.

02_scan_engine:
  扫描引擎原型(统一入口). 在同一程序内提供 walk/parallel 两种扫描模式; 验证两者结果一致、并发下不重不漏、线程数生效与确定性排序.

03_match_rules:
  过滤与规则引擎. 验证 include/exclude 通配匹配、ignore-case, 以及分层.gitignore规则叠加与剪枝行为.

04_render_output:
  渲染与输出层. 验证树形文本渲染(ASCII/Unicode/no-indent/quote等)与多格式输出(txt/json/yml/toml)及silent写文件逻辑.
```

我现在准备合并原型至主程序. 现有实现内容包括:  

本次对话中, 你需要编写:  

参考已经测试过的原型实现:  

提供  
已经实现的部分代码如有需要修改的内容指引相应修改.  

---

config.rs
- 定义 Config 及子配置：ScanOptions / MatchOptions / RenderOptions / OutputOptions  
- 定义通用枚举：SortKey、OutputFormat 等  
- 实现 Config::validate()：默认值、冲突校验、派生字段（如 output 扩展名推导 format、thread 下限等）  

error.rs  
- 定义统一错误：AppError、Result<T>
- 统一错误展示格式

需附带config.rs  

cli.rs  
- 参数解析与归一化：/ - -- 三风格混用；/ 大小写不敏感
- 等价映射：如 /F ↔ -f ↔ --files
- 只负责产出 Config, 不做扫描/渲染/输出逻辑
- 调用 Config::validate() 输出可用配置

需附带01_cli_compat  
需附带config.rs, error.rs  

scan.rs
- 定义扫描输出的统一 IR（例如 TreeNode/Entry 等）与 ScanStats
- 实现扫描引擎：walk 与 parallel 两种模式（输出必须一致）  
- 在扫描阶段完成：include/exclude 通配, ignore-case, level 限制, prune（空目录剪枝）, .gitignore 分层叠加与剪枝, 确定性排序：SortKey + reverse  
- 计时入口  

需附带02_scan_engine, 03_match_rules  
需附带config.rs, error.rs  

render.rs  
- 将 scan 的 IR 渲染为文本树：ASCII/Unicode/no-indent
- full-path、size/date/human-readable 的文本拼接与对齐
- report 末尾统计文本（使用 ScanStats）
- Windows 原生 banner 输出控制：默认显示(调用原生 tree 生成 banner)；/NB 禁止  

需附带04_render_output  
需附带config.rs, error.rs, scan.rs  

output.rs  
- 输出策略：stdout、写文件、silent（仅写文件不写 stdout）
- 多格式输出：txt/json/yml/toml（序列化 schema 固定）
- 文件写入策略（建议覆盖写；是否原子写你可固定一种）

需附带04_render_output  
需附带config.rs, error.rs, scan.rs, render.rs  

main.rs  
- 串联主流程：cli -> validate -> scan -> render -> output  
- 统一错误打印与退出码

需附带config.rs, error.rs, cli.rs, scan.rs, render.rs, output.rs  
