# 代码整理  

我的项目:  

```markdown
# `tree++`: 好的多的Windows`tree`命令

*[English](./README.md)*

Windows上的`tree`命令自从近40年前发布以来几乎就没有改动. 在如今LLM的时代, 作为描述项目结构非常常用的工具, 仅有的`/f`和`/a`两个参数的功能显然捉襟见肘. 同时, 它也不太快.  

**`tree++`是对`tree`的一次全面升级**, 为Windows平台下的`tree`命令引入了:  

- ***扩展参数集, 支持功能涵盖包括显示文件大小, 递归深度限制, 修改输出风格, 将结果输出至文件, 及排除指定目录(包括遵循`.gitignore`)等常用功能***  
- ***Rust的实现更好的性能, 在批处理模式下更支持多线程, 提供显著的扫描速度提升***
- ***与原有的Windows`tree`命令参数和输出格式完全兼容, 并可使用Unix风格的参数(如`-f`和`--files`)***

**`tree++`使用`Rust`实现**, 开源于[GitHub](https://github.com/Water-Run/treepp).  

*性能对比(以`C:\Windows`为示例):*  

| 类型                         |  耗时 (`ms`) |       倍率 |
|----------------------------|-----------:|---------:|
| `tree /f` (Windows Native) | `34367.81` |  `1.00x` |
| `treepp /f`                |  `8948.63` |  `3.84x` |
| `treepp /f /nb`            |  `8690.36` |  `3.95x` |
| `treepp /f /nb /b`         |  `3816.34` |  `9.01x` |
| `treepp /f /nb /b /t 1`    | `10672.62` |  `3.22x` |
| `treepp /f /nb /b /t 2`    |  `6769.22` |  `5.08x` |
| `treepp /f /nb /b /t 4`    |  `4717.16` |  `7.29x` |
| `treepp /f /nb /b /t 8`    |  `3797.09` |  `9.05x` |
| `treepp /f /nb /b /t 16`   |  `3026.32` | `11.36x` |
| `treepp /f /nb /b /t 32`   |  `3013.44` | `11.40x` |

## 安装

从[Release](https://github.com/Water-Run/treepp/releases/tag/0.1.0)下载`tree++.zip`, 解压到合适目录, 并将目录添加至环境变量.  

开启Windows终端, 执行:  

```powershell
treepp /v
```

有输出:

```plaintext
tree++ version 0.1.0

A Much Better Windows tree Command.

author: WaterRun
link: https://github.com/Water-Run/treepp
```

即完成安装.

随后, 你可以以和普通的Windows `tree`命令一样的方式使用:

```powershell
treepp /f
```

## 速览

| 参数集(等价写法)                     | 说明                                         |
|-------------------------------|--------------------------------------------|
| `--help` `-h` `/?`            | 显示帮助信息                                     |
| `--version` `-v` `/V`         | 显示版本信息                                     |
| `--ascii` `-a` `/A`           | 使用 ASCII 字符绘制树                             |
| `--files` `-f` `/F`           | 显示文件                                       |
| `--full-path` `-p` `/FP`      | 显示完整路径                                     |
| `--human-readable` `-H` `/HR` | 以人类可读方式显示文件大小                              |
| `--no-indent` `-i` `/NI`      | 不显示树形连接线                                   |
| `--reverse` `-r` `/R`         | 逆序排序                                       |
| `--size` `-s` `/S`            | 显示文件大小(字节)                                 |
| `--date` `-d` `/DT`           | 显示最后修改日期                                   |
| `--exclude` `-I` `/X`         | 排除匹配的文件                                    |
| `--level` `-L` `/L`           | 限制递归深度                                     |
| `--include` `-m` `/M`         | 仅显示匹配的文件                                   |
| `--disk-usage` `-u` `/DU`     | 显示目录累计大小                                   |
| `--report` `-e` `/RP`         | 显示末尾统计信息                                   |
| `--prune` `-P` `/P`           | 修剪空目录                                      |
| `--no-win-banner` `-N` `/NB`  | 不显示 Windows 原生 tree 的样板信息                  |
| `--silent` `-l` `/SI`         | 终端静默(结合`output`指令使用)                       |
| `--output` `-o` `/O`          | 将结果输出至文件(`.txt`, `.json`, `.yml`, `.toml`) |
| `--batch` `-b` `/B`           | 使用批处理模式                                    |
| `--thread` `-t` `/T`          | 扫描线程数(批处理模式, 默认8线程)                        |
| `--gitignore` `-g` `/G`       | 遵循`.gitignore`                             |

> 完整参数集参阅: [tree++参数集文档](./OPTIONS-zh.md)

```

```cmd
PS D:\数据\Rust\tree++> treepp /f /x sim.py /x .git /g
卷 存储 的文件夹 PATH 列表
卷序列号为 26E9-52C1
D:.
│   .gitignore
│   Cargo.lock
│   Cargo.toml
│   LICENSE
│   OPTIONS-zh.md
│   OPTIONS.md
│   README-zh.md
│   README.md
│
├─prompts
│       代码整理.md
│       编码规范.md
├─src
│       cli.rs
│       config.rs
│       error.rs
│       main.rs
│       output.rs
│       render.rs
│       scan.rs
└─tests
        compatibility_test.rs
        functional_test.rs
        performance_test.rs
```

请整理以下代码, 契合编码规范:

```markdown
# Rust编码规范说明

## 1. 总体要求

在编写/修改代码时，你使用**英文**编写注释，并遵循以下规范：

- **语言级别:** `Rust 2024 Edition`
- **目标:** 极其严谨、可维护、可审计；代码清晰易读；在最严格工具链下 **0 Warning**。
- **强制工具约束（必须通过）:**
    - `cargo fmt --all --check`
    - `cargo clippy --all-targets --all-features -- -D warnings`
    - `cargo test --all --all-features`
    - `cargo test --doc --all-features`（文档注释必须可测试）
- **严格零警告含义（示例，不限于此）:**
    - 不声明不使用的变量/导入/依赖。
    - 不需要可变的变量**不得**声明为 `mut`（同时确保通过 `clippy::needless_mut` 等相关lint）。
    - 不需要分配/克隆时**不得**无谓 `clone()`/`to_string()`/`Vec::from`。
    - 不得使用“先写出来再说”的占位代码；确需占位应使用明确的 `todo!()` 并附带任务编号/原因/边界（且不得进入主分支产物）。
- **更接近Rust官方风格的额外约束（强制）:**
    - 默认禁止 `unsafe`：优先 `#![forbid(unsafe_code)]`；若必须使用，需在同文件中以最小封装边界隔离，并用文档注释声明不变量与安全性前提。
    - 公共API稳定性优先：避免暴露内部实现细节；优先通过类型系统表达约束（而不是靠注释/约定）。
    - 依赖最小化：不引入未使用/仅为“方便”的crate；引入必须有明确价值与替代方案说明（写在模块文档注释中即可）。

---

## 2. 时间信息维护（修改代码必须同步更新）

任何修改代码的行为，都必须同步更新对应的**时间信息**到最新，且保持一致性：

- 每个文件（模块）开头的模块级文档注释（`//!`）必须包含：
    - `Author: WaterRun`
    - `Date: YYYY-MM-DD`
- 若文件内存在协议/数据格式/行为约定的时间戳说明：
    - 必须更新到本次修改的实际日期，并确保同文件内不出现相互矛盾的日期。

---

## 3. 类型与API约束（强类型、清晰边界）

- Rust 是静态强类型语言，编译器可推导类型，但在以下位置必须明确标注类型：
    - 函数签名（参数与返回值）
    - 结构体字段
    - 公共 `pub` API
    - 重要 type alias（尤其是跨模块/跨层级语义边界的别名）
- 善用高级类型能力：
    - 泛型 + trait bounds + 关联类型
    - 生命周期参数（必要且最小化暴露）
    - `impl Trait` 简化返回类型（避免暴露内部实现细节）
- 公共API设计遵循 Rust API 习惯：
    - 语义稳定、错误可诊断、命名一致、行为可预期
    - 能用类型表达的不使用运行时检查/魔法值/隐式约定

---

## 4. 编码规范与风格（rustfmt + Clippy + 代码可读性）

- **格式化:** 严格使用 `rustfmt`，不允许手工风格分歧。
- **lint策略（同文件可设置crate级属性）:**
    - `#![deny(warnings)]`（或至少确保等效：`clippy -D warnings`）
    - `#![deny(missing_docs)]`（公共API必须有文档）
    - `#![forbid(unsafe_code)]`（默认禁止；如必须使用，见“总体要求”）
- **可读性优先规则（强制）:**
    - 函数短小、单一职责；超过合理长度必须拆分。
    - 命名表达意图，避免 `tmp/data/foo` 等无语义名。
    - 复杂逻辑用类型/结构化拆解表达，而不是堆注释。
    - 尽量减少“聪明写法”；在清晰与微小性能收益冲突时优先清晰（除非有明确基准证据）。
- **可变性规则（强制，0 Warning导向）:**
    - 默认 `let`；只有确有必要才 `let mut`。
    - 不需可变的绑定/字段/引用不得可变（满足 `clippy::needless_mut` / `clippy::unused_mut` 等）。
    - 缩小可变借用作用域：能在更小块内完成修改就不要跨越更大作用域。
- **未使用值处理（强制）:**
    - 不允许“声明但不使用”。
    - 确需忽略返回值时使用 `let _ = expr;` 或 `_ = expr;`（表达“刻意忽略”）。
    - 迭代中未使用的变量使用 `_` 或 `_name`，且必须是语义上确实不需要。

---

## 5. 错误处理（Result/Option，避免panic）

- 使用 `Result<T, E>` 与 `Option<T>` 表达失败与缺失。
- 避免 `panic! / unwrap() / expect()`：
    - **生产代码**默认禁止；确需不可恢复逻辑错误时必须给出严格不变量说明（写在相关API的文档注释中）。
    - **测试代码**允许 `unwrap/expect`，但失败信息必须清晰可定位。
- 错误类型策略（单文件视角）：
    - 可枚举错误：优先自定义 `enum`（可配合 `thiserror`），保证可匹配与可诊断。
    - 应用层聚合：可用 `anyhow`，但边界处仍需结构化信息（至少错误上下文清晰）。

---

## 6. 文档注释（rustdoc）与“就近测试”（强制）

> “就近的测试”指**写在文档注释中的doctest**：用于验证该API/类型的**基本功能与典型用法**，保持短小、直观、可运行。

- 在以下位置必须写**rustdoc**文档注释：
    - 文件（模块）开头：`//!`
    - 所有公共 `pub` 的函数/结构体/枚举/trait/宏：`///`
- 文档注释必须包含可执行示例，且通过 doctest：
    - 示例使用 ` ```rust ` 代码块，确保 `cargo test --doc --all-features` 通过。
    - 文档示例用于**基本功能验证**：
        - 1～3个短例子覆盖“正常路径”的关键点
        - 避免在文档里堆边界与组合矩阵（这些进入统一单元测试）
    - 对于需要不可运行/仅编译检查的示例，使用：
        - ` ```rust,no_run `（编译但不运行）
        - ` ```compile_fail `（用于验证错误用法）
        - ` ```rust,ignore `（仅在有充分理由时使用，并在文档中说明原因）
- 公共API的文档最低要求：
    - 语义（解决什么问题）
    - 参数/返回值/错误语义
    - `# Examples`（至少1个可测试例子）

---

## 7. 统一单元测试（高覆盖率，放到文件最后）

> 单元测试统一放在文件最后，追求高覆盖率与边缘条件覆盖；与文档示例分工明确：
> - 文档示例：基本功能与典型用法（短）
> - 单元测试：高覆盖率、边界情况、错误分支、组合验证（全）

- 单元测试统一放在文件末尾：
    - `#[cfg(test)] mod tests { ... }`
- 覆盖要求（强制）：
    - 关键逻辑分支必须覆盖（成功/失败路径）
    - 边界条件必须覆盖（空值、最小/最大、溢出/截断、非法输入等按语义定义）
    - 错误分支必须断言错误类型/错误码/错误消息关键片段（避免“只断言失败”）
- 测试命名与结构：
    - 测试名表达行为与条件：`should_xxx_when_yyy`
    - 避免脆弱测试（不要过度依赖内部实现细节）
    - 失败信息清晰可定位（必要时使用 `assert!(.., "context: ...")`）

---

## 8. 命名约定

- **snake_case**: 变量名、函数名、模块名、宏名、字段名（如 `user_name`, `get_total`）
- **SCREAMING_SNAKE_CASE**: 常量、静态变量（如 `MAX_SIZE`, `DEFAULT_TIMEOUT`）
- **PascalCase**: 类型名、trait名、枚举名、枚举变体（如 `DataProcessor`, `ProcessingStatus::Pending`）
- **'a, 'b**: 生命周期参数（如 `'static`, `'a`）
- **T, U, K, V**: 泛型类型参数（如 `T`, `ResultT`）

---

## 9. 文件结构（模块组织顺序）

每个 Rust 文件（模块）必须按以下顺序组织：

1. 模块级文档注释（`//!`，含作者与最后更新日期）
2. 属性声明（`#![...]` / `#[...]`）
3. `use` 语句（按 标准库 / 外部crate / 当前crate 分组；组内按字母序）
4. 模块声明（`mod`，若存在）
5. 常量定义
6. 类型定义（`struct`、`enum`、type alias、`trait`）
7. `impl`（按类型分组，先固有实现再trait实现）
8. 函数定义（按可见性与用途分组）
9. `#[cfg(test)]` 测试模块（**统一放在文件最后**）

---

## 10. 代码即文档（最终原则）

- **原则:** 最大化代码可读性，同时保证库级别高质量规范。
- 除文档注释外尽量减少零散注释；优先通过：
    - 更好的命名
    - 类型与结构拆解
    - 明确的不变量封装
      来表达意图。
- 任何“看起来不直观”的实现都必须满足至少其一：
    - 文档注释中给出可测试示例或不变量说明
    - 有基准/性能约束证据证明必要性
    - 有清晰的审计点与回退策略

```

```rust

```

请注意, 每一个函数, 结构体, 枚举, 实现, 结构体等都要完善的文档注释: 包括说明, 参数, 返回值, 一个至多个文档测试等等.  
文档注释使用英文, 代码中不要有任何中文部分(测试的有关部分除外, 我是中文系统).  
另外, 代码即文档的风格, 移除各种冗余注释. 对于除文档字符串外的注释, 仅保留"如果移除就非常难看懂"的部分, 即基本上不要有任何冗余注释--因为此时应当遵循代码即文档, 将代码写的浅显易懂.  
同时, 修改代码的顺序, 包含测试部分, 或者实现等, 使其结构更清晰. 
你可以重命名单元测试为更合适的名字.  
扩写原有的单元测试, 大致多20%, 涵盖更多原有的单元测试未覆盖的编译情况.  
修改后的代码行为和功能不能有任何变动, 尤其是对外暴露的接口及调用等必须完全一致. 只是调整优化可读性和规范.  
请提供我重写后的完整代码: 提升代码质量, 遵循最规范的Rust 2024.  
